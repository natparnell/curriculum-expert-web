<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Wave Interference Simulator</title>
<style>
    :root {
        --bg-primary: #0a0e1a;
        --bg-secondary: #111827;
        --bg-panel: #1a2235;
        --bg-control: #1e293b;
        --border-color: #2a3a52;
        --text-primary: #e2e8f0;
        --text-secondary: #94a3b8;
        --text-muted: #64748b;
        --accent-cyan: #06d6e0;
        --accent-teal: #14b8a6;
        --accent-blue: #3b82f6;
        --accent-purple: #8b5cf6;
        --accent-orange: #f59e0b;
        --accent-red: #ef4444;
        --accent-green: #22c55e;
        --wave-crest: #06d6e0;
        --wave-trough: #0a0e1a;
        --header-height: 72px;
        --radius: 8px;
        --radius-lg: 12px;
        --shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        --font-mono: 'Courier New', monospace;
    }

    *, *::before, *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }

    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: var(--bg-primary);
        color: var(--text-primary);
        min-height: 100vh;
        overflow-x: hidden;
    }

    header {
        position: sticky;
        top: 0;
        z-index: 100;
        background: linear-gradient(135deg, var(--bg-secondary), var(--bg-panel));
        border-bottom: 2px solid var(--accent-cyan);
        padding: 12px 24px;
        height: var(--header-height);
        display: flex;
        align-items: center;
        justify-content: space-between;
        box-shadow: var(--shadow);
    }

    .header-left h1 {
        font-size: 1.4rem;
        font-weight: 700;
        color: var(--accent-cyan);
        letter-spacing: 0.5px;
    }

    .header-left p {
        font-size: 0.8rem;
        color: var(--text-secondary);
        margin-top: 2px;
    }

    .header-right {
        display: flex;
        align-items: center;
        gap: 12px;
    }

    .header-badge {
        background: var(--bg-control);
        border: 1px solid var(--border-color);
        border-radius: var(--radius);
        padding: 4px 12px;
        font-size: 0.75rem;
        color: var(--accent-teal);
        font-family: var(--font-mono);
    }

    main {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    .sim-layout {
        display: grid;
        grid-template-columns: 1fr 280px;
        gap: 20px;
    }

    .canvas-wrapper {
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-lg);
        overflow: hidden;
        position: relative;
        box-shadow: var(--shadow);
    }

    canvas {
        display: block;
        width: 100%;
        cursor: crosshair;
    }

    .canvas-overlay {
        position: absolute;
        top: 10px;
        left: 10px;
        display: flex;
        flex-direction: column;
        gap: 6px;
        pointer-events: none;
    }

    .overlay-tag {
        background: rgba(10, 14, 26, 0.8);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 3px 8px;
        font-size: 0.7rem;
        color: var(--text-secondary);
        font-family: var(--font-mono);
        pointer-events: none;
    }

    .overlay-tag span {
        color: var(--accent-cyan);
    }

    .controls-sidebar {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .control-card {
        background: var(--bg-panel);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-lg);
        padding: 16px;
        box-shadow: var(--shadow);
    }

    .control-card h3 {
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--accent-teal);
        margin-bottom: 12px;
        padding-bottom: 8px;
        border-bottom: 1px solid var(--border-color);
    }

    .slider-group {
        margin-bottom: 14px;
    }

    .slider-group:last-child {
        margin-bottom: 0;
    }

    .slider-label {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 6px;
    }

    .slider-label span:first-child {
        font-size: 0.8rem;
        color: var(--text-secondary);
    }

    .slider-value {
        font-size: 0.75rem;
        font-family: var(--font-mono);
        color: var(--accent-cyan);
        background: var(--bg-primary);
        padding: 2px 8px;
        border-radius: 4px;
    }

    input[type="range"] {
        width: 100%;
        height: 6px;
        -webkit-appearance: none;
        appearance: none;
        background: var(--bg-primary);
        border-radius: 3px;
        outline: none;
        cursor: pointer;
    }

    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--accent-cyan);
        cursor: pointer;
        border: 2px solid var(--bg-primary);
        box-shadow: 0 0 6px rgba(6, 214, 224, 0.4);
    }

    input[type="range"]::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--accent-cyan);
        cursor: pointer;
        border: 2px solid var(--bg-primary);
    }

    .btn-row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
    }

    .btn {
        flex: 1;
        min-width: 0;
        padding: 8px 10px;
        border: 1px solid var(--border-color);
        border-radius: var(--radius);
        background: var(--bg-control);
        color: var(--text-primary);
        font-size: 0.78rem;
        cursor: pointer;
        transition: all 0.2s;
        text-align: center;
        white-space: nowrap;
    }

    .btn:hover {
        border-color: var(--accent-cyan);
        background: rgba(6, 214, 224, 0.1);
    }

    .btn.active {
        background: rgba(6, 214, 224, 0.15);
        border-color: var(--accent-cyan);
        color: var(--accent-cyan);
    }

    .btn-primary {
        background: var(--accent-cyan);
        color: var(--bg-primary);
        border-color: var(--accent-cyan);
        font-weight: 600;
    }

    .btn-primary:hover {
        background: var(--accent-teal);
        border-color: var(--accent-teal);
        color: var(--bg-primary);
    }

    .toggle-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 6px 0;
    }

    .toggle-row span {
        font-size: 0.8rem;
        color: var(--text-secondary);
    }

    .toggle-switch {
        position: relative;
        width: 40px;
        height: 22px;
        cursor: pointer;
    }

    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .toggle-track {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--bg-primary);
        border-radius: 11px;
        border: 1px solid var(--border-color);
        transition: 0.3s;
    }

    .toggle-track::before {
        content: '';
        position: absolute;
        width: 16px;
        height: 16px;
        left: 2px;
        bottom: 2px;
        background: var(--text-muted);
        border-radius: 50%;
        transition: 0.3s;
    }

    .toggle-switch input:checked + .toggle-track {
        background: rgba(6, 214, 224, 0.2);
        border-color: var(--accent-cyan);
    }

    .toggle-switch input:checked + .toggle-track::before {
        transform: translateX(18px);
        background: var(--accent-cyan);
    }

    .readout-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
    }

    .readout {
        background: var(--bg-primary);
        border-radius: var(--radius);
        padding: 8px;
        text-align: center;
    }

    .readout-label {
        font-size: 0.65rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: var(--text-muted);
        margin-bottom: 4px;
    }

    .readout-value {
        font-size: 0.9rem;
        font-family: var(--font-mono);
        color: var(--accent-cyan);
    }

    .info-section {
        background: var(--bg-panel);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-lg);
        padding: 24px;
        box-shadow: var(--shadow);
    }

    .info-section h2 {
        font-size: 1.1rem;
        color: var(--accent-cyan);
        margin-bottom: 16px;
        padding-bottom: 10px;
        border-bottom: 1px solid var(--border-color);
    }

    .info-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 16px;
    }

    .info-card {
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: var(--radius);
        padding: 16px;
    }

    .info-card h4 {
        font-size: 0.85rem;
        color: var(--accent-teal);
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .info-card h4 .icon {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.7rem;
        flex-shrink: 0;
    }

    .info-card p, .info-card ul {
        font-size: 0.8rem;
        color: var(--text-secondary);
        line-height: 1.6;
    }

    .info-card ul {
        list-style: none;
        padding: 0;
    }

    .info-card ul li {
        padding-left: 16px;
        position: relative;
        margin-bottom: 4px;
    }

    .info-card ul li::before {
        content: '';
        position: absolute;
        left: 0;
        top: 8px;
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: var(--accent-cyan);
    }

    .formula {
        background: var(--bg-primary);
        border-radius: var(--radius);
        padding: 8px 12px;
        font-family: var(--font-mono);
        font-size: 0.8rem;
        color: var(--accent-orange);
        margin: 8px 0;
        border-left: 3px solid var(--accent-orange);
    }

    .source-indicator {
        position: absolute;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.6rem;
        font-weight: 700;
        color: var(--bg-primary);
        pointer-events: none;
        z-index: 5;
        transform: translate(-50%, -50%);
    }

    .source-indicator.s1 {
        background: var(--accent-cyan);
        box-shadow: 0 0 10px rgba(6, 214, 224, 0.6);
    }

    .source-indicator.s2 {
        background: var(--accent-purple);
        box-shadow: 0 0 10px rgba(139, 92, 246, 0.6);
    }

    .legend {
        display: flex;
        align-items: center;
        gap: 16px;
        padding: 8px 0;
        flex-wrap: wrap;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 0.75rem;
        color: var(--text-secondary);
    }

    .legend-swatch {
        width: 12px;
        height: 12px;
        border-radius: 3px;
    }

    @media (max-width: 900px) {
        .sim-layout {
            grid-template-columns: 1fr;
        }
        .controls-sidebar {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        header {
            padding: 10px 16px;
        }
        .header-left h1 {
            font-size: 1.1rem;
        }
        main {
            padding: 12px;
        }
    }

    @media (max-width: 600px) {
        .controls-sidebar {
            grid-template-columns: 1fr;
        }
        .info-grid {
            grid-template-columns: 1fr;
        }
        .header-badge {
            display: none;
        }
    }
</style>
</head>
<body>

<header>
    <div class="header-left">
        <h1>Wave Interference Simulator</h1>
        <p>Two-source ripple tank: superposition, constructive and destructive interference</p>
    </div>
    <div class="header-right">
        <span class="header-badge" id="fpsDisplay">-- FPS</span>
    </div>
</header>

<main>
    <div class="sim-layout">
        <div class="canvas-wrapper" id="canvasWrapper">
            <canvas id="simCanvas" width="700" height="500"></canvas>
            <div class="canvas-overlay">
                <div class="overlay-tag">S1: <span id="s1Pos">--</span></div>
                <div class="overlay-tag">S2: <span id="s2Pos">--</span></div>
                <div class="overlay-tag" id="pointerInfo" style="display:none">Cursor: <span id="pointerPos">--</span></div>
            </div>
            <div class="source-indicator s1" id="s1Label">1</div>
            <div class="source-indicator s2" id="s2Label">2</div>
        </div>

        <div class="controls-sidebar">
            <div class="control-card">
                <h3>Playback</h3>
                <div class="btn-row" style="margin-bottom:12px">
                    <button class="btn btn-primary" id="btnPlayPause">Pause</button>
                    <button class="btn" id="btnReset">Reset</button>
                </div>
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Speed</span>
                        <span class="slider-value" id="speedVal">1.0x</span>
                    </div>
                    <input type="range" id="speedSlider" min="0.1" max="3" step="0.1" value="1">
                </div>
            </div>

            <div class="control-card">
                <h3>Wave Properties</h3>
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Frequency</span>
                        <span class="slider-value" id="freqVal">3.0 Hz</span>
                    </div>
                    <input type="range" id="freqSlider" min="1" max="8" step="0.1" value="3">
                </div>
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Amplitude</span>
                        <span class="slider-value" id="ampVal">1.0</span>
                    </div>
                    <input type="range" id="ampSlider" min="0.2" max="1.5" step="0.05" value="1">
                </div>
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Wavelength</span>
                        <span class="slider-value" id="wlVal">-- px</span>
                    </div>
                </div>
            </div>

            <div class="control-card">
                <h3>Display</h3>
                <div class="toggle-row">
                    <span>Superposition</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="togSuper" checked>
                        <span class="toggle-track"></span>
                    </label>
                </div>
                <div class="toggle-row">
                    <span>Source 1 Only</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="togS1">
                        <span class="toggle-track"></span>
                    </label>
                </div>
                <div class="toggle-row">
                    <span>Source 2 Only</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="togS2">
                        <span class="toggle-track"></span>
                    </label>
                </div>
                <div class="toggle-row">
                    <span>Nodal Lines</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="togNodal">
                        <span class="toggle-track"></span>
                    </label>
                </div>
                <div class="toggle-row">
                    <span>Grid Overlay</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="togGrid">
                        <span class="toggle-track"></span>
                    </label>
                </div>
            </div>

            <div class="control-card">
                <h3>Readouts</h3>
                <div class="readout-grid">
                    <div class="readout">
                        <div class="readout-label">Separation</div>
                        <div class="readout-value" id="readSep">-- px</div>
                    </div>
                    <div class="readout">
                        <div class="readout-label">Wave Speed</div>
                        <div class="readout-value" id="readSpeed">-- px/s</div>
                    </div>
                    <div class="readout">
                        <div class="readout-label">Period</div>
                        <div class="readout-value" id="readPeriod">-- s</div>
                    </div>
                    <div class="readout">
                        <div class="readout-label">Time</div>
                        <div class="readout-value" id="readTime">0.0 s</div>
                    </div>
                </div>
                <div class="legend" style="margin-top:10px">
                    <div class="legend-item">
                        <div class="legend-swatch" style="background:var(--accent-cyan)"></div>
                        Crest
                    </div>
                    <div class="legend-item">
                        <div class="legend-swatch" style="background:#0a0e1a; border:1px solid var(--border-color)"></div>
                        Trough
                    </div>
                    <div class="legend-item">
                        <div class="legend-swatch" style="background:var(--accent-red)"></div>
                        Nodal line
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="info-section">
        <h2>Understanding Wave Interference</h2>
        <div class="info-grid">
            <div class="info-card">
                <h4><span class="icon" style="background:var(--accent-cyan); color:var(--bg-primary)">+</span> Superposition Principle</h4>
                <p>When two or more waves overlap in the same region, the resultant displacement at any point is the sum of the individual displacements from each wave. This is the principle of superposition.</p>
                <div class="formula">y_total = y_1 + y_2</div>
                <p>Each point on the canvas calculates the displacement from Source 1 and Source 2, then adds them together to find the combined amplitude.</p>
            </div>
            <div class="info-card">
                <h4><span class="icon" style="background:var(--accent-green); color:var(--bg-primary)">C</span> Constructive Interference</h4>
                <p>When two waves arrive at a point in phase (crest meets crest, or trough meets trough), they reinforce each other. The result is a combined wave with greater amplitude.</p>
                <div class="formula">Path difference = n x wavelength (n = 0, 1, 2...)</div>
                <p>On the canvas, constructive interference appears as the brightest regions, where crests from both sources arrive at the same time.</p>
            </div>
            <div class="info-card">
                <h4><span class="icon" style="background:var(--accent-red); color:var(--bg-primary)">D</span> Destructive Interference</h4>
                <p>When two waves arrive out of phase (crest meets trough), they cancel each other. The displacement drops towards zero in these regions.</p>
                <div class="formula">Path difference = (n + 0.5) x wavelength</div>
                <p>Nodal lines are the curves along which destructive interference always occurs. Toggle them on to see the pattern. These lines form hyperbolic shapes between the two sources.</p>
            </div>
            <div class="info-card">
                <h4><span class="icon" style="background:var(--accent-orange); color:var(--bg-primary)">?</span> Real-World Applications</h4>
                <ul>
                    <li><strong>Noise-cancelling headphones</strong>: generate an "anti-wave" that destructively interferes with ambient noise, reducing what you hear.</li>
                    <li><strong>Thin film interference</strong>: colourful patterns on soap bubbles and oil slicks arise from interference of light waves reflecting off the top and bottom surfaces of a thin film.</li>
                    <li><strong>Radio and Wi-Fi signals</strong>: dead spots in reception can result from destructive interference between direct and reflected signals.</li>
                    <li><strong>Musical acoustics</strong>: standing waves in instruments are the result of superposition of reflected waves.</li>
                </ul>
            </div>
        </div>
    </div>
</main>

<script>
(function() {
    'use strict';

    /* ========== Canvas Setup ========== */
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    const wrapper = document.getElementById('canvasWrapper');

    const W = 700;
    const H = 500;
    canvas.width = W;
    canvas.height = H;

    /* ========== State ========== */
    const state = {
        sources: [
            { x: 220, y: 250 },
            { x: 480, y: 250 }
        ],
        frequency: 3.0,
        amplitude: 1.0,
        speed: 1.0,
        waveSpeed: 120,
        playing: true,
        time: 0,
        showSuper: true,
        showS1: false,
        showS2: false,
        showNodal: false,
        showGrid: false,
        dragging: -1
    };

    /* ========== Image Data for Pixel Drawing ========== */
    const imageData = ctx.createImageData(W, H);
    const pixels = imageData.data;

    /* ========== Colour helpers ========== */
    function waveColor(val) {
        // val in range [-1, 1]. Map to colour.
        // -1 = deep navy (trough), 0 = mid dark, +1 = bright cyan (crest)
        const t = (val + 1) * 0.5; // 0 to 1
        const r = Math.round(10 + t * 0);
        const g = Math.round(14 + t * 200);
        const b = Math.round(26 + t * 198);
        return [r, g, b];
    }

    function waveColorS1(val) {
        const t = (val + 1) * 0.5;
        return [
            Math.round(6 + t * 0),
            Math.round(14 + t * 200),
            Math.round(26 + t * 198)
        ];
    }

    function waveColorS2(val) {
        const t = (val + 1) * 0.5;
        return [
            Math.round(20 + t * 119),
            Math.round(10 + t * 72),
            Math.round(30 + t * 216)
        ];
    }

    /* ========== Wave displacement at a point ========== */
    function displacement(sx, sy, px, py, time, freq, amp, waveSpd) {
        const dx = px - sx;
        const dy = py - sy;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const wavelength = waveSpd / freq;
        const k = (2 * Math.PI) / wavelength;
        const omega = 2 * Math.PI * freq;
        // Attenuate with distance (2D circular wave: 1/sqrt(r))
        const minDist = 5;
        const atten = 1 / Math.sqrt(Math.max(dist, minDist) / 20);
        const clampedAtten = Math.min(atten, 1);
        return amp * clampedAtten * Math.sin(k * dist - omega * time);
    }

    /* ========== Render Frame ========== */
    const STEP = 2; // render every 2nd pixel for performance, fill 2x2 blocks

    function renderFrame() {
        const freq = state.frequency;
        const amp = state.amplitude;
        const ws = state.waveSpeed;
        const t = state.time;
        const s1 = state.sources[0];
        const s2 = state.sources[1];
        const showSuper = state.showSuper;
        const showS1Only = state.showS1;
        const showS2Only = state.showS2;

        const wavelength = ws / freq;

        // Background fill
        for (let i = 0; i < pixels.length; i += 4) {
            pixels[i] = 10;
            pixels[i + 1] = 14;
            pixels[i + 2] = 26;
            pixels[i + 3] = 255;
        }

        for (let py = 0; py < H; py += STEP) {
            for (let px = 0; px < W; px += STEP) {
                let r, g, b;

                if (showS1Only && !showS2Only && !showSuper) {
                    const d1 = displacement(s1.x, s1.y, px, py, t, freq, amp, ws);
                    const clamped = Math.max(-1, Math.min(1, d1));
                    [r, g, b] = waveColorS1(clamped);
                } else if (showS2Only && !showS1Only && !showSuper) {
                    const d2 = displacement(s2.x, s2.y, px, py, t, freq, amp, ws);
                    const clamped = Math.max(-1, Math.min(1, d2));
                    [r, g, b] = waveColorS2(clamped);
                } else {
                    // Superposition (default)
                    const d1 = displacement(s1.x, s1.y, px, py, t, freq, amp, ws);
                    const d2 = displacement(s2.x, s2.y, px, py, t, freq, amp, ws);
                    const combined = d1 + d2;
                    // Normalise: max possible is 2*amp
                    const norm = combined / (2 * amp);
                    const clamped = Math.max(-1, Math.min(1, norm));
                    [r, g, b] = waveColor(clamped);
                }

                // Fill a STEP x STEP block
                for (let dy = 0; dy < STEP && py + dy < H; dy++) {
                    for (let dx = 0; dx < STEP && px + dx < W; dx++) {
                        const idx = ((py + dy) * W + (px + dx)) * 4;
                        pixels[idx] = r;
                        pixels[idx + 1] = g;
                        pixels[idx + 2] = b;
                        pixels[idx + 3] = 255;
                    }
                }
            }
        }

        ctx.putImageData(imageData, 0, 0);

        // Grid overlay
        if (state.showGrid) {
            ctx.strokeStyle = 'rgba(42, 58, 82, 0.4)';
            ctx.lineWidth = 0.5;
            for (let x = 0; x < W; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, H);
                ctx.stroke();
            }
            for (let y = 0; y < H; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(W, y);
                ctx.stroke();
            }
        }

        // Nodal lines (destructive interference lines)
        if (state.showNodal) {
            drawNodalLines(freq, ws, s1, s2);
        }

        // Draw source points
        drawSource(s1.x, s1.y, '#06d6e0', '1');
        drawSource(s2.x, s2.y, '#8b5cf6', '2');

        // Update HTML source indicators
        updateSourceLabels();
    }

    function drawSource(x, y, color, label) {
        // Outer glow
        const grad = ctx.createRadialGradient(x, y, 0, x, y, 18);
        grad.addColorStop(0, color);
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x, y, 18, 0, Math.PI * 2);
        ctx.fill();

        // Core
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI * 2);
        ctx.fill();

        // Border
        ctx.strokeStyle = '#0a0e1a';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI * 2);
        ctx.stroke();

        // Label
        ctx.fillStyle = '#0a0e1a';
        ctx.font = 'bold 9px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, x, y);
    }

    function drawNodalLines(freq, ws, s1, s2) {
        const wavelength = ws / freq;
        const sep = Math.sqrt((s2.x - s1.x) ** 2 + (s2.y - s1.y) ** 2);
        const maxOrder = Math.ceil(sep / wavelength) + 1;

        ctx.lineWidth = 1.5;
        ctx.strokeStyle = 'rgba(239, 68, 68, 0.6)';

        for (let n = -maxOrder; n <= maxOrder; n++) {
            const pathDiff = (n + 0.5) * wavelength;
            if (Math.abs(pathDiff) >= sep) continue;

            ctx.beginPath();
            let started = false;

            for (let py = 0; py < H; py += 3) {
                for (let px = 0; px < W; px += 3) {
                    const d1 = Math.sqrt((px - s1.x) ** 2 + (py - s1.y) ** 2);
                    const d2 = Math.sqrt((px - s2.x) ** 2 + (py - s2.y) ** 2);
                    const diff = d1 - d2;
                    if (Math.abs(diff - pathDiff) < 2.5) {
                        if (!started) {
                            ctx.moveTo(px, py);
                            started = true;
                        } else {
                            ctx.lineTo(px, py);
                        }
                    }
                }
            }
            ctx.stroke();
        }

        // Better approach: sample along y and solve for x
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = 'rgba(239, 68, 68, 0.55)';

        for (let n = -maxOrder; n <= maxOrder; n++) {
            const pathDiff = (n + 0.5) * wavelength;
            if (Math.abs(pathDiff) >= sep) continue;
            drawHyperbolaBranch(s1, s2, pathDiff);
        }
    }

    function drawHyperbolaBranch(s1, s2, targetDiff) {
        // For each row, find x where |d1 - d2 - targetDiff| is minimised
        const points = [];
        for (let py = 0; py < H; py += 2) {
            let bestX = -1;
            let bestErr = Infinity;
            for (let px = 0; px < W; px += 2) {
                const d1 = Math.sqrt((px - s1.x) ** 2 + (py - s1.y) ** 2);
                const d2 = Math.sqrt((px - s2.x) ** 2 + (py - s2.y) ** 2);
                const err = Math.abs((d1 - d2) - targetDiff);
                if (err < bestErr) {
                    bestErr = err;
                    bestX = px;
                }
            }
            if (bestErr < 3) {
                points.push({ x: bestX, y: py });
            }
        }

        if (points.length < 2) return;

        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            const dx = Math.abs(points[i].x - points[i - 1].x);
            const dy = Math.abs(points[i].y - points[i - 1].y);
            if (dx < 40 && dy < 10) {
                ctx.lineTo(points[i].x, points[i].y);
            } else {
                ctx.moveTo(points[i].x, points[i].y);
            }
        }
        ctx.stroke();
    }

    /* ========== Source label positions (HTML overlays) ========== */
    function updateSourceLabels() {
        const rect = canvas.getBoundingClientRect();
        const scaleX = rect.width / W;
        const scaleY = rect.height / H;

        const s1El = document.getElementById('s1Label');
        const s2El = document.getElementById('s2Label');

        s1El.style.left = (state.sources[0].x * scaleX) + 'px';
        s1El.style.top = (state.sources[0].y * scaleY) + 'px';

        s2El.style.left = (state.sources[1].x * scaleX) + 'px';
        s2El.style.top = (state.sources[1].y * scaleY) + 'px';

        // Position readouts
        document.getElementById('s1Pos').textContent =
            `(${Math.round(state.sources[0].x)}, ${Math.round(state.sources[0].y)})`;
        document.getElementById('s2Pos').textContent =
            `(${Math.round(state.sources[1].x)}, ${Math.round(state.sources[1].y)})`;
    }

    /* ========== UI Updates ========== */
    function updateReadouts() {
        const wl = state.waveSpeed / state.frequency;
        const sep = Math.sqrt(
            (state.sources[1].x - state.sources[0].x) ** 2 +
            (state.sources[1].y - state.sources[0].y) ** 2
        );
        document.getElementById('readSep').textContent = Math.round(sep) + ' px';
        document.getElementById('readSpeed').textContent = state.waveSpeed + ' px/s';
        document.getElementById('readPeriod').textContent = (1 / state.frequency).toFixed(2) + ' s';
        document.getElementById('readTime').textContent = state.time.toFixed(1) + ' s';
        document.getElementById('wlVal').textContent = Math.round(wl) + ' px';
    }

    /* ========== Dragging ========== */
    function getCanvasCoords(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = W / rect.width;
        const scaleY = H / rect.height;
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    function onPointerDown(e) {
        e.preventDefault();
        const pos = getCanvasCoords(e);
        for (let i = 0; i < state.sources.length; i++) {
            const dx = pos.x - state.sources[i].x;
            const dy = pos.y - state.sources[i].y;
            if (Math.sqrt(dx * dx + dy * dy) < 25) {
                state.dragging = i;
                canvas.style.cursor = 'grabbing';
                return;
            }
        }
    }

    function onPointerMove(e) {
        const pos = getCanvasCoords(e);

        // Show pointer info
        const pointerInfo = document.getElementById('pointerInfo');
        const pointerPos = document.getElementById('pointerPos');
        pointerInfo.style.display = 'block';
        pointerPos.textContent = `(${Math.round(pos.x)}, ${Math.round(pos.y)})`;

        if (state.dragging >= 0) {
            state.sources[state.dragging].x = Math.max(5, Math.min(W - 5, pos.x));
            state.sources[state.dragging].y = Math.max(5, Math.min(H - 5, pos.y));
            updateReadouts();
        } else {
            // Hover cursor change
            let overSource = false;
            for (let i = 0; i < state.sources.length; i++) {
                const dx = pos.x - state.sources[i].x;
                const dy = pos.y - state.sources[i].y;
                if (Math.sqrt(dx * dx + dy * dy) < 25) {
                    overSource = true;
                    break;
                }
            }
            canvas.style.cursor = overSource ? 'grab' : 'crosshair';
        }
    }

    function onPointerUp() {
        state.dragging = -1;
        canvas.style.cursor = 'crosshair';
    }

    function onPointerLeave() {
        document.getElementById('pointerInfo').style.display = 'none';
    }

    canvas.addEventListener('mousedown', onPointerDown);
    canvas.addEventListener('mousemove', onPointerMove);
    canvas.addEventListener('mouseup', onPointerUp);
    canvas.addEventListener('mouseleave', onPointerLeave);
    canvas.addEventListener('touchstart', onPointerDown, { passive: false });
    canvas.addEventListener('touchmove', function(e) {
        e.preventDefault();
        onPointerMove(e);
    }, { passive: false });
    canvas.addEventListener('touchend', onPointerUp);

    /* ========== Controls ========== */
    const freqSlider = document.getElementById('freqSlider');
    const ampSlider = document.getElementById('ampSlider');
    const speedSlider = document.getElementById('speedSlider');
    const btnPlayPause = document.getElementById('btnPlayPause');
    const btnReset = document.getElementById('btnReset');
    const togSuper = document.getElementById('togSuper');
    const togS1 = document.getElementById('togS1');
    const togS2 = document.getElementById('togS2');
    const togNodal = document.getElementById('togNodal');
    const togGrid = document.getElementById('togGrid');

    freqSlider.addEventListener('input', function() {
        state.frequency = parseFloat(this.value);
        document.getElementById('freqVal').textContent = state.frequency.toFixed(1) + ' Hz';
        updateReadouts();
    });

    ampSlider.addEventListener('input', function() {
        state.amplitude = parseFloat(this.value);
        document.getElementById('ampVal').textContent = state.amplitude.toFixed(2);
    });

    speedSlider.addEventListener('input', function() {
        state.speed = parseFloat(this.value);
        document.getElementById('speedVal').textContent = state.speed.toFixed(1) + 'x';
    });

    btnPlayPause.addEventListener('click', function() {
        state.playing = !state.playing;
        this.textContent = state.playing ? 'Pause' : 'Play';
        this.classList.toggle('btn-primary', state.playing);
    });

    btnReset.addEventListener('click', function() {
        state.time = 0;
        state.sources[0] = { x: 220, y: 250 };
        state.sources[1] = { x: 480, y: 250 };
        state.frequency = 3.0;
        state.amplitude = 1.0;
        state.speed = 1.0;
        freqSlider.value = 3;
        ampSlider.value = 1;
        speedSlider.value = 1;
        document.getElementById('freqVal').textContent = '3.0 Hz';
        document.getElementById('ampVal').textContent = '1.00';
        document.getElementById('speedVal').textContent = '1.0x';
        updateReadouts();
    });

    // Display toggles with mutual exclusion logic
    function updateDisplayMode() {
        state.showSuper = togSuper.checked;
        state.showS1 = togS1.checked;
        state.showS2 = togS2.checked;
    }

    togSuper.addEventListener('change', function() {
        if (this.checked) {
            togS1.checked = false;
            togS2.checked = false;
        }
        updateDisplayMode();
    });

    togS1.addEventListener('change', function() {
        if (this.checked) {
            togSuper.checked = false;
            togS2.checked = false;
        }
        updateDisplayMode();
    });

    togS2.addEventListener('change', function() {
        if (this.checked) {
            togSuper.checked = false;
            togS1.checked = false;
        }
        updateDisplayMode();
    });

    togNodal.addEventListener('change', function() {
        state.showNodal = this.checked;
    });

    togGrid.addEventListener('change', function() {
        state.showGrid = this.checked;
    });

    /* ========== Animation Loop ========== */
    let lastTimestamp = 0;
    let frameCount = 0;
    let fpsTimer = 0;
    let currentFps = 0;

    function animate(timestamp) {
        requestAnimationFrame(animate);

        if (!lastTimestamp) {
            lastTimestamp = timestamp;
        }

        const rawDt = (timestamp - lastTimestamp) / 1000;
        lastTimestamp = timestamp;
        const dt = Math.min(rawDt, 0.05); // cap delta

        // FPS counter
        frameCount++;
        fpsTimer += rawDt;
        if (fpsTimer >= 0.5) {
            currentFps = Math.round(frameCount / fpsTimer);
            document.getElementById('fpsDisplay').textContent = currentFps + ' FPS';
            frameCount = 0;
            fpsTimer = 0;
        }

        if (state.playing) {
            state.time += dt * state.speed;
        }

        renderFrame();
        updateReadouts();
    }

    /* ========== Init ========== */
    updateReadouts();
    requestAnimationFrame(animate);

    // Hide HTML source labels initially, let first render position them
    document.getElementById('s1Label').style.display = 'none';
    document.getElementById('s2Label').style.display = 'none';

    // Position source labels after a tick
    requestAnimationFrame(function() {
        document.getElementById('s1Label').style.display = '';
        document.getElementById('s2Label').style.display = '';
        updateSourceLabels();
    });

})();
</script>
</body>
</html>
