<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quadratic Function Explorer - GCSE/A-Level Mathematics</title>
    <style>
        /* CSS Reset and Base Styles */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --primary-blue: #2563eb;
            --primary-blue-light: #3b82f6;
            --primary-green: #059669;
            --primary-green-light: #10b981;
            --parabola-color: #ea580c;
            --vertex-color: #dc2626;
            --root-color: #7c3aed;
            --y-intercept-color: #0891b2;
            --axis-color: #374151;
            --grid-color: #e5e7eb;
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f1f5f9;
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --text-muted: #64748b;
            --border-color: #cbd5e1;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            --radius-sm: 6px;
            --radius-md: 8px;
            --radius-lg: 12px;
        }

        html {
            font-size: 16px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        /* Header */
        header {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--primary-blue-light) 100%);
            color: white;
            padding: 1.5rem 2rem;
            text-align: center;
            box-shadow: var(--shadow-md);
        }

        header h1 {
            font-size: 1.75rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
        }

        header p {
            font-size: 1rem;
            opacity: 0.9;
        }

        /* Main Layout */
        main {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1.5rem;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }

        @media (max-width: 1024px) {
            main {
                grid-template-columns: 1fr;
            }
        }

        /* Card Styles */
        .card {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md);
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1.25rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid var(--bg-tertiary);
        }

        .card-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .card-title::before {
            content: '';
            width: 4px;
            height: 1.25rem;
            background: var(--primary-blue);
            border-radius: 2px;
        }

        /* Controls Section */
        .controls-section {
            grid-column: 1 / -1;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-weight: 600;
            color: var(--text-primary);
        }

        .coefficient-display {
            font-family: 'Courier New', monospace;
            background: var(--bg-tertiary);
            padding: 0.25rem 0.5rem;
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            color: var(--primary-blue);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        input[type="range"] {
            flex: 1;
            height: 8px;
            border-radius: 4px;
            background: var(--bg-tertiary);
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-blue);
            cursor: pointer;
            box-shadow: var(--shadow-sm);
            transition: transform 0.15s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-blue);
            cursor: pointer;
            border: none;
            box-shadow: var(--shadow-sm);
        }

        input[type="range"]:focus {
            outline: 2px solid var(--primary-blue-light);
            outline-offset: 2px;
        }

        input[type="number"] {
            width: 70px;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            text-align: center;
            font-family: 'Courier New', monospace;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.625rem 1.25rem;
            font-size: 0.9375rem;
            font-weight: 600;
            border: none;
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn:focus {
            outline: 2px solid var(--primary-blue-light);
            outline-offset: 2px;
        }

        .btn-primary {
            background: var(--primary-blue);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-blue-light);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--border-color);
        }

        .btn-success {
            background: var(--primary-green);
            color: white;
        }

        .btn-success:hover {
            background: var(--primary-green-light);
        }

        .btn-group {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        /* Graph Section */
        .graph-section {
            display: flex;
            flex-direction: column;
        }

        .canvas-container {
            position: relative;
            background: white;
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
            overflow: hidden;
        }

        #graphCanvas {
            display: block;
            width: 100%;
            height: auto;
            max-height: 500px;
        }

        .graph-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 1rem;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.375rem;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .legend-line {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        /* Info Section */
        .info-grid {
            display: grid;
            gap: 1rem;
        }

        .info-item {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: var(--radius-sm);
            border-left: 3px solid var(--primary-blue);
        }

        .info-label {
            font-size: 0.8125rem;
            color: var(--text-muted);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }

        .info-value {
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            color: var(--text-primary);
            font-weight: 600;
        }

        .info-value.highlight-vertex {
            color: var(--vertex-color);
        }

        .info-value.highlight-roots {
            color: var(--root-color);
        }

        .info-value.highlight-yint {
            color: var(--y-intercept-color);
        }

        .discriminant-positive {
            border-left-color: var(--primary-green);
        }

        .discriminant-zero {
            border-left-color: var(--parabola-color);
        }

        .discriminant-negative {
            border-left-color: var(--vertex-color);
        }

        /* Challenge Mode */
        .challenge-section {
            grid-column: 1 / -1;
        }

        .challenge-toggle {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .toggle-switch {
            position: relative;
            width: 52px;
            height: 28px;
            background: var(--border-color);
            border-radius: 14px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .toggle-switch.active {
            background: var(--primary-green);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 50%;
            box-shadow: var(--shadow-sm);
            transition: transform 0.3s ease;
        }

        .toggle-switch.active::after {
            transform: translateX(24px);
        }

        .toggle-switch:focus {
            outline: 2px solid var(--primary-blue-light);
            outline-offset: 2px;
        }

        .challenge-content {
            display: none;
            margin-top: 1.25rem;
            padding-top: 1.25rem;
            border-top: 1px solid var(--border-color);
        }

        .challenge-content.visible {
            display: block;
        }

        .challenge-status {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
        }

        .challenge-status-icon {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            background: var(--primary-blue);
            color: white;
        }

        .challenge-status-text h3 {
            font-size: 1rem;
            margin-bottom: 0.25rem;
        }

        .challenge-status-text p {
            font-size: 0.875rem;
            color: var(--text-muted);
        }

        .accuracy-display {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-green);
            margin-top: 1rem;
            text-align: center;
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            display: none;
        }

        .accuracy-display.visible {
            display: block;
        }

        .accuracy-excellent {
            color: var(--primary-green);
        }

        .accuracy-good {
            color: var(--parabola-color);
        }

        .accuracy-poor {
            color: var(--vertex-color);
        }

        /* Special Forms Display */
        .equation-display {
            font-family: 'Courier New', monospace;
            font-size: 1.125rem;
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            text-align: center;
            margin-bottom: 1rem;
            border: 2px solid var(--primary-blue);
        }

        /* Accessibility */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Focus visible for keyboard users */
        :focus-visible {
            outline: 2px solid var(--primary-blue);
            outline-offset: 2px;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            header {
                padding: 1rem;
            }

            header h1 {
                font-size: 1.5rem;
            }

            main {
                padding: 1rem;
                gap: 1rem;
            }

            .card {
                padding: 1rem;
            }

            .controls-grid {
                grid-template-columns: 1fr;
            }

            .graph-legend {
                justify-content: center;
            }
        }

        /* Print styles */
        @media print {
            header {
                background: var(--primary-blue);
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .btn {
                display: none;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Quadratic Function Explorer</h1>
        <p>Interactive tool for GCSE &amp; A-Level Mathematics</p>
    </header>

    <main>
        <!-- Controls Section -->
        <section class="card controls-section" aria-labelledby="controls-title">
            <div class="card-header">
                <h2 class="card-title" id="controls-title">Coefficient Controls</h2>
                <div class="btn-group">
                    <button type="button" class="btn btn-secondary" id="resetBtn" aria-label="Reset all coefficients to default values">
                        Reset
                    </button>
                </div>
            </div>

            <div class="controls-grid">
                <!-- Coefficient a -->
                <div class="control-group">
                    <label class="control-label" for="sliderA">
                        <span>Coefficient <strong>a</strong> (shape)</span>
                        <span class="coefficient-display" id="displayA">a = 1</span>
                    </label>
                    <div class="slider-container">
                        <input type="range" id="sliderA" min="-5" max="5" step="0.1" value="1"
                               aria-describedby="descA" aria-valuemin="-5" aria-valuemax="5" aria-valuenow="1">
                        <input type="number" id="inputA" min="-5" max="5" step="0.1" value="1"
                               aria-label="Coefficient a precise value">
                    </div>
                    <span id="descA" class="visually-hidden">Controls the width and direction of the parabola. Positive opens upward, negative opens downward.</span>
                </div>

                <!-- Coefficient b -->
                <div class="control-group">
                    <label class="control-label" for="sliderB">
                        <span>Coefficient <strong>b</strong> (position)</span>
                        <span class="coefficient-display" id="displayB">b = 0</span>
                    </label>
                    <div class="slider-container">
                        <input type="range" id="sliderB" min="-10" max="10" step="0.5" value="0"
                               aria-describedby="descB" aria-valuemin="-10" aria-valuemax="10" aria-valuenow="0">
                        <input type="number" id="inputB" min="-10" max="10" step="0.5" value="0"
                               aria-label="Coefficient b precise value">
                    </div>
                    <span id="descB" class="visually-hidden">Affects the horizontal position of the vertex and the tilt of the parabola.</span>
                </div>

                <!-- Coefficient c -->
                <div class="control-group">
                    <label class="control-label" for="sliderC">
                        <span>Coefficient <strong>c</strong> (y-intercept)</span>
                        <span class="coefficient-display" id="displayC">c = 0</span>
                    </label>
                    <div class="slider-container">
                        <input type="range" id="sliderC" min="-10" max="10" step="0.5" value="0"
                               aria-describedby="descC" aria-valuemin="-10" aria-valuemax="10" aria-valuenow="0">
                        <input type="number" id="inputC" min="-10" max="10" step="0.5" value="0"
                               aria-label="Coefficient c precise value">
                    </div>
                    <span id="descC" class="visually-hidden">The y-intercept: where the parabola crosses the y-axis.</span>
                </div>
            </div>
        </section>

        <!-- Graph Section -->
        <section class="card graph-section" aria-labelledby="graph-title">
            <div class="card-header">
                <h2 class="card-title" id="graph-title">Graph</h2>
            </div>

            <div class="canvas-container">
                <canvas id="graphCanvas" width="600" height="500" role="img" aria-label="Interactive graph showing the quadratic function"></canvas>
            </div>

            <div class="graph-legend" aria-label="Graph legend">
                <div class="legend-item">
                    <span class="legend-line" style="background: var(--parabola-color);"></span>
                    <span>Parabola</span>
                </div>
                <div class="legend-item">
                    <span class="legend-dot" style="background: var(--vertex-color);"></span>
                    <span>Vertex</span>
                </div>
                <div class="legend-item">
                    <span class="legend-dot" style="background: var(--root-color);"></span>
                    <span>Roots</span>
                </div>
                <div class="legend-item">
                    <span class="legend-dot" style="background: var(--y-intercept-color);"></span>
                    <span>Y-intercept</span>
                </div>
            </div>
        </section>

        <!-- Mathematical Information Panel -->
        <section class="card" aria-labelledby="info-title">
            <div class="card-header">
                <h2 class="card-title" id="info-title">Mathematical Properties</h2>
            </div>

            <!-- Current Equation Display -->
            <div class="equation-display" id="equationDisplay" aria-live="polite">
                y = x²
            </div>

            <div class="info-grid">
                <!-- Standard Form -->
                <div class="info-item">
                    <span class="info-label">Standard Form</span>
                    <span class="info-value" id="standardForm">y = x²</span>
                </div>

                <!-- Vertex Form -->
                <div class="info-item">
                    <span class="info-label">Vertex Form</span>
                    <span class="info-value" id="vertexForm">y = (x - 0)² + 0</span>
                </div>

                <!-- Factored Form -->
                <div class="info-item">
                    <span class="info-label">Factored Form</span>
                    <span class="info-value" id="factoredForm">y = x(x - 0)</span>
                </div>

                <!-- Vertex -->
                <div class="info-item">
                    <span class="info-label">Vertex (h, k)</span>
                    <span class="info-value highlight-vertex" id="vertexCoords">(0, 0)</span>
                </div>

                <!-- Axis of Symmetry -->
                <div class="info-item">
                    <span class="info-label">Axis of Symmetry</span>
                    <span class="info-value" id="axisSymmetry">x = 0</span>
                </div>

                <!-- Y-intercept -->
                <div class="info-item">
                    <span class="info-label">Y-intercept</span>
                    <span class="info-value highlight-yint" id="yIntercept">(0, 0)</span>
                </div>

                <!-- Roots -->
                <div class="info-item">
                    <span class="info-label">Roots (x-intercepts)</span>
                    <span class="info-value highlight-roots" id="roots">x = 0 (repeated)</span>
                </div>

                <!-- Discriminant -->
                <div class="info-item" id="discriminantItem">
                    <span class="info-label">Discriminant (b² - 4ac)</span>
                    <span class="info-value" id="discriminant">0 — One repeated root</span>
                </div>
            </div>
        </section>

        <!-- Challenge Mode Section -->
        <section class="card challenge-section" aria-labelledby="challenge-title">
            <div class="card-header">
                <h2 class="card-title" id="challenge-title">Student Challenge Mode</h2>
                <div class="challenge-toggle">
                    <span id="toggleLabel">Off</span>
                    <button type="button" class="toggle-switch" id="challengeToggle"
                            role="switch" aria-checked="false" aria-labelledby="toggleLabel"
                            tabindex="0">
                    </button>
                </div>
            </div>

            <div class="challenge-content" id="challengeContent">
                <div class="challenge-status">
                    <div class="challenge-status-icon" aria-hidden="true">?</div>
                    <div class="challenge-status-text">
                        <h3>Match the Curve!</h3>
                        <p>Adjust the sliders to match the hidden quadratic function shown on the graph.</p>
                    </div>
                </div>

                <div class="btn-group" style="justify-content: center;">
                    <button type="button" class="btn btn-primary" id="newChallengeBtn">
                        New Challenge
                    </button>
                    <button type="button" class="btn btn-success" id="checkAnswerBtn">
                        Check Answer
                    </button>
                    <button type="button" class="btn btn-secondary" id="revealBtn">
                        Reveal Solution
                    </button>
                </div>

                <div class="accuracy-display" id="accuracyDisplay" aria-live="polite">
                    Accuracy: 100%
                </div>
            </div>
        </section>
    </main>

    <script>
        /**
         * Quadratic Function Explorer
         * Educational tool for GCSE/A-Level Mathematics
         *
         * This application allows students to explore quadratic functions
         * by manipulating coefficients and observing the effects on the graph.
         */

        // ============================================================
        // Configuration and Constants
        // ============================================================

        const CONFIG = {
            // Coefficient ranges
            coefficients: {
                a: { min: -5, max: 5, step: 0.1, default: 1 },
                b: { min: -10, max: 10, step: 0.5, default: 0 },
                c: { min: -10, max: 10, step: 0.5, default: 0 }
            },
            // Graph settings
            graph: {
                xMin: -10,
                xMax: 10,
                padding: 50,
                gridColor: '#e5e7eb',
                axisColor: '#374151',
                parabolaColor: '#ea580c',
                vertexColor: '#dc2626',
                rootColor: '#7c3aed',
                yInterceptColor: '#0891b2',
                challengeColor: '#3b82f6',
                lineWidth: 3,
                pointRadius: 6
            },
            // Decimal places for display
            precision: 2
        };

        // ============================================================
        // State Management
        // ============================================================

        const state = {
            // Current coefficients
            a: CONFIG.coefficients.a.default,
            b: CONFIG.coefficients.b.default,
            c: CONFIG.coefficients.c.default,

            // Challenge mode state
            challengeMode: false,
            challengeA: 1,
            challengeB: 0,
            challengeC: 0,
            showSolution: false
        };

        // ============================================================
        // DOM Element References
        // ============================================================

        const elements = {
            // Sliders
            sliderA: document.getElementById('sliderA'),
            sliderB: document.getElementById('sliderB'),
            sliderC: document.getElementById('sliderC'),

            // Number inputs
            inputA: document.getElementById('inputA'),
            inputB: document.getElementById('inputB'),
            inputC: document.getElementById('inputC'),

            // Coefficient displays
            displayA: document.getElementById('displayA'),
            displayB: document.getElementById('displayB'),
            displayC: document.getElementById('displayC'),

            // Buttons
            resetBtn: document.getElementById('resetBtn'),
            challengeToggle: document.getElementById('challengeToggle'),
            newChallengeBtn: document.getElementById('newChallengeBtn'),
            checkAnswerBtn: document.getElementById('checkAnswerBtn'),
            revealBtn: document.getElementById('revealBtn'),

            // Information displays
            equationDisplay: document.getElementById('equationDisplay'),
            standardForm: document.getElementById('standardForm'),
            vertexForm: document.getElementById('vertexForm'),
            factoredForm: document.getElementById('factoredForm'),
            vertexCoords: document.getElementById('vertexCoords'),
            axisSymmetry: document.getElementById('axisSymmetry'),
            yIntercept: document.getElementById('yIntercept'),
            roots: document.getElementById('roots'),
            discriminant: document.getElementById('discriminant'),
            discriminantItem: document.getElementById('discriminantItem'),

            // Challenge elements
            challengeContent: document.getElementById('challengeContent'),
            toggleLabel: document.getElementById('toggleLabel'),
            accuracyDisplay: document.getElementById('accuracyDisplay'),

            // Canvas
            canvas: document.getElementById('graphCanvas'),
            ctx: document.getElementById('graphCanvas').getContext('2d')
        };

        // ============================================================
        // Mathematical Calculations
        // ============================================================

        /**
         * Calculate y value for a given x using quadratic formula
         * @param {number} x - Input value
         * @param {number} a - Coefficient a
         * @param {number} b - Coefficient b
         * @param {number} c - Coefficient c
         * @returns {number} - y value
         */
        function calculateY(x, a, b, c) {
            return a * x * x + b * x + c;
        }

        /**
         * Calculate vertex coordinates (h, k)
         * h = -b / (2a), k = f(h)
         * @param {number} a - Coefficient a
         * @param {number} b - Coefficient b
         * @param {number} c - Coefficient c
         * @returns {object} - { h, k }
         */
        function calculateVertex(a, b, c) {
            if (a === 0) {
                // Not a quadratic - return null
                return null;
            }
            const h = -b / (2 * a);
            const k = calculateY(h, a, b, c);
            return { h, k };
        }

        /**
         * Calculate discriminant and roots
         * Discriminant = b² - 4ac
         * @param {number} a - Coefficient a
         * @param {number} b - Coefficient b
         * @param {number} c - Coefficient c
         * @returns {object} - { discriminant, roots }
         */
        function calculateRoots(a, b, c) {
            if (a === 0) {
                // Linear equation: bx + c = 0
                if (b === 0) {
                    return { discriminant: null, roots: c === 0 ? 'All real numbers' : 'No solution' };
                }
                const root = -c / b;
                return { discriminant: null, roots: [root] };
            }

            const discriminant = b * b - 4 * a * c;

            if (discriminant > 0) {
                const sqrtDisc = Math.sqrt(discriminant);
                const root1 = (-b + sqrtDisc) / (2 * a);
                const root2 = (-b - sqrtDisc) / (2 * a);
                return { discriminant, roots: [Math.min(root1, root2), Math.max(root1, root2)] };
            } else if (discriminant === 0) {
                const root = -b / (2 * a);
                return { discriminant, roots: [root] };
            } else {
                return { discriminant, roots: null };
            }
        }

        /**
         * Format a number for display
         * @param {number} num - Number to format
         * @param {number} precision - Decimal places
         * @returns {string} - Formatted string
         */
        function formatNumber(num, precision = CONFIG.precision) {
            if (num === null || num === undefined) return 'undefined';

            // Round to precision
            const rounded = Math.round(num * Math.pow(10, precision)) / Math.pow(10, precision);

            // Check if it's effectively an integer
            if (Math.abs(rounded - Math.round(rounded)) < 0.0001) {
                return Math.round(rounded).toString();
            }

            return rounded.toFixed(precision);
        }

        /**
         * Format coefficient with sign for equation display
         * @param {number} coef - Coefficient value
         * @param {string} variable - Variable string (e.g., 'x²')
         * @param {boolean} isFirst - Is this the first term?
         * @returns {string} - Formatted term
         */
        function formatTerm(coef, variable, isFirst = false) {
            if (coef === 0) return '';

            const absCoef = Math.abs(coef);
            const sign = coef < 0 ? '-' : (isFirst ? '' : '+');
            const space = isFirst ? '' : ' ';

            let coefStr = '';
            if (variable === '' || (absCoef !== 1)) {
                coefStr = formatNumber(absCoef);
            }

            return `${space}${sign}${space}${coefStr}${variable}`;
        }

        // ============================================================
        // Display Update Functions
        // ============================================================

        /**
         * Build the standard form equation string
         */
        function buildStandardForm(a, b, c) {
            if (a === 0 && b === 0 && c === 0) {
                return 'y = 0';
            }

            let equation = 'y = ';
            let terms = [];

            // a term
            if (a !== 0) {
                if (a === 1) {
                    terms.push('x²');
                } else if (a === -1) {
                    terms.push('-x²');
                } else {
                    terms.push(`${formatNumber(a)}x²`);
                }
            }

            // b term
            if (b !== 0) {
                const sign = b > 0 && terms.length > 0 ? ' + ' : (b < 0 && terms.length > 0 ? ' - ' : (b < 0 ? '-' : ''));
                const absB = Math.abs(b);
                if (absB === 1) {
                    terms.push(`${sign}x`);
                } else {
                    terms.push(`${sign}${formatNumber(absB)}x`);
                }
            }

            // c term
            if (c !== 0) {
                const sign = c > 0 && terms.length > 0 ? ' + ' : (c < 0 && terms.length > 0 ? ' - ' : (c < 0 ? '-' : ''));
                terms.push(`${sign}${formatNumber(Math.abs(c))}`);
            }

            if (terms.length === 0) {
                return 'y = 0';
            }

            return equation + terms.join('');
        }

        /**
         * Build the vertex form equation string
         * y = a(x - h)² + k
         */
        function buildVertexForm(a, h, k) {
            if (a === 0) return 'Not a quadratic (a = 0)';

            let equation = 'y = ';

            // Coefficient a
            if (a !== 1) {
                if (a === -1) {
                    equation += '-(';
                } else {
                    equation += `${formatNumber(a)}(`;
                }
            }

            // (x - h) part
            if (h === 0) {
                equation += 'x';
            } else if (h > 0) {
                equation += `x - ${formatNumber(h)}`;
            } else {
                equation += `x + ${formatNumber(-h)}`;
            }

            equation += ')²';

            if (a !== 1 && a !== -1) {
                // Coefficient already includes parenthesis
            }

            // + k part
            if (k !== 0) {
                if (k > 0) {
                    equation += ` + ${formatNumber(k)}`;
                } else {
                    equation += ` - ${formatNumber(-k)}`;
                }
            }

            return equation;
        }

        /**
         * Build the factored form equation string
         * y = a(x - r₁)(x - r₂)
         */
        function buildFactoredForm(a, roots) {
            if (a === 0) return 'Not a quadratic (a = 0)';
            if (!roots || !Array.isArray(roots)) return 'Complex roots (no real factored form)';

            let equation = 'y = ';

            // Coefficient a
            if (a !== 1) {
                if (a === -1) {
                    equation += '-';
                } else {
                    equation += `${formatNumber(a)}`;
                }
            }

            if (roots.length === 1) {
                // Repeated root
                const r = roots[0];
                if (r === 0) {
                    equation += 'x²';
                } else if (r > 0) {
                    equation += `(x - ${formatNumber(r)})²`;
                } else {
                    equation += `(x + ${formatNumber(-r)})²`;
                }
            } else if (roots.length === 2) {
                // Two distinct roots
                const [r1, r2] = roots;

                // First factor
                if (r1 === 0) {
                    equation += 'x';
                } else if (r1 > 0) {
                    equation += `(x - ${formatNumber(r1)})`;
                } else {
                    equation += `(x + ${formatNumber(-r1)})`;
                }

                // Second factor
                if (r2 === 0) {
                    equation += 'x';
                } else if (r2 > 0) {
                    equation += `(x - ${formatNumber(r2)})`;
                } else {
                    equation += `(x + ${formatNumber(-r2)})`;
                }
            }

            return equation;
        }

        /**
         * Update all mathematical information displays
         */
        function updateInfoPanel() {
            const { a, b, c } = state;

            // Standard form
            const standardFormStr = buildStandardForm(a, b, c);
            elements.standardForm.textContent = standardFormStr;
            elements.equationDisplay.textContent = standardFormStr;

            // Vertex calculations
            const vertex = calculateVertex(a, b, c);

            if (vertex) {
                // Vertex form
                elements.vertexForm.textContent = buildVertexForm(a, vertex.h, vertex.k);

                // Vertex coordinates
                elements.vertexCoords.textContent = `(${formatNumber(vertex.h)}, ${formatNumber(vertex.k)})`;

                // Axis of symmetry
                elements.axisSymmetry.textContent = `x = ${formatNumber(vertex.h)}`;
            } else {
                elements.vertexForm.textContent = 'Not a quadratic (a = 0)';
                elements.vertexCoords.textContent = 'N/A (not a quadratic)';
                elements.axisSymmetry.textContent = 'N/A (not a quadratic)';
            }

            // Y-intercept (always c)
            elements.yIntercept.textContent = `(0, ${formatNumber(c)})`;

            // Roots and discriminant
            const { discriminant, roots } = calculateRoots(a, b, c);

            // Factored form
            elements.factoredForm.textContent = buildFactoredForm(a, roots);

            // Roots display
            if (a === 0) {
                if (typeof roots === 'string') {
                    elements.roots.textContent = roots;
                } else if (Array.isArray(roots)) {
                    elements.roots.textContent = `x = ${formatNumber(roots[0])}`;
                }
            } else if (!roots) {
                elements.roots.textContent = 'No real roots';
            } else if (roots.length === 1) {
                elements.roots.textContent = `x = ${formatNumber(roots[0])} (repeated)`;
            } else {
                elements.roots.textContent = `x = ${formatNumber(roots[0])}, x = ${formatNumber(roots[1])}`;
            }

            // Discriminant display
            elements.discriminantItem.className = 'info-item';
            if (discriminant === null) {
                elements.discriminant.textContent = 'N/A (not a quadratic)';
            } else if (discriminant > 0) {
                elements.discriminant.textContent = `${formatNumber(discriminant)} — Two distinct real roots`;
                elements.discriminantItem.classList.add('discriminant-positive');
            } else if (discriminant === 0) {
                elements.discriminant.textContent = `0 — One repeated root`;
                elements.discriminantItem.classList.add('discriminant-zero');
            } else {
                elements.discriminant.textContent = `${formatNumber(discriminant)} — Complex roots (no real solutions)`;
                elements.discriminantItem.classList.add('discriminant-negative');
            }
        }

        /**
         * Update coefficient displays
         */
        function updateCoefficientDisplays() {
            elements.displayA.textContent = `a = ${formatNumber(state.a)}`;
            elements.displayB.textContent = `b = ${formatNumber(state.b)}`;
            elements.displayC.textContent = `c = ${formatNumber(state.c)}`;
        }

        // ============================================================
        // Canvas Drawing Functions
        // ============================================================

        /**
         * Convert mathematical coordinates to canvas coordinates
         */
        function mathToCanvas(x, y, scaleX, scaleY, offsetX, offsetY) {
            return {
                x: offsetX + x * scaleX,
                y: offsetY - y * scaleY
            };
        }

        /**
         * Calculate appropriate Y-axis range based on function values
         */
        function calculateYRange(a, b, c) {
            const { xMin, xMax } = CONFIG.graph;

            // Sample many points to find Y range
            let yMin = Infinity;
            let yMax = -Infinity;

            for (let x = xMin; x <= xMax; x += 0.1) {
                const y = calculateY(x, a, b, c);
                if (isFinite(y)) {
                    yMin = Math.min(yMin, y);
                    yMax = Math.max(yMax, y);
                }
            }

            // Include vertex
            const vertex = calculateVertex(a, b, c);
            if (vertex) {
                yMin = Math.min(yMin, vertex.k);
                yMax = Math.max(yMax, vertex.k);
            }

            // Include y-intercept
            yMin = Math.min(yMin, c);
            yMax = Math.max(yMax, c);

            // Add padding
            const yRange = yMax - yMin;
            const padding = Math.max(yRange * 0.1, 2);

            yMin -= padding;
            yMax += padding;

            // Ensure reasonable range
            yMin = Math.max(yMin, -50);
            yMax = Math.min(yMax, 50);

            // Ensure at least -10 to 10 range if values are small
            if (yMin > -5) yMin = -10;
            if (yMax < 5) yMax = 10;

            return { yMin, yMax };
        }

        /**
         * Draw grid lines and axis
         */
        function drawGrid(ctx, width, height, scaleX, scaleY, offsetX, offsetY, yMin, yMax) {
            const { xMin, xMax, gridColor, axisColor } = CONFIG.graph;

            ctx.save();

            // Grid lines
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1;

            // Vertical grid lines (x values)
            for (let x = Math.ceil(xMin); x <= Math.floor(xMax); x++) {
                const canvasX = offsetX + x * scaleX;
                ctx.beginPath();
                ctx.moveTo(canvasX, 0);
                ctx.lineTo(canvasX, height);
                ctx.stroke();
            }

            // Horizontal grid lines (y values)
            const yStep = Math.ceil((yMax - yMin) / 10);
            for (let y = Math.ceil(yMin / yStep) * yStep; y <= yMax; y += yStep) {
                const canvasY = offsetY - y * scaleY;
                if (canvasY >= 0 && canvasY <= height) {
                    ctx.beginPath();
                    ctx.moveTo(0, canvasY);
                    ctx.lineTo(width, canvasY);
                    ctx.stroke();
                }
            }

            // Axes
            ctx.strokeStyle = axisColor;
            ctx.lineWidth = 2;

            // X-axis
            const xAxisY = offsetY;
            if (xAxisY >= 0 && xAxisY <= height) {
                ctx.beginPath();
                ctx.moveTo(0, xAxisY);
                ctx.lineTo(width, xAxisY);
                ctx.stroke();
            }

            // Y-axis
            const yAxisX = offsetX;
            ctx.beginPath();
            ctx.moveTo(yAxisX, 0);
            ctx.lineTo(yAxisX, height);
            ctx.stroke();

            // Axis labels
            ctx.fillStyle = axisColor;
            ctx.font = '12px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            // X-axis labels
            for (let x = Math.ceil(xMin); x <= Math.floor(xMax); x += 2) {
                if (x !== 0) {
                    const canvasX = offsetX + x * scaleX;
                    const labelY = Math.min(Math.max(offsetY + 5, 5), height - 20);
                    ctx.fillText(x.toString(), canvasX, labelY);
                }
            }

            // Y-axis labels
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for (let y = Math.ceil(yMin / yStep) * yStep; y <= yMax; y += yStep) {
                if (y !== 0) {
                    const canvasY = offsetY - y * scaleY;
                    if (canvasY >= 15 && canvasY <= height - 15) {
                        ctx.fillText(y.toString(), offsetX - 8, canvasY);
                    }
                }
            }

            // Origin label
            ctx.textAlign = 'right';
            ctx.textBaseline = 'top';
            const originLabelY = Math.min(offsetY + 5, height - 15);
            ctx.fillText('0', offsetX - 5, originLabelY);

            ctx.restore();
        }

        /**
         * Draw a parabola
         */
        function drawParabola(ctx, a, b, c, scaleX, scaleY, offsetX, offsetY, color, lineWidth, yMin, yMax) {
            const { xMin, xMax } = CONFIG.graph;

            ctx.save();
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.beginPath();
            let firstPoint = true;

            // Draw curve with small step for smoothness
            const step = (xMax - xMin) / 400;

            for (let x = xMin; x <= xMax; x += step) {
                const y = calculateY(x, a, b, c);

                // Only draw if within reasonable Y bounds
                if (y >= yMin - 10 && y <= yMax + 10) {
                    const canvasPos = mathToCanvas(x, y, scaleX, scaleY, offsetX, offsetY);

                    if (firstPoint) {
                        ctx.moveTo(canvasPos.x, canvasPos.y);
                        firstPoint = false;
                    } else {
                        ctx.lineTo(canvasPos.x, canvasPos.y);
                    }
                } else {
                    firstPoint = true; // Start new path segment
                }
            }

            ctx.stroke();
            ctx.restore();
        }

        /**
         * Draw a point marker
         */
        function drawPoint(ctx, x, y, scaleX, scaleY, offsetX, offsetY, color, radius, label = '') {
            const canvasPos = mathToCanvas(x, y, scaleX, scaleY, offsetX, offsetY);
            const canvasHeight = ctx.canvas.height;

            // Only draw if on canvas
            if (canvasPos.x < 0 || canvasPos.x > ctx.canvas.width ||
                canvasPos.y < 0 || canvasPos.y > canvasHeight) {
                return;
            }

            ctx.save();

            // Outer circle
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(canvasPos.x, canvasPos.y, radius, 0, Math.PI * 2);
            ctx.fill();

            // Inner white circle
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(canvasPos.x, canvasPos.y, radius - 2, 0, Math.PI * 2);
            ctx.fill();

            // Center dot
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(canvasPos.x, canvasPos.y, 2, 0, Math.PI * 2);
            ctx.fill();

            // Label
            if (label) {
                ctx.fillStyle = color;
                ctx.font = 'bold 12px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'bottom';
                ctx.fillText(label, canvasPos.x + radius + 4, canvasPos.y - 4);
            }

            ctx.restore();
        }

        /**
         * Main graph drawing function
         */
        function drawGraph() {
            const { canvas, ctx } = elements;
            const { padding, xMin, xMax, parabolaColor, vertexColor, rootColor, yInterceptColor, challengeColor, lineWidth, pointRadius } = CONFIG.graph;

            // Handle high DPI displays
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();

            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            const width = rect.width;
            const height = rect.height;

            // Clear canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, width, height);

            // Determine which coefficients to use for Y range calculation
            let rangeA = state.a;
            let rangeB = state.b;
            let rangeC = state.c;

            if (state.challengeMode) {
                // Consider both user's curve and challenge curve for range
                const userRange = calculateYRange(state.a, state.b, state.c);
                const challengeRange = calculateYRange(state.challengeA, state.challengeB, state.challengeC);
                rangeA = state.challengeA;
                rangeB = state.challengeB;
                rangeC = state.challengeC;
            }

            // Calculate Y range
            let { yMin, yMax } = calculateYRange(rangeA, rangeB, rangeC);

            // If in challenge mode, also consider user's curve
            if (state.challengeMode) {
                const userRange = calculateYRange(state.a, state.b, state.c);
                yMin = Math.min(yMin, userRange.yMin);
                yMax = Math.max(yMax, userRange.yMax);
            }

            // Calculate scales
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;
            const scaleX = graphWidth / (xMax - xMin);
            const scaleY = graphHeight / (yMax - yMin);
            const offsetX = padding - xMin * scaleX;
            const offsetY = height - padding + yMin * scaleY;

            // Draw grid
            drawGrid(ctx, width, height, scaleX, scaleY, offsetX, offsetY, yMin, yMax);

            // Draw challenge parabola if in challenge mode
            if (state.challengeMode) {
                drawParabola(ctx, state.challengeA, state.challengeB, state.challengeC,
                            scaleX, scaleY, offsetX, offsetY, challengeColor, lineWidth + 1, yMin, yMax);

                // Draw user's parabola
                drawParabola(ctx, state.a, state.b, state.c,
                            scaleX, scaleY, offsetX, offsetY, parabolaColor, lineWidth, yMin, yMax);

                // Only show key points if solution is revealed
                if (state.showSolution) {
                    drawKeyPoints(ctx, state.challengeA, state.challengeB, state.challengeC,
                                 scaleX, scaleY, offsetX, offsetY, yMin, yMax);
                }
            } else {
                // Normal mode - draw parabola and key points
                drawParabola(ctx, state.a, state.b, state.c,
                            scaleX, scaleY, offsetX, offsetY, parabolaColor, lineWidth, yMin, yMax);

                drawKeyPoints(ctx, state.a, state.b, state.c,
                             scaleX, scaleY, offsetX, offsetY, yMin, yMax);
            }
        }

        /**
         * Draw key points (vertex, roots, y-intercept)
         */
        function drawKeyPoints(ctx, a, b, c, scaleX, scaleY, offsetX, offsetY, yMin, yMax) {
            const { vertexColor, rootColor, yInterceptColor, pointRadius } = CONFIG.graph;

            // Vertex
            const vertex = calculateVertex(a, b, c);
            if (vertex && vertex.k >= yMin && vertex.k <= yMax) {
                drawPoint(ctx, vertex.h, vertex.k, scaleX, scaleY, offsetX, offsetY,
                         vertexColor, pointRadius, `Vertex (${formatNumber(vertex.h)}, ${formatNumber(vertex.k)})`);
            }

            // Roots
            const { roots } = calculateRoots(a, b, c);
            if (Array.isArray(roots)) {
                roots.forEach((root, i) => {
                    if (root >= CONFIG.graph.xMin && root <= CONFIG.graph.xMax) {
                        const label = roots.length === 1 ?
                            `Root (${formatNumber(root)}, 0)` :
                            `Root ${i + 1} (${formatNumber(root)}, 0)`;
                        drawPoint(ctx, root, 0, scaleX, scaleY, offsetX, offsetY,
                                 rootColor, pointRadius, label);
                    }
                });
            }

            // Y-intercept
            if (c >= yMin && c <= yMax) {
                drawPoint(ctx, 0, c, scaleX, scaleY, offsetX, offsetY,
                         yInterceptColor, pointRadius, `Y-int (0, ${formatNumber(c)})`);
            }
        }

        // ============================================================
        // Event Handlers
        // ============================================================

        /**
         * Handle coefficient change from slider
         */
        function handleSliderChange(coefficient, value) {
            const numValue = parseFloat(value);
            if (!isNaN(numValue)) {
                state[coefficient] = numValue;

                // Sync with number input
                elements[`input${coefficient.toUpperCase()}`].value = numValue;

                // Update displays
                updateCoefficientDisplays();
                updateInfoPanel();
                drawGraph();
            }
        }

        /**
         * Handle coefficient change from number input
         */
        function handleInputChange(coefficient, value) {
            let numValue = parseFloat(value);
            const config = CONFIG.coefficients[coefficient];

            if (!isNaN(numValue)) {
                // Clamp to valid range
                numValue = Math.max(config.min, Math.min(config.max, numValue));
                state[coefficient] = numValue;

                // Sync with slider
                elements[`slider${coefficient.toUpperCase()}`].value = numValue;

                // Update displays
                updateCoefficientDisplays();
                updateInfoPanel();
                drawGraph();
            }
        }

        /**
         * Reset all coefficients to defaults
         */
        function resetCoefficients() {
            state.a = CONFIG.coefficients.a.default;
            state.b = CONFIG.coefficients.b.default;
            state.c = CONFIG.coefficients.c.default;

            // Update all inputs
            elements.sliderA.value = state.a;
            elements.sliderB.value = state.b;
            elements.sliderC.value = state.c;
            elements.inputA.value = state.a;
            elements.inputB.value = state.b;
            elements.inputC.value = state.c;

            // Update displays
            updateCoefficientDisplays();
            updateInfoPanel();
            drawGraph();
        }

        /**
         * Toggle challenge mode
         */
        function toggleChallengeMode() {
            state.challengeMode = !state.challengeMode;
            state.showSolution = false;

            // Update toggle appearance
            elements.challengeToggle.classList.toggle('active', state.challengeMode);
            elements.challengeToggle.setAttribute('aria-checked', state.challengeMode);
            elements.toggleLabel.textContent = state.challengeMode ? 'On' : 'Off';

            // Show/hide challenge content
            elements.challengeContent.classList.toggle('visible', state.challengeMode);
            elements.accuracyDisplay.classList.remove('visible');

            if (state.challengeMode) {
                generateChallenge();
            }

            drawGraph();
        }

        /**
         * Generate a new challenge
         */
        function generateChallenge() {
            state.showSolution = false;
            elements.accuracyDisplay.classList.remove('visible');

            // Generate random coefficients within reasonable ranges
            state.challengeA = Math.round((Math.random() * 4 - 2) * 10) / 10; // -2 to 2
            if (state.challengeA === 0) state.challengeA = 1; // Avoid a = 0

            state.challengeB = Math.round((Math.random() * 10 - 5) * 2) / 2; // -5 to 5
            state.challengeC = Math.round((Math.random() * 10 - 5) * 2) / 2; // -5 to 5

            // Reset user values
            resetCoefficients();

            drawGraph();
        }

        /**
         * Check answer accuracy
         */
        function checkAnswer() {
            // Calculate accuracy for each coefficient
            const aError = Math.abs(state.a - state.challengeA);
            const bError = Math.abs(state.b - state.challengeB);
            const cError = Math.abs(state.c - state.challengeC);

            // Calculate accuracy percentages (max error of 10 = 0%)
            const aAccuracy = Math.max(0, 100 - aError * 20);
            const bAccuracy = Math.max(0, 100 - bError * 10);
            const cAccuracy = Math.max(0, 100 - cError * 10);

            // Overall accuracy
            const overallAccuracy = Math.round((aAccuracy + bAccuracy + cAccuracy) / 3);

            // Display accuracy
            elements.accuracyDisplay.textContent = `Accuracy: ${overallAccuracy}%`;
            elements.accuracyDisplay.classList.add('visible');

            // Color based on accuracy
            elements.accuracyDisplay.classList.remove('accuracy-excellent', 'accuracy-good', 'accuracy-poor');
            if (overallAccuracy >= 90) {
                elements.accuracyDisplay.classList.add('accuracy-excellent');
                elements.accuracyDisplay.textContent += ' - Excellent!';
            } else if (overallAccuracy >= 70) {
                elements.accuracyDisplay.classList.add('accuracy-good');
                elements.accuracyDisplay.textContent += ' - Good effort!';
            } else {
                elements.accuracyDisplay.classList.add('accuracy-poor');
                elements.accuracyDisplay.textContent += ' - Keep trying!';
            }
        }

        /**
         * Reveal the solution
         */
        function revealSolution() {
            state.showSolution = true;

            // Set coefficients to challenge values
            state.a = state.challengeA;
            state.b = state.challengeB;
            state.c = state.challengeC;

            // Update inputs
            elements.sliderA.value = state.a;
            elements.sliderB.value = state.b;
            elements.sliderC.value = state.c;
            elements.inputA.value = state.a;
            elements.inputB.value = state.b;
            elements.inputC.value = state.c;

            // Update displays
            updateCoefficientDisplays();
            updateInfoPanel();
            drawGraph();

            // Show 100% accuracy
            elements.accuracyDisplay.textContent = 'Solution revealed! a = ' +
                formatNumber(state.challengeA) + ', b = ' +
                formatNumber(state.challengeB) + ', c = ' +
                formatNumber(state.challengeC);
            elements.accuracyDisplay.classList.add('visible');
            elements.accuracyDisplay.classList.remove('accuracy-excellent', 'accuracy-good', 'accuracy-poor');
        }

        /**
         * Handle window resize
         */
        function handleResize() {
            drawGraph();
        }

        // ============================================================
        // Initialization
        // ============================================================

        /**
         * Set up all event listeners
         */
        function setupEventListeners() {
            // Slider events
            elements.sliderA.addEventListener('input', (e) => handleSliderChange('a', e.target.value));
            elements.sliderB.addEventListener('input', (e) => handleSliderChange('b', e.target.value));
            elements.sliderC.addEventListener('input', (e) => handleSliderChange('c', e.target.value));

            // Number input events
            elements.inputA.addEventListener('change', (e) => handleInputChange('a', e.target.value));
            elements.inputB.addEventListener('change', (e) => handleInputChange('b', e.target.value));
            elements.inputC.addEventListener('change', (e) => handleInputChange('c', e.target.value));

            // Button events
            elements.resetBtn.addEventListener('click', resetCoefficients);
            elements.challengeToggle.addEventListener('click', toggleChallengeMode);
            elements.newChallengeBtn.addEventListener('click', generateChallenge);
            elements.checkAnswerBtn.addEventListener('click', checkAnswer);
            elements.revealBtn.addEventListener('click', revealSolution);

            // Keyboard support for toggle
            elements.challengeToggle.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    toggleChallengeMode();
                }
            });

            // Window resize
            window.addEventListener('resize', handleResize);
        }

        /**
         * Initialize the application
         */
        function init() {
            setupEventListeners();
            updateCoefficientDisplays();
            updateInfoPanel();
            drawGraph();
        }

        // Start the application when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
