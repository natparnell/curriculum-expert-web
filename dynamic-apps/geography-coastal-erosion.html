<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Coastal Erosion Simulator</title>
<style>
:root {
  --ocean-deep: #1a5276;
  --ocean-mid: #2980b9;
  --ocean-light: #5dade2;
  --ocean-surface: #85c1e9;
  --sky-light: #d6eaf8;
  --sky-top: #aed6f1;
  --sand-light: #f9e79f;
  --sand-mid: #f0d27a;
  --sand-dark: #d4ac0d;
  --cliff-brown: #8b6914;
  --cliff-dark: #6e4b0a;
  --cliff-hard: #7b7d7d;
  --cliff-hard-dark: #566573;
  --rock-soft: #c4a45a;
  --rock-hard: #808b96;
  --text-primary: #1b2631;
  --text-secondary: #2c3e50;
  --text-light: #f8f9fa;
  --panel-bg: #fdfefe;
  --panel-border: #d5dbdb;
  --accent: #e67e22;
  --accent-hover: #d35400;
  --success: #27ae60;
  --danger: #c0392b;
  --label-bg: rgba(26, 82, 118, 0.92);
  --shadow: 0 2px 8px rgba(0,0,0,0.12);
  --radius: 8px;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--sky-light);
  color: var(--text-primary);
  min-height: 100vh;
}

header {
  position: sticky;
  top: 0;
  z-index: 100;
  background: linear-gradient(135deg, var(--ocean-deep), var(--ocean-mid));
  color: var(--text-light);
  padding: 14px 24px;
  box-shadow: 0 3px 12px rgba(0,0,0,0.2);
}

header h1 {
  font-size: 1.5rem;
  font-weight: 700;
  letter-spacing: 0.3px;
}

header p {
  font-size: 0.85rem;
  opacity: 0.85;
  margin-top: 2px;
}

.app-layout {
  max-width: 1280px;
  margin: 0 auto;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.canvas-wrapper {
  position: relative;
  background: var(--panel-bg);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  overflow: hidden;
  border: 1px solid var(--panel-border);
}

canvas {
  display: block;
  width: 100%;
  height: auto;
  cursor: crosshair;
}

.controls-row {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  align-items: stretch;
}

.control-panel {
  background: var(--panel-bg);
  border: 1px solid var(--panel-border);
  border-radius: var(--radius);
  padding: 14px 18px;
  box-shadow: var(--shadow);
  flex: 1;
  min-width: 200px;
}

.control-panel h3 {
  font-size: 0.82rem;
  text-transform: uppercase;
  letter-spacing: 0.8px;
  color: var(--ocean-deep);
  margin-bottom: 10px;
  border-bottom: 2px solid var(--ocean-light);
  padding-bottom: 6px;
}

.btn-group {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
}

.btn {
  padding: 7px 16px;
  border: none;
  border-radius: 5px;
  font-size: 0.82rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-play { background: var(--success); color: white; }
.btn-play:hover { background: #219a52; }
.btn-pause { background: var(--accent); color: white; }
.btn-pause:hover { background: var(--accent-hover); }
.btn-reset { background: var(--danger); color: white; }
.btn-reset:hover { background: #a93226; }

.slider-group {
  margin-top: 10px;
}

.slider-group label {
  display: flex;
  justify-content: space-between;
  font-size: 0.78rem;
  font-weight: 600;
  color: var(--text-secondary);
  margin-bottom: 4px;
}

.slider-group input[type="range"] {
  width: 100%;
  accent-color: var(--ocean-mid);
  cursor: pointer;
}

.time-display {
  text-align: center;
  padding: 8px;
  background: linear-gradient(135deg, var(--ocean-deep), var(--ocean-mid));
  color: white;
  border-radius: 6px;
  margin-top: 8px;
}

.time-display .years {
  font-size: 1.4rem;
  font-weight: 700;
  font-variant-numeric: tabular-nums;
}

.time-display .label {
  font-size: 0.7rem;
  opacity: 0.8;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.erosion-types {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 6px;
}

.erosion-btn {
  padding: 6px 8px;
  border: 2px solid var(--panel-border);
  border-radius: 5px;
  background: white;
  font-size: 0.72rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  text-align: center;
}

.erosion-btn.active {
  border-color: var(--ocean-mid);
  background: var(--sky-light);
  color: var(--ocean-deep);
}

.erosion-btn:hover { border-color: var(--ocean-light); }

.erosion-explanation {
  margin-top: 10px;
  padding: 10px;
  background: var(--sky-light);
  border-radius: 6px;
  font-size: 0.78rem;
  line-height: 1.5;
  color: var(--text-secondary);
  min-height: 60px;
}

.info-section {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

.info-card {
  background: var(--panel-bg);
  border: 1px solid var(--panel-border);
  border-radius: var(--radius);
  padding: 16px;
  box-shadow: var(--shadow);
}

.info-card h3 {
  font-size: 0.9rem;
  color: var(--ocean-deep);
  margin-bottom: 8px;
  border-bottom: 2px solid var(--ocean-light);
  padding-bottom: 6px;
}

.info-card p, .info-card li {
  font-size: 0.8rem;
  line-height: 1.6;
  color: var(--text-secondary);
}

.info-card ul {
  padding-left: 18px;
  margin-top: 6px;
}

.info-card li { margin-bottom: 4px; }

.feature-legend {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-top: 8px;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 5px;
  font-size: 0.75rem;
}

.legend-swatch {
  width: 14px;
  height: 14px;
  border-radius: 3px;
  border: 1px solid #ccc;
}

.annotations-list {
  position: absolute;
  top: 8px;
  right: 8px;
  display: flex;
  flex-direction: column;
  gap: 4px;
  pointer-events: none;
  z-index: 10;
}

.annotation {
  background: var(--label-bg);
  color: white;
  padding: 4px 10px;
  border-radius: 4px;
  font-size: 0.72rem;
  font-weight: 600;
  animation: fadeIn 0.5s ease;
  white-space: nowrap;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateX(10px); }
  to { opacity: 1; transform: translateX(0); }
}

.rock-toggles {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.rock-toggle {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.78rem;
}

.rock-toggle select {
  padding: 3px 6px;
  border: 1px solid var(--panel-border);
  border-radius: 4px;
  font-size: 0.75rem;
  background: white;
}

.rock-toggle .rock-label {
  min-width: 64px;
  font-weight: 600;
}

@media (max-width: 768px) {
  header { padding: 10px 16px; }
  header h1 { font-size: 1.2rem; }
  .app-layout { padding: 10px; }
  .info-section { grid-template-columns: 1fr; }
  .erosion-types { grid-template-columns: 1fr; }
  .controls-row { flex-direction: column; }
}
</style>
</head>
<body>

<header>
  <h1>Coastal Erosion Simulator</h1>
  <p>Watch headlands, bays, caves, arches, stacks and stumps form through erosion over geological time</p>
</header>

<div class="app-layout">
  <div class="canvas-wrapper">
    <canvas id="simCanvas" width="800" height="500"></canvas>
    <div class="annotations-list" id="annotations"></div>
  </div>

  <div class="controls-row">
    <div class="control-panel">
      <h3>Simulation</h3>
      <div class="btn-group">
        <button class="btn btn-play" id="btnPlay" onclick="togglePlay()">Play</button>
        <button class="btn btn-pause" id="btnPause" onclick="togglePause()" style="display:none">Pause</button>
        <button class="btn btn-reset" onclick="resetSim()">Reset</button>
      </div>
      <div class="time-display">
        <div class="years" id="yearDisplay">0</div>
        <div class="label">Years Elapsed</div>
      </div>
      <div class="slider-group">
        <label><span>Time Speed</span><span id="speedVal">5x</span></label>
        <input type="range" id="speedSlider" min="1" max="20" value="5" oninput="updateSpeed()">
      </div>
      <div class="slider-group">
        <label><span>Wave Power</span><span id="waveVal">Medium</span></label>
        <input type="range" id="waveSlider" min="1" max="10" value="5" oninput="updateWave()">
      </div>
    </div>

    <div class="control-panel">
      <h3>Erosion Type Focus</h3>
      <div class="erosion-types">
        <button class="erosion-btn active" data-type="hydraulic" onclick="setErosion('hydraulic')">Hydraulic Action</button>
        <button class="erosion-btn" data-type="abrasion" onclick="setErosion('abrasion')">Abrasion</button>
        <button class="erosion-btn" data-type="attrition" onclick="setErosion('attrition')">Attrition</button>
        <button class="erosion-btn" data-type="solution" onclick="setErosion('solution')">Solution</button>
      </div>
      <div class="erosion-explanation" id="erosionExplain">
        <strong>Hydraulic Action:</strong> Waves crash against rock, compressing air into cracks. The pressure forces the rock apart over time, widening joints and faults in the cliff face.
      </div>
    </div>

    <div class="control-panel">
      <h3>Rock Layers (Top to Bottom)</h3>
      <div class="rock-toggles" id="rockToggles"></div>
      <div class="feature-legend" style="margin-top: 12px;">
        <div class="legend-item"><div class="legend-swatch" style="background: var(--rock-hard)"></div> Hard Rock</div>
        <div class="legend-item"><div class="legend-swatch" style="background: var(--rock-soft)"></div> Soft Rock</div>
        <div class="legend-item"><div class="legend-swatch" style="background: var(--ocean-mid)"></div> Ocean</div>
        <div class="legend-item"><div class="legend-swatch" style="background: var(--sand-mid)"></div> Beach/Sand</div>
      </div>
    </div>
  </div>

  <div class="info-section">
    <div class="info-card">
      <h3>Erosion Processes</h3>
      <ul>
        <li><strong>Hydraulic action:</strong> Waves force air into cracks in the rock, creating pressure that breaks the rock apart.</li>
        <li><strong>Abrasion:</strong> Waves hurl rocks and sediment at the cliff face, grinding it away like sandpaper.</li>
        <li><strong>Attrition:</strong> Rocks and pebbles carried by waves collide with each other, becoming smaller and smoother over time.</li>
        <li><strong>Solution:</strong> Slightly acidic seawater dissolves certain rock types (especially limestone and chalk) chemically.</li>
      </ul>
    </div>

    <div class="info-card">
      <h3>Concordant vs Discordant Coastlines</h3>
      <p><strong>Discordant coastlines</strong> have alternating bands of hard and soft rock at right angles to the sea. This creates headlands (hard rock) and bays (soft rock erodes faster). This simulator models a discordant coastline.</p>
      <p style="margin-top: 8px;"><strong>Concordant coastlines</strong> have rock layers running parallel to the sea. If the outer hard rock is breached, the softer rock behind erodes rapidly, forming coves.</p>
    </div>

    <div class="info-card">
      <h3>Feature Formation Sequence</h3>
      <p>On a headland, erosion follows a predictable sequence:</p>
      <ul>
        <li><strong>Crack:</strong> Hydraulic action widens a fault in the rock.</li>
        <li><strong>Cave:</strong> Continued erosion deepens the crack into a cave.</li>
        <li><strong>Arch:</strong> Erosion breaks through the headland, forming a natural arch.</li>
        <li><strong>Stack:</strong> The arch roof collapses, leaving an isolated column of rock.</li>
        <li><strong>Stump:</strong> The stack is further eroded to a low stump at water level.</li>
      </ul>
    </div>

    <div class="info-card">
      <h3>Real-World Examples</h3>
      <ul>
        <li><strong>Durdle Door, Dorset:</strong> A famous natural limestone arch on the Jurassic Coast, formed by wave erosion breaking through a headland.</li>
        <li><strong>Old Harry Rocks, Dorset:</strong> Chalk stacks and stumps at Handfast Point, showing various stages of erosion from stack to stump.</li>
        <li><strong>Flamborough Head, Yorkshire:</strong> A chalk headland with caves and arches carved by North Sea waves.</li>
        <li><strong>The Needles, Isle of Wight:</strong> Three chalk stacks marking the western tip of the island, remnants of a former ridge.</li>
      </ul>
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const annotationsEl = document.getElementById('annotations');

const W = 800, H = 500;
canvas.width = W;
canvas.height = H;

const SEA_LEVEL = 310;
const COAST_Y_TOP = 80;
const INITIAL_COAST_X = 550;

const EROSION_TEXTS = {
  hydraulic: '<strong>Hydraulic Action:</strong> Waves crash against rock, compressing air into cracks. The pressure forces the rock apart over time, widening joints and faults in the cliff face.',
  abrasion: '<strong>Abrasion:</strong> Waves hurl rocks and pebbles at the cliff face, wearing it away like sandpaper. This is the most effective erosion process on many coastlines.',
  attrition: '<strong>Attrition:</strong> Rocks and pebbles carried by waves smash into each other, becoming smaller and rounder. This creates the smooth pebbles and sand found on beaches.',
  solution: '<strong>Solution (Corrosion):</strong> Seawater is slightly acidic and dissolves soluble rocks like limestone and chalk. This chemical process weakens the rock structure over time.'
};

let playing = false;
let speed = 5;
let wavePower = 5;
let erosionType = 'hydraulic';
let years = 0;
let animFrame = null;
let lastTime = 0;

const NUM_BANDS = 5;
let bands = [];
let waves = [];
let particles = [];
let annotations = [];

function initBands() {
  const bandHeight = (SEA_LEVEL - COAST_Y_TOP) / NUM_BANDS;
  const pattern = ['hard', 'soft', 'hard', 'soft', 'hard'];
  bands = pattern.map((type, i) => ({
    type: type,
    y: COAST_Y_TOP + i * bandHeight,
    h: bandHeight,
    coastX: INITIAL_COAST_X,
    eroded: 0,
    caveDepth: 0,
    hasArch: false,
    archCollapsed: false,
    stackHeight: 0,
    stumpOnly: false,
    featureX: 0,
    featureWidth: 30,
    crackFormed: false,
    caveFormed: false,
    archFormed: false,
    stackFormed: false,
    stumpFormed: false
  }));
  buildRockToggles();
}

function buildRockToggles() {
  const container = document.getElementById('rockToggles');
  container.innerHTML = '';
  bands.forEach((b, i) => {
    const div = document.createElement('div');
    div.className = 'rock-toggle';
    div.innerHTML = `
      <span class="rock-label">Band ${i + 1}:</span>
      <select onchange="toggleRock(${i}, this.value)">
        <option value="hard" ${b.type === 'hard' ? 'selected' : ''}>Hard Rock</option>
        <option value="soft" ${b.type === 'soft' ? 'selected' : ''}>Soft Rock</option>
      </select>`;
    container.appendChild(div);
  });
}

function toggleRock(index, value) {
  bands[index].type = value;
}

function initWaves() {
  waves = [];
  for (let i = 0; i < 12; i++) {
    waves.push({
      x: Math.random() * INITIAL_COAST_X,
      y: SEA_LEVEL - 30 + Math.random() * 60,
      speed: 0.5 + Math.random() * 1.5,
      amp: 3 + Math.random() * 8,
      phase: Math.random() * Math.PI * 2,
      length: 30 + Math.random() * 50
    });
  }
}

function initParticles() {
  particles = [];
}

function spawnSplash(x, y) {
  for (let i = 0; i < 3; i++) {
    particles.push({
      x: x,
      y: y,
      vx: -1 - Math.random() * 3,
      vy: -2 - Math.random() * 4,
      life: 30 + Math.random() * 30,
      maxLife: 60,
      size: 1.5 + Math.random() * 2
    });
  }
}

function addAnnotation(text) {
  const exists = annotations.find(a => a.text === text);
  if (exists) return;
  annotations.push({ text, time: 200 });
}

function updateAnnotations() {
  annotations = annotations.filter(a => {
    a.time--;
    return a.time > 0;
  });
  annotationsEl.innerHTML = annotations.map(a => {
    const opacity = a.time < 30 ? a.time / 30 : 1;
    return `<div class="annotation" style="opacity:${opacity}">${a.text}</div>`;
  }).join('');
}

function getErosionRate(band) {
  const baseRate = band.type === 'soft' ? 0.035 : 0.008;
  const waveMultiplier = wavePower / 5;
  let typeMultiplier = 1;
  if (erosionType === 'hydraulic') typeMultiplier = band.type === 'hard' ? 1.2 : 0.9;
  if (erosionType === 'abrasion') typeMultiplier = 1.3;
  if (erosionType === 'attrition') typeMultiplier = 0.7;
  if (erosionType === 'solution') typeMultiplier = band.type === 'soft' ? 1.4 : 0.5;
  return baseRate * waveMultiplier * typeMultiplier * speed * 0.3;
}

function updateErosion(dt) {
  years += speed * dt * 8;
  document.getElementById('yearDisplay').textContent = Math.floor(years).toLocaleString();

  bands.forEach((band, i) => {
    const rate = getErosionRate(band);
    band.eroded += rate * dt;
    band.coastX = INITIAL_COAST_X - band.eroded;
    if (band.coastX < 150) band.coastX = 150;

    if (band.type === 'hard') {
      updateHeadlandFeatures(band, dt);
    }
  });
}

function updateHeadlandFeatures(band, dt) {
  const neighbours = bands.filter(b => b.type === 'soft');
  const avgSoftErosion = neighbours.length > 0
    ? neighbours.reduce((s, b) => s + b.eroded, 0) / neighbours.length
    : 0;
  const headlandExposure = avgSoftErosion - band.eroded;

  if (headlandExposure < 20) return;

  const featureRate = (wavePower / 5) * speed * 0.02 * dt;

  if (!band.crackFormed && headlandExposure > 25) {
    band.crackFormed = true;
    band.featureX = band.coastX + 5;
    addAnnotation('Crack forming in headland');
  }

  if (band.crackFormed && !band.caveFormed) {
    band.caveDepth += featureRate * 1.5;
    if (band.caveDepth > 15) {
      band.caveFormed = true;
      addAnnotation('Cave developing');
    }
  }

  if (band.caveFormed && !band.archFormed) {
    band.caveDepth += featureRate;
    if (band.caveDepth > 35) {
      band.hasArch = true;
      band.archFormed = true;
      addAnnotation('Arch formed!');
    }
  }

  if (band.archFormed && !band.stackFormed) {
    band.caveDepth += featureRate * 0.5;
    if (band.caveDepth > 55) {
      band.archCollapsed = true;
      band.stackFormed = true;
      band.stackHeight = band.h * 0.8;
      addAnnotation('Arch collapsed: Stack!');
    }
  }

  if (band.stackFormed && !band.stumpFormed) {
    band.stackHeight -= featureRate * 0.8;
    if (band.stackHeight < band.h * 0.25) {
      band.stumpOnly = true;
      band.stumpFormed = true;
      addAnnotation('Stack eroded to stump');
    }
  }

  if (band.stumpFormed) {
    band.stackHeight -= featureRate * 0.2;
    if (band.stackHeight < 2) band.stackHeight = 2;
  }
}

function updateWaves(dt) {
  waves.forEach(w => {
    w.phase += w.speed * dt * 2;
    const targetX = getMinCoastX();
    w.x += (wavePower * 0.4) * dt;
    if (w.x > targetX - 10) {
      spawnSplash(w.x, w.y);
      w.x = Math.random() * 100;
      w.y = SEA_LEVEL - 30 + Math.random() * 60;
    }
  });

  particles = particles.filter(p => {
    p.x += p.vx * dt * 20;
    p.y += p.vy * dt * 20;
    p.vy += 6 * dt;
    p.life--;
    return p.life > 0;
  });
}

function getMinCoastX() {
  return Math.min(...bands.map(b => b.coastX));
}

function drawSky() {
  const grad = ctx.createLinearGradient(0, 0, 0, SEA_LEVEL);
  grad.addColorStop(0, '#87ceeb');
  grad.addColorStop(0.7, '#b8def5');
  grad.addColorStop(1, '#d6eaf8');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, SEA_LEVEL);
}

function drawSea() {
  const grad = ctx.createLinearGradient(0, SEA_LEVEL, 0, H);
  grad.addColorStop(0, '#5dade2');
  grad.addColorStop(0.3, '#2e86c1');
  grad.addColorStop(1, '#1a5276');
  ctx.fillStyle = grad;
  ctx.fillRect(0, SEA_LEVEL, W, H - SEA_LEVEL);

  const t = performance.now() / 1000;
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1.5;
  for (let row = 0; row < 6; row++) {
    const wy = SEA_LEVEL + 15 + row * 28;
    ctx.beginPath();
    for (let x = 0; x < W; x += 3) {
      const y = wy + Math.sin(x * 0.02 + t * 1.5 + row) * (3 + row * 0.5);
      x === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.stroke();
  }
}

function drawCliffs() {
  bands.forEach((band, i) => {
    const hardColor = '#7b7d7d';
    const hardDark = '#566573';
    const softColor = '#c4a45a';
    const softDark = '#a38528';

    const baseColor = band.type === 'hard' ? hardColor : softColor;
    const darkColor = band.type === 'hard' ? hardDark : softDark;

    ctx.fillStyle = baseColor;
    ctx.fillRect(band.coastX, band.y, W - band.coastX, band.h);

    ctx.fillStyle = darkColor;
    ctx.fillRect(band.coastX, band.y, 4, band.h);

    if (band.type === 'hard') {
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.lineWidth = 0.5;
      for (let lx = band.coastX + 15; lx < W; lx += 20) {
        ctx.beginPath();
        ctx.moveTo(lx, band.y);
        ctx.lineTo(lx, band.y + band.h);
        ctx.stroke();
      }
    } else {
      ctx.fillStyle = 'rgba(0,0,0,0.04)';
      for (let dx = 10; dx < W - band.coastX; dx += 12) {
        for (let dy = 4; dy < band.h; dy += 8) {
          ctx.fillRect(band.coastX + dx, band.y + dy, 4, 2);
        }
      }
    }
  });

  ctx.fillStyle = '#5c3d0a';
  const topX = Math.min(...bands.map(b => b.coastX));
  ctx.fillRect(topX - 5, COAST_Y_TOP - 8, W - topX + 10, 8);
  ctx.fillStyle = '#2d8a4e';
  for (let gx = topX; gx < W; gx += 8) {
    const gh = 3 + Math.sin(gx * 0.3) * 2;
    ctx.fillRect(gx, COAST_Y_TOP - 8 - gh, 4, gh);
  }
}

function drawHeadlandFeatures() {
  bands.forEach(band => {
    if (band.type !== 'hard') return;
    if (!band.crackFormed) return;

    const fx = band.featureX || band.coastX + 5;
    const cy = band.y + band.h / 2;

    if (band.archCollapsed) {
      const stackX = fx + 15;
      const stackW = band.featureWidth * 0.5;

      if (band.stumpOnly) {
        ctx.fillStyle = '#6b6e70';
        const stumpH = Math.max(band.stackHeight, 2);
        ctx.fillRect(stackX, cy - stumpH / 2, stackW, stumpH);
        ctx.fillStyle = 'rgba(93,173,226,0.4)';
        ctx.fillRect(stackX, cy, stackW, stumpH / 2);
        drawFeatureLabel(stackX + stackW / 2, band.y - 4, 'Stump');
      } else {
        ctx.fillStyle = '#7b7d7d';
        const sh = band.stackHeight;
        ctx.fillRect(stackX, cy - sh / 2, stackW, sh);
        ctx.fillStyle = '#566573';
        ctx.fillRect(stackX, cy - sh / 2, 2, sh);
        drawFeatureLabel(stackX + stackW / 2, band.y - 4, 'Stack');
      }

      ctx.fillStyle = '#5dade2';
      ctx.fillRect(fx - 5, band.y, 25, band.h);
    } else if (band.hasArch) {
      ctx.fillStyle = '#5dade2';
      const archH = band.h * 0.55;
      const archW = band.caveDepth * 0.6;
      ctx.fillRect(fx - 2, cy - archH / 2, archW, archH);

      ctx.fillStyle = '#7b7d7d';
      ctx.fillRect(fx - 2, band.y, archW, (band.h - archH) / 2);
      ctx.fillRect(fx - 2, cy + archH / 2, archW, (band.h - archH) / 2);
      drawFeatureLabel(fx + archW / 2, band.y - 4, 'Arch');
    } else if (band.caveFormed) {
      ctx.fillStyle = '#2c3e50';
      const caveH = band.h * 0.4;
      const caveW = band.caveDepth * 0.5;
      ctx.beginPath();
      ctx.ellipse(fx, cy, caveW, caveH / 2, 0, -Math.PI / 2, Math.PI / 2);
      ctx.fill();
      drawFeatureLabel(fx, band.y - 4, 'Cave');
    } else if (band.crackFormed) {
      ctx.strokeStyle = '#2c3e50';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(fx, band.y + 2);
      const crackLen = Math.min(band.caveDepth * 2 + 8, band.h - 4);
      ctx.lineTo(fx + 2, band.y + crackLen);
      ctx.stroke();
      drawFeatureLabel(fx, band.y - 4, 'Crack');
    }
  });
}

function drawFeatureLabel(x, y, text) {
  ctx.font = 'bold 10px sans-serif';
  const tw = ctx.measureText(text).width;
  ctx.fillStyle = 'rgba(26, 82, 118, 0.88)';
  ctx.fillRect(x - tw / 2 - 4, y - 12, tw + 8, 15);
  ctx.fillStyle = 'white';
  ctx.textAlign = 'center';
  ctx.fillText(text, x, y - 1);
  ctx.textAlign = 'left';
}

function drawBeach() {
  bands.forEach(band => {
    if (band.type !== 'soft') return;
    const beachW = Math.min(band.eroded * 0.3, 25);
    if (beachW < 2) return;
    const grad = ctx.createLinearGradient(band.coastX - beachW, 0, band.coastX, 0);
    grad.addColorStop(0, '#f9e79f');
    grad.addColorStop(1, '#d4ac0d');
    ctx.fillStyle = grad;
    ctx.fillRect(band.coastX - beachW, band.y, beachW, band.h);
  });
}

function drawWaves() {
  const t = performance.now() / 1000;
  waves.forEach(w => {
    const y = w.y + Math.sin(w.phase) * w.amp;
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(w.x - w.length / 2, y);
    for (let dx = 0; dx <= w.length; dx += 3) {
      const wy = y + Math.sin(dx * 0.15 + t * 3) * 2;
      ctx.lineTo(w.x - w.length / 2 + dx, wy);
    }
    ctx.stroke();
  });

  particles.forEach(p => {
    const alpha = p.life / p.maxLife;
    ctx.fillStyle = `rgba(200, 230, 255, ${alpha})`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
  });
}

function drawErosionIndicator() {
  const icons = {
    hydraulic: { symbol: '~}', desc: 'Air pressure in cracks' },
    abrasion: { symbol: '////', desc: 'Rock grinding cliff' },
    attrition: { symbol: 'oo', desc: 'Rocks colliding' },
    solution: { symbol: 'H+', desc: 'Acid dissolving rock' }
  };
  const info = icons[erosionType];
  ctx.fillStyle = 'rgba(26, 82, 118, 0.85)';
  ctx.fillRect(8, H - 32, 190, 24);
  ctx.fillStyle = 'white';
  ctx.font = 'bold 11px sans-serif';
  ctx.fillText(`${erosionType.charAt(0).toUpperCase() + erosionType.slice(1)}: ${info.desc}`, 14, H - 16);
}

function drawDiscordantLabel() {
  ctx.fillStyle = 'rgba(26, 82, 118, 0.8)';
  ctx.fillRect(8, 8, 160, 22);
  ctx.fillStyle = 'white';
  ctx.font = 'bold 10px sans-serif';
  ctx.fillText('Discordant Coastline (top view)', 14, 23);
}

function drawSeaLabel() {
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.font = 'bold 16px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('SEA', 120, SEA_LEVEL + 60);
  ctx.textAlign = 'left';

  ctx.save();
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.font = 'bold 13px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('LAND', W - 60, COAST_Y_TOP + 40);
  ctx.textAlign = 'left';
  ctx.restore();
}

function drawWaveArrows() {
  const t = performance.now() / 1000;
  const minX = getMinCoastX();
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 2;

  for (let row = 0; row < 3; row++) {
    const ay = SEA_LEVEL + 20 + row * 50;
    const ax = 40 + Math.sin(t * 1.2 + row) * 15;
    ctx.beginPath();
    ctx.moveTo(ax, ay);
    ctx.lineTo(ax + 50, ay);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(ax + 50, ay);
    ctx.lineTo(ax + 43, ay - 5);
    ctx.lineTo(ax + 43, ay + 5);
    ctx.fill();
  }
}

function render() {
  ctx.clearRect(0, 0, W, H);
  drawSky();
  drawSea();
  drawWaveArrows();
  drawCliffs();
  drawBeach();
  drawHeadlandFeatures();
  drawWaves();
  drawErosionIndicator();
  drawDiscordantLabel();
  drawSeaLabel();
}

function gameLoop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
  lastTime = timestamp;

  if (playing) {
    updateErosion(dt);
    updateWaves(dt);
    updateAnnotations();
  } else {
    updateWaves(dt);
  }

  render();
  animFrame = requestAnimationFrame(gameLoop);
}

function togglePlay() {
  playing = true;
  document.getElementById('btnPlay').style.display = 'none';
  document.getElementById('btnPause').style.display = '';
}

function togglePause() {
  playing = false;
  document.getElementById('btnPlay').style.display = '';
  document.getElementById('btnPause').style.display = 'none';
}

function resetSim() {
  playing = false;
  years = 0;
  annotations = [];
  annotationsEl.innerHTML = '';
  document.getElementById('yearDisplay').textContent = '0';
  document.getElementById('btnPlay').style.display = '';
  document.getElementById('btnPause').style.display = 'none';
  initBands();
  initWaves();
  initParticles();
}

function updateSpeed() {
  speed = parseInt(document.getElementById('speedSlider').value);
  document.getElementById('speedVal').textContent = speed + 'x';
}

function updateWave() {
  wavePower = parseInt(document.getElementById('waveSlider').value);
  const labels = ['', 'Very Gentle', 'Gentle', 'Calm', 'Moderate', 'Medium',
    'Strong', 'Rough', 'Very Rough', 'Severe', 'Storm Force'];
  document.getElementById('waveVal').textContent = labels[wavePower];
}

function setErosion(type) {
  erosionType = type;
  document.querySelectorAll('.erosion-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.type === type);
  });
  document.getElementById('erosionExplain').innerHTML = EROSION_TEXTS[type];
}

initBands();
initWaves();
initParticles();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>