<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Probability Simulator</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
<style>
  /* ===== CSS Reset & Root Variables ===== */
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --primary: #4361ee;
    --primary-light: #6b83f2;
    --primary-dark: #2b44c7;
    --secondary: #f72585;
    --accent: #4cc9f0;
    --accent2: #7209b7;
    --success: #06d6a0;
    --warning: #ffd166;
    --bg: #f0f4ff;
    --surface: #ffffff;
    --text: #1a1a2e;
    --text-light: #555;
    --border: #dde2f1;
    --radius: 12px;
    --shadow: 0 4px 24px rgba(67, 97, 238, 0.10);
    --shadow-lg: 0 8px 40px rgba(67, 97, 238, 0.16);
    --transition: 0.25s cubic-bezier(0.4, 0, 0.2, 1);
  }

  body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    line-height: 1.5;
  }

  /* ===== Header ===== */
  header {
    background: linear-gradient(135deg, var(--primary) 0%, var(--accent2) 50%, var(--secondary) 100%);
    color: white;
    padding: 1.2rem 2rem;
    text-align: center;
    box-shadow: 0 4px 20px rgba(67, 97, 238, 0.3);
    position: relative;
    overflow: hidden;
  }
  header::before {
    content: '';
    position: absolute;
    inset: 0;
    background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='0.06'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
  }
  header h1 {
    font-size: 2.2rem;
    font-weight: 800;
    letter-spacing: -0.5px;
    position: relative;
    text-shadow: 0 2px 8px rgba(0,0,0,0.15);
  }
  header h1 .icon { font-size: 1.6rem; margin-right: 0.4rem; }
  header p {
    font-size: 1rem;
    opacity: 0.9;
    margin-top: 0.25rem;
    position: relative;
    font-weight: 500;
  }

  /* ===== Main Layout ===== */
  main {
    flex: 1;
    max-width: 1400px;
    width: 100%;
    margin: 0 auto;
    padding: 1.5rem;
    display: grid;
    grid-template-columns: 340px 1fr;
    gap: 1.5rem;
  }
  @media (max-width: 960px) {
    main { grid-template-columns: 1fr; }
  }

  /* ===== Card Component ===== */
  .card {
    background: var(--surface);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: 1.5rem;
    border: 1px solid var(--border);
    transition: box-shadow var(--transition);
  }
  .card:hover { box-shadow: var(--shadow-lg); }
  .card-title {
    font-size: 1.05rem;
    font-weight: 700;
    color: var(--primary);
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding-bottom: 0.75rem;
    border-bottom: 2px solid var(--bg);
  }
  .card-title .badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 28px; height: 28px;
    border-radius: 8px;
    font-size: 0.85rem;
    flex-shrink: 0;
  }

  /* ===== Sidebar Controls ===== */
  .sidebar { display: flex; flex-direction: column; gap: 1rem; }

  /* Experiment Selector */
  .experiment-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.5rem;
  }
  .experiment-btn {
    padding: 0.7rem 0.5rem;
    border: 2px solid var(--border);
    border-radius: 10px;
    background: var(--surface);
    cursor: pointer;
    text-align: center;
    transition: all var(--transition);
    font-size: 0.82rem;
    font-weight: 600;
    color: var(--text);
  }
  .experiment-btn .exp-icon { font-size: 1.5rem; display: block; margin-bottom: 0.2rem; }
  .experiment-btn:hover { border-color: var(--primary-light); background: #f0f3ff; transform: translateY(-1px); }
  .experiment-btn.active {
    border-color: var(--primary);
    background: linear-gradient(135deg, #eef1ff, #e8ecff);
    color: var(--primary-dark);
    box-shadow: 0 2px 12px rgba(67, 97, 238, 0.15);
  }

  /* Sub-options */
  .sub-options { margin-top: 0.75rem; }
  .sub-options label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
    border-radius: 8px;
    cursor: pointer;
    font-size: 0.88rem;
    transition: background var(--transition);
    font-weight: 500;
  }
  .sub-options label:hover { background: var(--bg); }
  .sub-options input[type="radio"] {
    accent-color: var(--primary);
    width: 16px; height: 16px;
  }

  /* Spinner Config */
  #spinnerConfig { display: none; margin-top: 0.75rem; }
  #spinnerConfig.visible { display: block; }
  .spinner-segment-row {
    display: flex;
    gap: 0.4rem;
    align-items: center;
    margin-bottom: 0.4rem;
  }
  .spinner-segment-row input[type="text"] {
    flex: 1;
    padding: 0.4rem 0.6rem;
    border: 1.5px solid var(--border);
    border-radius: 6px;
    font-size: 0.82rem;
  }
  .spinner-segment-row input[type="color"] {
    width: 32px; height: 32px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    padding: 0;
  }
  .spinner-segment-row input[type="number"] {
    width: 56px;
    padding: 0.4rem;
    border: 1.5px solid var(--border);
    border-radius: 6px;
    font-size: 0.82rem;
    text-align: center;
  }
  .spinner-segment-row button {
    background: none;
    border: none;
    color: #e74c3c;
    cursor: pointer;
    font-size: 1.1rem;
    padding: 0.2rem;
    border-radius: 4px;
    transition: background var(--transition);
  }
  .spinner-segment-row button:hover { background: #fdecea; }
  #addSegmentBtn {
    margin-top: 0.3rem;
    padding: 0.4rem 0.8rem;
    border: 1.5px dashed var(--primary);
    background: transparent;
    color: var(--primary);
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.82rem;
    font-weight: 600;
    transition: all var(--transition);
    width: 100%;
  }
  #addSegmentBtn:hover { background: #eef1ff; }

  /* Trial Buttons */
  .trial-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 0.4rem;
  }
  .trial-btn {
    flex: 1;
    min-width: 55px;
    padding: 0.55rem 0.3rem;
    border: 2px solid var(--border);
    border-radius: 8px;
    background: var(--surface);
    cursor: pointer;
    font-size: 0.82rem;
    font-weight: 700;
    color: var(--text);
    transition: all var(--transition);
    text-align: center;
  }
  .trial-btn:hover {
    border-color: var(--success);
    background: #e6faf4;
    transform: translateY(-1px);
  }

  /* Run & Reset Buttons */
  .action-buttons { display: flex; gap: 0.5rem; margin-top: 0.25rem; }
  #runBtn {
    flex: 2;
    padding: 1rem;
    border: none;
    border-radius: 10px;
    background: linear-gradient(135deg, var(--success), #05c796);
    color: white;
    font-size: 1.15rem;
    font-weight: 800;
    cursor: pointer;
    transition: all var(--transition);
    box-shadow: 0 4px 16px rgba(6, 214, 160, 0.35);
    position: relative;
    overflow: hidden;
    letter-spacing: 0.5px;
  }
  #runBtn::after {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
    transform: translateX(-100%);
    transition: transform 0.6s;
  }
  #runBtn:hover::after { transform: translateX(100%); }
  #runBtn:hover { transform: translateY(-2px); box-shadow: 0 6px 24px rgba(6, 214, 160, 0.45); }
  #runBtn:active { transform: translateY(0); }
  #runBtn.running {
    background: linear-gradient(135deg, var(--warning), #f0c040);
    box-shadow: 0 4px 16px rgba(255, 209, 102, 0.35);
    animation: pulse 0.8s ease-in-out infinite;
  }
  @keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.02); }
  }

  #resetBtn {
    flex: 1;
    padding: 1rem;
    border: 2px solid var(--border);
    border-radius: 10px;
    background: var(--surface);
    color: var(--text);
    font-size: 0.95rem;
    font-weight: 700;
    cursor: pointer;
    transition: all var(--transition);
  }
  #resetBtn:hover {
    border-color: var(--secondary);
    color: var(--secondary);
    background: #fff0f6;
  }

  /* ===== Main Content Area ===== */
  .content-area { display: flex; flex-direction: column; gap: 1rem; }

  /* Animation Canvas Area */
  #animationArea {
    height: 200px;
    background: linear-gradient(135deg, #f8f9ff, #eef1ff);
    border-radius: var(--radius);
    border: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
  }
  #animCanvas {
    width: 100%;
    height: 100%;
  }

  /* Chart Area */
  .chart-container {
    position: relative;
    width: 100%;
    min-height: 320px;
  }
  #chartCanvas { width: 100% !important; }

  /* Stats Table */
  .stats-table-wrap {
    max-height: 340px;
    overflow-y: auto;
    border-radius: 8px;
    border: 1px solid var(--border);
  }
  .stats-table-wrap::-webkit-scrollbar { width: 6px; }
  .stats-table-wrap::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
  table.stats-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.85rem;
  }
  .stats-table thead {
    position: sticky;
    top: 0;
    z-index: 1;
  }
  .stats-table th {
    background: linear-gradient(135deg, var(--primary), var(--primary-dark));
    color: white;
    padding: 0.65rem 0.8rem;
    text-align: center;
    font-weight: 700;
    font-size: 0.8rem;
    letter-spacing: 0.3px;
  }
  .stats-table td {
    padding: 0.55rem 0.8rem;
    text-align: center;
    border-bottom: 1px solid var(--border);
    font-variant-numeric: tabular-nums;
  }
  .stats-table tr:nth-child(even) { background: #f8f9ff; }
  .stats-table tr:hover { background: #eef1ff; }
  .stats-table .converging { color: var(--success); font-weight: 700; }
  .stats-table .diverging { color: var(--secondary); font-weight: 600; }

  /* Summary Stats Bar */
  .summary-bar {
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
  }
  .stat-chip {
    flex: 1;
    min-width: 120px;
    padding: 0.8rem 1rem;
    border-radius: 10px;
    text-align: center;
    font-weight: 700;
    border: 1px solid var(--border);
    background: var(--surface);
  }
  .stat-chip .stat-value {
    font-size: 1.6rem;
    display: block;
    line-height: 1.2;
  }
  .stat-chip .stat-label {
    font-size: 0.72rem;
    color: var(--text-light);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .stat-chip.primary .stat-value { color: var(--primary); }
  .stat-chip.success .stat-value { color: var(--success); }
  .stat-chip.warning .stat-value { color: var(--warning); }
  .stat-chip.accent .stat-value { color: var(--accent2); }

  /* ===== Footer ===== */
  footer {
    text-align: center;
    padding: 1rem 2rem;
    font-size: 0.8rem;
    color: var(--text-light);
    background: var(--surface);
    border-top: 1px solid var(--border);
    margin-top: auto;
  }
  footer strong { color: var(--primary); }

  /* ===== Utilities ===== */
  .hidden { display: none !important; }
  .fade-in { animation: fadeIn 0.4s ease; }
  @keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }

  /* ===== Responsive ===== */
  @media (max-width: 600px) {
    header h1 { font-size: 1.5rem; }
    main { padding: 0.75rem; }
    .card { padding: 1rem; }
    #animationArea { height: 160px; }
  }

  /* Speed selector */
  .speed-row {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-top: 0.5rem;
  }
  .speed-row label { font-size: 0.82rem; font-weight: 600; white-space: nowrap; }
  .speed-row select {
    flex: 1;
    padding: 0.4rem 0.6rem;
    border: 1.5px solid var(--border);
    border-radius: 6px;
    font-size: 0.82rem;
    background: var(--surface);
  }

  /* Trial count input */
  .trial-count-display {
    text-align: center;
    font-size: 1.1rem;
    font-weight: 700;
    color: var(--primary);
    padding: 0.5rem;
    background: var(--bg);
    border-radius: 8px;
    margin-bottom: 0.3rem;
    border: 1.5px solid var(--border);
  }
</style>
</head>
<body>

<header>
  <h1><span class="icon">&#127922;</span> Probability Simulator</h1>
  <p>Explore experimental vs theoretical probability through interactive experiments</p>
</header>

<main>
  <!-- ===== SIDEBAR ===== -->
  <div class="sidebar">
    <!-- Experiment Type -->
    <div class="card">
      <div class="card-title">
        <span class="badge" style="background:#eef1ff;color:var(--primary);">1</span>
        Choose Experiment
      </div>
      <div class="experiment-grid">
        <button class="experiment-btn active" data-exp="dice" onclick="selectExperiment('dice')">
          <span class="exp-icon">&#127922;</span> Dice
        </button>
        <button class="experiment-btn" data-exp="coin" onclick="selectExperiment('coin')">
          <span class="exp-icon">&#129689;</span> Coin
        </button>
        <button class="experiment-btn" data-exp="card" onclick="selectExperiment('card')">
          <span class="exp-icon">&#127183;</span> Cards
        </button>
        <button class="experiment-btn" data-exp="spinner" onclick="selectExperiment('spinner')">
          <span class="exp-icon">&#127761;</span> Spinner
        </button>
      </div>

      <!-- Dice sub-options -->
      <div class="sub-options" id="diceOptions">
        <label><input type="radio" name="diceMode" value="1d6" checked onchange="updateExperiment()"> Single die (1-6)</label>
        <label><input type="radio" name="diceMode" value="2d6" onchange="updateExperiment()"> Two dice (sum 2-12)</label>
      </div>

      <!-- Coin sub-options -->
      <div class="sub-options hidden" id="coinOptions">
        <label><input type="radio" name="coinMode" value="ht" checked onchange="updateExperiment()"> Heads or Tails</label>
      </div>

      <!-- Card sub-options -->
      <div class="sub-options hidden" id="cardOptions">
        <label><input type="radio" name="cardMode" value="suit" checked onchange="updateExperiment()"> By Suit</label>
        <label><input type="radio" name="cardMode" value="face" onchange="updateExperiment()"> Face vs Number vs Ace</label>
        <label><input type="radio" name="cardMode" value="colour" onchange="updateExperiment()"> Red vs Black</label>
      </div>

      <!-- Spinner config -->
      <div id="spinnerConfig">
        <div id="segmentList"></div>
        <button id="addSegmentBtn" onclick="addSpinnerSegment()">+ Add Segment</button>
      </div>
    </div>

    <!-- Trial Count -->
    <div class="card">
      <div class="card-title">
        <span class="badge" style="background:#e6faf4;color:var(--success);">2</span>
        Number of Trials
      </div>
      <div class="trial-count-display" id="trialDisplay">10 trials</div>
      <div class="trial-buttons">
        <button class="trial-btn" onclick="setTrials(1)">1</button>
        <button class="trial-btn" onclick="setTrials(10)" style="border-color:var(--success);background:#e6faf4;">10</button>
        <button class="trial-btn" onclick="setTrials(100)">100</button>
        <button class="trial-btn" onclick="setTrials(1000)">1k</button>
        <button class="trial-btn" onclick="setTrials(10000)">10k</button>
      </div>
      <div class="speed-row">
        <label>Speed:</label>
        <select id="speedSelect">
          <option value="slow">Slow (see each)</option>
          <option value="normal" selected>Normal</option>
          <option value="fast">Fast</option>
          <option value="instant">Instant</option>
        </select>
      </div>
    </div>

    <!-- Action Buttons -->
    <div class="card" style="padding: 1rem;">
      <div class="action-buttons">
        <button id="runBtn" onclick="runExperiment()">&#9654; RUN</button>
        <button id="resetBtn" onclick="resetAll()">&#8635; Reset</button>
      </div>
    </div>

    <!-- Summary Stats -->
    <div class="card" id="summaryCard">
      <div class="card-title">
        <span class="badge" style="background:#fff3e0;color:#e67e22;">&#931;</span>
        Summary
      </div>
      <div class="summary-bar">
        <div class="stat-chip primary">
          <span class="stat-value" id="totalTrialsStat">0</span>
          <span class="stat-label">Total Trials</span>
        </div>
        <div class="stat-chip success">
          <span class="stat-value" id="maxRelFreq">-</span>
          <span class="stat-label">Closest Match</span>
        </div>
      </div>
      <div class="summary-bar" style="margin-top:0.5rem;">
        <div class="stat-chip warning">
          <span class="stat-value" id="avgDiff">-</span>
          <span class="stat-label">Avg Difference</span>
        </div>
        <div class="stat-chip accent">
          <span class="stat-value" id="modeOutcome">-</span>
          <span class="stat-label">Most Frequent</span>
        </div>
      </div>
    </div>
  </div>

  <!-- ===== MAIN CONTENT ===== -->
  <div class="content-area">
    <!-- Animation Area -->
    <div class="card">
      <div class="card-title">
        <span class="badge" style="background:#fce4ec;color:var(--secondary);">&#9881;</span>
        Live Animation
        <span id="animLabel" style="margin-left:auto;font-size:0.78rem;color:var(--text-light);font-weight:500;">Ready</span>
      </div>
      <div id="animationArea">
        <canvas id="animCanvas"></canvas>
      </div>
    </div>

    <!-- Chart -->
    <div class="card">
      <div class="card-title">
        <span class="badge" style="background:#e8f5e9;color:#2e7d32;">&#128202;</span>
        Results Chart
        <span id="chartLabel" style="margin-left:auto;font-size:0.78rem;color:var(--text-light);font-weight:500;">Experimental frequency vs Theoretical probability</span>
      </div>
      <div class="chart-container">
        <canvas id="chartCanvas"></canvas>
      </div>
    </div>

    <!-- Frequency Table -->
    <div class="card">
      <div class="card-title">
        <span class="badge" style="background:#ede7f6;color:var(--accent2);">&#128220;</span>
        Frequency Table
      </div>
      <div class="stats-table-wrap">
        <table class="stats-table" id="freqTable">
          <thead>
            <tr>
              <th>Outcome</th>
              <th>Frequency</th>
              <th>Rel. Frequency</th>
              <th>Theoretical Prob.</th>
              <th>Difference</th>
            </tr>
          </thead>
          <tbody id="freqTableBody"></tbody>
        </table>
      </div>
    </div>
  </div>
</main>

<footer>
  <strong>Probability Simulator</strong> &mdash; An interactive tool for exploring experimental probability &middot; Designed for secondary school mathematics
</footer>

<script>
// ============================================================
//  STATE
// ============================================================
let currentExperiment = 'dice';
let trialCount = 10;
let totalTrials = 0;
let frequencies = {};    // outcome -> count
let outcomes = [];       // ordered list of outcome labels
let theoreticalProbs = {}; // outcome -> probability
let isRunning = false;
let chart = null;

// Spinner segments
let spinnerSegments = [
  { label: 'Red', colour: '#e74c3c', weight: 1 },
  { label: 'Blue', colour: '#3498db', weight: 1 },
  { label: 'Green', colour: '#2ecc71', weight: 1 },
  { label: 'Yellow', colour: '#f1c40f', weight: 1 },
];

// Nice colour palette for bar charts
const CHART_COLOURS = [
  '#4361ee','#f72585','#4cc9f0','#7209b7','#06d6a0','#ffd166',
  '#ef476f','#118ab2','#073b4c','#06d6a0','#8338ec','#ff6b6b',
  '#48bfe3','#64dfdf','#5e60ce','#e76f51','#2a9d8f','#e9c46a',
];

// Dice face colours
const DICE_COLOURS = { 1:'#4361ee',2:'#f72585',3:'#4cc9f0',4:'#7209b7',5:'#06d6a0',6:'#ffd166' };

// Card suits
const SUITS = ['Hearts','Diamonds','Clubs','Spades'];
const SUIT_SYMBOLS = { Hearts:'\u2665', Diamonds:'\u2666', Clubs:'\u2663', Spades:'\u2660' };
const SUIT_COLOURS_MAP = { Hearts:'#e74c3c', Diamonds:'#e74c3c', Clubs:'#2c3e50', Spades:'#2c3e50' };

// ============================================================
//  EXPERIMENT SETUP
// ============================================================
function selectExperiment(type) {
  currentExperiment = type;
  document.querySelectorAll('.experiment-btn').forEach(b => b.classList.toggle('active', b.dataset.exp === type));
  document.getElementById('diceOptions').classList.toggle('hidden', type !== 'dice');
  document.getElementById('coinOptions').classList.toggle('hidden', type !== 'coin');
  document.getElementById('cardOptions').classList.toggle('hidden', type !== 'card');
  const sc = document.getElementById('spinnerConfig');
  if (type === 'spinner') { sc.classList.add('visible'); buildSpinnerUI(); } else { sc.classList.remove('visible'); }
  resetAll();
}

function updateExperiment() { resetAll(); }

function getExperimentConfig() {
  if (currentExperiment === 'dice') {
    const mode = document.querySelector('input[name="diceMode"]:checked').value;
    if (mode === '1d6') {
      return {
        outcomes: ['1','2','3','4','5','6'],
        probs: { '1':1/6,'2':1/6,'3':1/6,'4':1/6,'5':1/6,'6':1/6 },
        sample: () => String(Math.floor(Math.random()*6)+1),
        label: 'Single Die Roll',
      };
    } else {
      const outs = []; const probs = {};
      for (let s=2; s<=12; s++) { outs.push(String(s)); let ways=0; for(let a=1;a<=6;a++) for(let b=1;b<=6;b++) if(a+b===s) ways++; probs[String(s)]=ways/36; }
      return {
        outcomes: outs, probs,
        sample: () => String(Math.floor(Math.random()*6)+1 + Math.floor(Math.random()*6)+1),
        label: 'Two Dice Sum',
      };
    }
  }
  if (currentExperiment === 'coin') {
    return {
      outcomes: ['Heads','Tails'],
      probs: { 'Heads':0.5,'Tails':0.5 },
      sample: () => Math.random() < 0.5 ? 'Heads' : 'Tails',
      label: 'Coin Flip',
    };
  }
  if (currentExperiment === 'card') {
    const mode = document.querySelector('input[name="cardMode"]:checked').value;
    if (mode === 'suit') {
      return {
        outcomes: ['Hearts','Diamonds','Clubs','Spades'],
        probs: { 'Hearts':13/52,'Diamonds':13/52,'Clubs':13/52,'Spades':13/52 },
        sample: () => SUITS[Math.floor(Math.random()*4)],
        label: 'Card Suit',
      };
    }
    if (mode === 'face') {
      return {
        outcomes: ['Ace','Number (2-10)','Face (J/Q/K)'],
        probs: { 'Ace':4/52, 'Number (2-10)':36/52, 'Face (J/Q/K)':12/52 },
        sample: () => { const v=Math.floor(Math.random()*13); if(v===0) return 'Ace'; if(v<=9) return 'Number (2-10)'; return 'Face (J/Q/K)'; },
        label: 'Card Type',
      };
    }
    if (mode === 'colour') {
      return {
        outcomes: ['Red','Black'],
        probs: { 'Red':26/52, 'Black':26/52 },
        sample: () => Math.random() < 0.5 ? 'Red' : 'Black',
        label: 'Card Colour',
      };
    }
  }
  if (currentExperiment === 'spinner') {
    const totalW = spinnerSegments.reduce((s,seg) => s + seg.weight, 0);
    const outs = spinnerSegments.map(s => s.label);
    const probs = {};
    spinnerSegments.forEach(s => probs[s.label] = s.weight / totalW);
    return {
      outcomes: outs, probs,
      sample: () => {
        let r = Math.random() * totalW; let cum = 0;
        for (const seg of spinnerSegments) { cum += seg.weight; if (r < cum) return seg.label; }
        return spinnerSegments[spinnerSegments.length-1].label;
      },
      label: 'Custom Spinner',
    };
  }
}

// ============================================================
//  SPINNER CONFIG UI
// ============================================================
function buildSpinnerUI() {
  const list = document.getElementById('segmentList');
  list.innerHTML = '';
  spinnerSegments.forEach((seg, i) => {
    const row = document.createElement('div');
    row.className = 'spinner-segment-row';
    row.innerHTML = `
      <input type="text" value="${seg.label}" onchange="spinnerSegments[${i}].label=this.value" placeholder="Label">
      <input type="color" value="${seg.colour}" onchange="spinnerSegments[${i}].colour=this.value">
      <input type="number" value="${seg.weight}" min="1" max="20" onchange="spinnerSegments[${i}].weight=parseInt(this.value)||1" title="Weight">
      <button onclick="removeSpinnerSegment(${i})" title="Remove">&times;</button>
    `;
    list.appendChild(row);
  });
}
function addSpinnerSegment() {
  const colours = ['#e74c3c','#3498db','#2ecc71','#f1c40f','#9b59b6','#e67e22','#1abc9c','#e84393'];
  spinnerSegments.push({ label:'New', colour: colours[spinnerSegments.length % colours.length], weight:1 });
  buildSpinnerUI();
  resetAll();
}
function removeSpinnerSegment(i) {
  if (spinnerSegments.length <= 2) return;
  spinnerSegments.splice(i, 1);
  buildSpinnerUI();
  resetAll();
}

// ============================================================
//  TRIALS
// ============================================================
function setTrials(n) {
  trialCount = n;
  document.getElementById('trialDisplay').textContent = n >= 1000 ? (n/1000)+'k trials' : n + ' trial' + (n>1?'s':'');
  document.querySelectorAll('.trial-btn').forEach(b => {
    const val = b.textContent.trim();
    const mapped = val === '1k' ? 1000 : val === '10k' ? 10000 : parseInt(val);
    b.style.borderColor = mapped === n ? 'var(--success)' : '';
    b.style.background = mapped === n ? '#e6faf4' : '';
  });
}

// ============================================================
//  CHART
// ============================================================
function initChart() {
  const ctx = document.getElementById('chartCanvas').getContext('2d');
  if (chart) chart.destroy();
  const config = getExperimentConfig();
  outcomes = config.outcomes;
  theoreticalProbs = config.probs;
  frequencies = {};
  outcomes.forEach(o => frequencies[o] = 0);
  totalTrials = 0;

  chart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: outcomes,
      datasets: [
        {
          label: 'Relative Frequency',
          data: outcomes.map(() => 0),
          backgroundColor: outcomes.map((_, i) => {
            if (currentExperiment === 'spinner') return spinnerSegments[i]?.colour || CHART_COLOURS[i % CHART_COLOURS.length];
            return CHART_COLOURS[i % CHART_COLOURS.length];
          }),
          borderColor: outcomes.map((_, i) => {
            if (currentExperiment === 'spinner') return spinnerSegments[i]?.colour || CHART_COLOURS[i % CHART_COLOURS.length];
            return CHART_COLOURS[i % CHART_COLOURS.length];
          }),
          borderWidth: 2,
          borderRadius: 6,
          order: 2,
        },
        {
          label: 'Theoretical Probability',
          data: outcomes.map(o => theoreticalProbs[o]),
          type: 'line',
          borderColor: '#e74c3c',
          borderWidth: 3,
          borderDash: [8, 4],
          pointBackgroundColor: '#e74c3c',
          pointRadius: 5,
          pointHoverRadius: 7,
          fill: false,
          order: 1,
          tension: 0,
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: { duration: 300 },
      scales: {
        y: {
          beginAtZero: true,
          max: 1,
          title: { display: true, text: 'Probability / Relative Frequency', font: { weight: 'bold', size: 12 } },
          grid: { color: '#eef1ff' },
          ticks: { callback: v => (v*100).toFixed(0)+'%' },
        },
        x: {
          title: { display: true, text: 'Outcome', font: { weight: 'bold', size: 12 } },
          grid: { display: false },
        }
      },
      plugins: {
        legend: {
          labels: { usePointStyle: true, padding: 16, font: { size: 12, weight: '600' } }
        },
        tooltip: {
          callbacks: {
            label: ctx => {
              const val = ctx.parsed.y;
              return ctx.dataset.label + ': ' + (val*100).toFixed(2) + '%';
            }
          }
        }
      }
    }
  });
}

function updateChart() {
  if (!chart) return;
  const relFreqs = outcomes.map(o => totalTrials > 0 ? frequencies[o] / totalTrials : 0);
  chart.data.datasets[0].data = relFreqs;
  // Adjust y-axis max dynamically
  const maxVal = Math.max(...relFreqs, ...outcomes.map(o => theoreticalProbs[o]));
  chart.options.scales.y.max = Math.min(1, Math.max(0.2, Math.ceil(maxVal * 10) / 10 + 0.05));
  chart.update('none');
}

// ============================================================
//  FREQUENCY TABLE
// ============================================================
function updateFreqTable() {
  const tbody = document.getElementById('freqTableBody');
  tbody.innerHTML = '';
  outcomes.forEach(o => {
    const count = frequencies[o];
    const relFreq = totalTrials > 0 ? count / totalTrials : 0;
    const theor = theoreticalProbs[o];
    const diff = totalTrials > 0 ? Math.abs(relFreq - theor) : 0;
    const converging = diff < 0.02;
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td style="font-weight:600;">${o}</td>
      <td>${count}</td>
      <td>${totalTrials > 0 ? (relFreq*100).toFixed(2)+'%' : '-'}</td>
      <td>${(theor*100).toFixed(2)}%</td>
      <td class="${converging ? 'converging' : (diff > 0.1 ? 'diverging' : '')}">
        ${totalTrials > 0 ? (diff < 0.001 ? '< 0.1%' : (diff*100).toFixed(2)+'%') : '-'}
      </td>
    `;
    tbody.appendChild(tr);
  });
}

// ============================================================
//  SUMMARY STATS
// ============================================================
function updateSummary() {
  document.getElementById('totalTrialsStat').textContent = totalTrials.toLocaleString();
  if (totalTrials === 0) {
    document.getElementById('maxRelFreq').textContent = '-';
    document.getElementById('avgDiff').textContent = '-';
    document.getElementById('modeOutcome').textContent = '-';
    return;
  }
  let bestOutcome = ''; let bestDiff = 999;
  let totalDiff = 0; let modeO = ''; let modeC = 0;
  outcomes.forEach(o => {
    const rf = frequencies[o] / totalTrials;
    const d = Math.abs(rf - theoreticalProbs[o]);
    totalDiff += d;
    if (d < bestDiff) { bestDiff = d; bestOutcome = o; }
    if (frequencies[o] > modeC) { modeC = frequencies[o]; modeO = o; }
  });
  document.getElementById('maxRelFreq').textContent = bestOutcome;
  document.getElementById('avgDiff').textContent = (totalDiff / outcomes.length * 100).toFixed(2) + '%';
  document.getElementById('modeOutcome').textContent = modeO + ' (' + modeC + ')';
}

// ============================================================
//  ANIMATION CANVAS
// ============================================================
const animCanvas = document.getElementById('animCanvas');
const animCtx = animCanvas.getContext('2d');
let animW, animH;

function resizeAnimCanvas() {
  const rect = document.getElementById('animationArea').getBoundingClientRect();
  animCanvas.width = rect.width * window.devicePixelRatio;
  animCanvas.height = rect.height * window.devicePixelRatio;
  animW = animCanvas.width;
  animH = animCanvas.height;
  animCtx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
}
window.addEventListener('resize', resizeAnimCanvas);

function clearAnim() {
  resizeAnimCanvas();
  const w = animW / window.devicePixelRatio;
  const h = animH / window.devicePixelRatio;
  animCtx.clearRect(0, 0, w, h);
  // Draw placeholder
  animCtx.fillStyle = '#bcc5e0';
  animCtx.font = '600 16px Segoe UI, system-ui, sans-serif';
  animCtx.textAlign = 'center';
  animCtx.fillText('Run an experiment to see the animation', w/2, h/2);
}

// ---- Die Drawing ----
function drawDie(ctx, x, y, size, value, rotation) {
  ctx.save();
  ctx.translate(x + size/2, y + size/2);
  ctx.rotate(rotation);
  // Shadow
  ctx.shadowColor = 'rgba(0,0,0,0.15)';
  ctx.shadowBlur = 10;
  ctx.shadowOffsetY = 4;
  // Die body
  const r = size * 0.15;
  roundRect(ctx, -size/2, -size/2, size, size, r);
  ctx.fillStyle = '#ffffff';
  ctx.fill();
  ctx.strokeStyle = '#ccc';
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.shadowColor = 'transparent';
  // Dots
  const dotR = size * 0.075;
  ctx.fillStyle = '#2c3e50';
  const positions = getDotPositions(value, size);
  positions.forEach(([dx, dy]) => {
    ctx.beginPath();
    ctx.arc(dx, dy, dotR, 0, Math.PI*2);
    ctx.fill();
  });
  ctx.restore();
}

function getDotPositions(val, size) {
  const s = size * 0.25;
  const positions = {
    1: [[0,0]],
    2: [[-s,-s],[s,s]],
    3: [[-s,-s],[0,0],[s,s]],
    4: [[-s,-s],[s,-s],[-s,s],[s,s]],
    5: [[-s,-s],[s,-s],[0,0],[-s,s],[s,s]],
    6: [[-s,-s],[s,-s],[-s,0],[s,0],[-s,s],[s,s]],
  };
  return positions[val] || positions[1];
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.lineTo(x+w-r, y);
  ctx.quadraticCurveTo(x+w, y, x+w, y+r);
  ctx.lineTo(x+w, y+h-r);
  ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
  ctx.lineTo(x+r, y+h);
  ctx.quadraticCurveTo(x, y+h, x, y+h-r);
  ctx.lineTo(x, y+r);
  ctx.quadraticCurveTo(x, y, x+r, y);
  ctx.closePath();
}

// ---- Coin Drawing ----
function drawCoin(ctx, cx, cy, radius, face, scaleX) {
  ctx.save();
  ctx.translate(cx, cy);
  ctx.scale(scaleX, 1);
  // Shadow
  ctx.shadowColor = 'rgba(0,0,0,0.15)';
  ctx.shadowBlur = 12;
  ctx.shadowOffsetY = 4;
  // Coin body
  ctx.beginPath();
  ctx.arc(0, 0, radius, 0, Math.PI*2);
  const isHeads = face === 'Heads';
  const grad = ctx.createRadialGradient(-radius*0.3, -radius*0.3, radius*0.1, 0, 0, radius);
  if (isHeads) {
    grad.addColorStop(0, '#ffd700');
    grad.addColorStop(1, '#daa520');
  } else {
    grad.addColorStop(0, '#c0c0c0');
    grad.addColorStop(1, '#909090');
  }
  ctx.fillStyle = grad;
  ctx.fill();
  ctx.strokeStyle = isHeads ? '#b8860b' : '#707070';
  ctx.lineWidth = 3;
  ctx.stroke();
  ctx.shadowColor = 'transparent';
  // Inner ring
  ctx.beginPath();
  ctx.arc(0, 0, radius*0.85, 0, Math.PI*2);
  ctx.strokeStyle = isHeads ? 'rgba(184,134,11,0.3)' : 'rgba(112,112,112,0.3)';
  ctx.lineWidth = 1.5;
  ctx.stroke();
  // Text
  ctx.fillStyle = isHeads ? '#8B6914' : '#505050';
  ctx.font = `bold ${radius*0.38}px Segoe UI, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(isHeads ? 'H' : 'T', 0, 0);
  ctx.restore();
}

// ---- Card Drawing ----
function drawCard(ctx, x, y, w, h, suitName, rotation) {
  ctx.save();
  ctx.translate(x + w/2, y + h/2);
  ctx.rotate(rotation);
  // Shadow
  ctx.shadowColor = 'rgba(0,0,0,0.12)';
  ctx.shadowBlur = 10;
  ctx.shadowOffsetY = 3;
  roundRect(ctx, -w/2, -h/2, w, h, 8);
  ctx.fillStyle = '#fff';
  ctx.fill();
  ctx.strokeStyle = '#ccc';
  ctx.lineWidth = 1.5;
  ctx.stroke();
  ctx.shadowColor = 'transparent';
  // Suit symbol
  const symbol = SUIT_SYMBOLS[suitName] || suitName;
  const colour = SUIT_COLOURS_MAP[suitName] || '#333';
  ctx.fillStyle = colour;
  ctx.font = `bold ${h*0.35}px Segoe UI, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(symbol, 0, 0);
  // Label
  ctx.font = `600 ${h*0.12}px Segoe UI, sans-serif`;
  ctx.fillText(suitName, 0, h*0.32);
  ctx.restore();
}

// ---- Spinner Drawing ----
function drawSpinner(ctx, cx, cy, radius, angle, resultIdx) {
  const total = spinnerSegments.reduce((s, seg) => s + seg.weight, 0);
  let startAngle = angle;
  spinnerSegments.forEach((seg, i) => {
    const sliceAngle = (seg.weight / total) * Math.PI * 2;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, radius, startAngle, startAngle + sliceAngle);
    ctx.closePath();
    ctx.fillStyle = seg.colour;
    if (resultIdx === i) {
      ctx.fillStyle = seg.colour;
      ctx.shadowColor = seg.colour;
      ctx.shadowBlur = 15;
    }
    ctx.fill();
    ctx.shadowColor = 'transparent';
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();
    // Label
    const midAngle = startAngle + sliceAngle / 2;
    const lx = cx + Math.cos(midAngle) * radius * 0.6;
    const ly = cy + Math.sin(midAngle) * radius * 0.6;
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.max(10, radius*0.14)}px Segoe UI, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.save();
    ctx.translate(lx, ly);
    ctx.fillText(seg.label, 0, 0);
    ctx.restore();
    startAngle += sliceAngle;
  });
  // Centre dot
  ctx.beginPath();
  ctx.arc(cx, cy, 6, 0, Math.PI*2);
  ctx.fillStyle = '#fff';
  ctx.fill();
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 2;
  ctx.stroke();
  // Pointer at top
  ctx.beginPath();
  ctx.moveTo(cx, cy - radius - 14);
  ctx.lineTo(cx - 10, cy - radius - 28);
  ctx.lineTo(cx + 10, cy - radius - 28);
  ctx.closePath();
  ctx.fillStyle = '#e74c3c';
  ctx.fill();
}

// ============================================================
//  ANIMATE SINGLE RESULT
// ============================================================
function animateDie(result, diceMode) {
  return new Promise(resolve => {
    resizeAnimCanvas();
    const w = animW / window.devicePixelRatio;
    const h = animH / window.devicePixelRatio;
    const dieSize = Math.min(70, h * 0.45);
    let frame = 0;
    const totalFrames = 20;
    const values = diceMode === '2d6' ? [parseInt(result) - Math.floor(Math.random()*5)-1, 0] : [parseInt(result)];
    if (diceMode === '2d6') {
      let d1 = Math.floor(Math.random()*6)+1;
      let d2 = parseInt(result) - d1;
      if (d2 < 1 || d2 > 6) { d1 = Math.min(6, Math.max(1, Math.floor(parseInt(result)/2))); d2 = parseInt(result) - d1; }
      if (d2 < 1) d2 = 1; if (d2 > 6) d2 = 6;
      values[0] = d1; values[1] = d2;
    }
    function step() {
      animCtx.clearRect(0, 0, w, h);
      const progress = frame / totalFrames;
      const eased = 1 - Math.pow(1 - progress, 3);
      if (diceMode === '1d6') {
        const showVal = frame < totalFrames ? Math.floor(Math.random()*6)+1 : values[0];
        const rot = (1 - eased) * Math.PI * 3;
        const bounce = Math.sin(progress * Math.PI) * 15;
        drawDie(animCtx, w/2 - dieSize/2, h/2 - dieSize/2 - bounce, dieSize, showVal, rot);
        if (frame >= totalFrames) {
          animCtx.fillStyle = '#4361ee';
          animCtx.font = 'bold 18px Segoe UI, sans-serif';
          animCtx.textAlign = 'center';
          animCtx.fillText('Result: ' + result, w/2, h/2 + dieSize/2 + 28);
        }
      } else {
        const showV1 = frame < totalFrames ? Math.floor(Math.random()*6)+1 : values[0];
        const showV2 = frame < totalFrames ? Math.floor(Math.random()*6)+1 : values[1];
        const rot = (1 - eased) * Math.PI * 3;
        const bounce = Math.sin(progress * Math.PI) * 12;
        const gap = dieSize * 0.6;
        drawDie(animCtx, w/2 - dieSize - gap/2, h/2 - dieSize/2 - bounce, dieSize, showV1, rot);
        drawDie(animCtx, w/2 + gap/2, h/2 - dieSize/2 - bounce, dieSize, showV2, -rot);
        if (frame >= totalFrames) {
          animCtx.fillStyle = '#4361ee';
          animCtx.font = 'bold 18px Segoe UI, sans-serif';
          animCtx.textAlign = 'center';
          animCtx.fillText(values[0] + ' + ' + values[1] + ' = ' + result, w/2, h/2 + dieSize/2 + 28);
        }
      }
      frame++;
      if (frame <= totalFrames) requestAnimationFrame(step);
      else setTimeout(resolve, 200);
    }
    step();
  });
}

function animateCoin(result) {
  return new Promise(resolve => {
    resizeAnimCanvas();
    const w = animW / window.devicePixelRatio;
    const h = animH / window.devicePixelRatio;
    const radius = Math.min(50, h*0.3);
    let frame = 0;
    const totalFrames = 30;
    function step() {
      animCtx.clearRect(0, 0, w, h);
      const progress = frame / totalFrames;
      const flipPhase = Math.cos(progress * Math.PI * 6) ; // flips 3 times
      const scaleX = frame < totalFrames ? Math.abs(flipPhase) * 0.7 + 0.3 : 1;
      const showFace = frame < totalFrames ? (flipPhase > 0 ? 'Heads' : 'Tails') : result;
      const bounceY = Math.sin(progress * Math.PI) * 40;
      drawCoin(animCtx, w/2, h/2 - bounceY - 10, radius, showFace, scaleX);
      if (frame >= totalFrames) {
        animCtx.fillStyle = result === 'Heads' ? '#b8860b' : '#707070';
        animCtx.font = 'bold 18px Segoe UI, sans-serif';
        animCtx.textAlign = 'center';
        animCtx.fillText('Result: ' + result, w/2, h/2 + radius + 30);
      }
      frame++;
      if (frame <= totalFrames) requestAnimationFrame(step);
      else setTimeout(resolve, 200);
    }
    step();
  });
}

function animateCard(result) {
  return new Promise(resolve => {
    resizeAnimCanvas();
    const w = animW / window.devicePixelRatio;
    const h = animH / window.devicePixelRatio;
    const cardH = Math.min(120, h * 0.7);
    const cardW = cardH * 0.68;
    let frame = 0;
    const totalFrames = 20;
    // Determine which suit/card to show
    let suitToShow = result;
    const mode = document.querySelector('input[name="cardMode"]:checked').value;
    if (mode === 'face') {
      if (result === 'Ace') suitToShow = SUITS[Math.floor(Math.random()*4)];
      else suitToShow = SUITS[Math.floor(Math.random()*4)];
    }
    if (mode === 'colour') {
      suitToShow = result === 'Red' ? (Math.random()<0.5?'Hearts':'Diamonds') : (Math.random()<0.5?'Clubs':'Spades');
    }
    function step() {
      animCtx.clearRect(0, 0, w, h);
      const progress = frame / totalFrames;
      const eased = 1 - Math.pow(1 - progress, 3);
      // Card appears from below, flips
      const yOff = (1 - eased) * h * 0.6;
      const rot = (1 - eased) * 0.5;
      const showing = frame >= totalFrames * 0.5;
      const cx = w/2 - cardW/2;
      const cy = h/2 - cardH/2 + yOff - 10;
      if (!showing) {
        // Back of card
        animCtx.save();
        animCtx.translate(cx + cardW/2, cy + cardH/2);
        animCtx.rotate(rot);
        roundRect(animCtx, -cardW/2, -cardH/2, cardW, cardH, 8);
        animCtx.fillStyle = '#2c3e80';
        animCtx.fill();
        // Pattern on back
        animCtx.strokeStyle = 'rgba(255,255,255,0.15)';
        animCtx.lineWidth = 1;
        for (let i = -cardW; i < cardW; i += 8) {
          animCtx.beginPath();
          animCtx.moveTo(i, -cardH/2);
          animCtx.lineTo(i + cardH, cardH/2);
          animCtx.stroke();
        }
        animCtx.restore();
      } else {
        drawCard(animCtx, cx, cy, cardW, cardH, suitToShow, rot * 0.2);
      }
      if (frame >= totalFrames) {
        animCtx.fillStyle = SUIT_COLOURS_MAP[suitToShow] || '#333';
        animCtx.font = 'bold 16px Segoe UI, sans-serif';
        animCtx.textAlign = 'center';
        animCtx.fillText('Result: ' + result, w/2, h/2 + cardH/2 + 24);
      }
      frame++;
      if (frame <= totalFrames) requestAnimationFrame(step);
      else setTimeout(resolve, 200);
    }
    step();
  });
}

function animateSpinner(result) {
  return new Promise(resolve => {
    resizeAnimCanvas();
    const w = animW / window.devicePixelRatio;
    const h = animH / window.devicePixelRatio;
    const radius = Math.min(70, h*0.38);
    const cx = w/2, cy = h/2 + 8;
    let frame = 0;
    const totalFrames = 60;
    // Calculate target angle so that the result segment is at the top (pointer)
    const totalW = spinnerSegments.reduce((s, seg) => s + seg.weight, 0);
    let targetSegIdx = spinnerSegments.findIndex(s => s.label === result);
    if (targetSegIdx < 0) targetSegIdx = 0;
    // Calculate the angle range for the target segment
    let cumAngle = 0;
    for (let i = 0; i < targetSegIdx; i++) cumAngle += (spinnerSegments[i].weight / totalW) * Math.PI * 2;
    const segAngle = (spinnerSegments[targetSegIdx].weight / totalW) * Math.PI * 2;
    const targetMid = cumAngle + segAngle / 2;
    // Pointer is at -PI/2 (top). Spinner rotates, so we need:
    // startAngle + offset = such that targetMid + offset is at -PI/2
    // So offset = -PI/2 - targetMid
    // We add extra full rotations for drama
    const targetOffset = -Math.PI/2 - targetMid + Math.PI * 8; // 4 extra spins
    function step() {
      animCtx.clearRect(0, 0, w, h);
      const progress = frame / totalFrames;
      const eased = 1 - Math.pow(1 - progress, 4); // quartic ease out
      const currentAngle = eased * targetOffset;
      const highlightIdx = frame >= totalFrames ? targetSegIdx : -1;
      drawSpinner(animCtx, cx, cy, radius, currentAngle, highlightIdx);
      if (frame >= totalFrames) {
        animCtx.fillStyle = spinnerSegments[targetSegIdx].colour;
        animCtx.font = 'bold 16px Segoe UI, sans-serif';
        animCtx.textAlign = 'center';
        animCtx.fillText('Result: ' + result, cx, cy + radius + 28);
      }
      frame++;
      if (frame <= totalFrames) requestAnimationFrame(step);
      else setTimeout(resolve, 300);
    }
    step();
  });
}

// ============================================================
//  BATCH ANIMATION (for large trials - show rapid results)
// ============================================================
function showBatchAnimation(results) {
  resizeAnimCanvas();
  const w = animW / window.devicePixelRatio;
  const h = animH / window.devicePixelRatio;
  animCtx.clearRect(0, 0, w, h);
  // Show a burst of results flying by
  const displayCount = Math.min(results.length, 30);
  const cols = Math.ceil(Math.sqrt(displayCount));
  const rows = Math.ceil(displayCount / cols);
  const cellW = w / cols;
  const cellH = h / rows;
  for (let i = 0; i < displayCount; i++) {
    const col = i % cols;
    const row = Math.floor(i / cols);
    const cx = col * cellW + cellW/2;
    const cy = row * cellH + cellH/2;
    const result = results[i];
    animCtx.fillStyle = CHART_COLOURS[outcomes.indexOf(result) % CHART_COLOURS.length];
    animCtx.globalAlpha = 0.6 + Math.random() * 0.4;
    animCtx.font = `bold ${Math.max(10, Math.min(cellW*0.5, cellH*0.5, 20))}px Segoe UI, sans-serif`;
    animCtx.textAlign = 'center';
    animCtx.textBaseline = 'middle';
    animCtx.fillText(result, cx, cy);
  }
  animCtx.globalAlpha = 1;
  // Overlay summary text
  animCtx.fillStyle = 'rgba(255,255,255,0.8)';
  roundRect(animCtx, w/2 - 120, h - 36, 240, 30, 8);
  animCtx.fill();
  animCtx.fillStyle = '#4361ee';
  animCtx.font = 'bold 14px Segoe UI, sans-serif';
  animCtx.textAlign = 'center';
  animCtx.fillText(results.length.toLocaleString() + ' trials completed', w/2, h - 18);
}

// ============================================================
//  RUN EXPERIMENT
// ============================================================
async function runExperiment() {
  if (isRunning) return;
  isRunning = true;
  document.getElementById('runBtn').classList.add('running');
  document.getElementById('runBtn').innerHTML = '&#9208; Running...';
  document.getElementById('animLabel').textContent = 'Running...';

  const config = getExperimentConfig();
  if (totalTrials === 0) {
    // Initialise
    outcomes = config.outcomes;
    theoreticalProbs = config.probs;
    if (!chart || JSON.stringify(chart.data.labels) !== JSON.stringify(outcomes)) initChart();
  }

  const speed = document.getElementById('speedSelect').value;
  const n = trialCount;
  const shouldAnimate = (n <= 10) && (speed !== 'instant');
  const results = [];

  if (shouldAnimate) {
    for (let i = 0; i < n; i++) {
      const result = config.sample();
      results.push(result);
      frequencies[result] = (frequencies[result] || 0) + 1;
      totalTrials++;
      // Animate
      if (currentExperiment === 'dice') {
        const diceMode = document.querySelector('input[name="diceMode"]:checked').value;
        await animateDie(result, diceMode);
      } else if (currentExperiment === 'coin') {
        await animateCoin(result);
      } else if (currentExperiment === 'card') {
        await animateCard(result);
      } else if (currentExperiment === 'spinner') {
        await animateSpinner(result);
      }
      updateChart();
      updateFreqTable();
      updateSummary();
      if (speed === 'slow') await sleep(500);
      else if (speed === 'normal') await sleep(100);
      else await sleep(30);
    }
  } else {
    // Batch mode - run all at once with progressive updates
    const batchSize = speed === 'instant' ? n : (speed === 'fast' ? Math.max(1, Math.floor(n/20)) : Math.max(1, Math.floor(n/50)));
    let done = 0;
    while (done < n) {
      const thisBatch = Math.min(batchSize, n - done);
      const batchResults = [];
      for (let i = 0; i < thisBatch; i++) {
        const result = config.sample();
        results.push(result);
        batchResults.push(result);
        frequencies[result] = (frequencies[result] || 0) + 1;
        totalTrials++;
      }
      done += thisBatch;
      updateChart();
      updateFreqTable();
      updateSummary();
      if (speed !== 'instant') {
        await sleep(speed === 'fast' ? 15 : 40);
      }
    }
    showBatchAnimation(results);
  }

  document.getElementById('animLabel').textContent = 'Complete - ' + totalTrials.toLocaleString() + ' total trials';
  document.getElementById('runBtn').classList.remove('running');
  document.getElementById('runBtn').innerHTML = '&#9654; RUN';
  isRunning = false;
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// ============================================================
//  RESET
// ============================================================
function resetAll() {
  isRunning = false;
  totalTrials = 0;
  frequencies = {};
  outcomes = [];
  theoreticalProbs = {};
  initChart();
  updateFreqTable();
  updateSummary();
  clearAnim();
  document.getElementById('animLabel').textContent = 'Ready';
  document.getElementById('runBtn').classList.remove('running');
  document.getElementById('runBtn').innerHTML = '&#9654; RUN';
}

// ============================================================
//  INIT
// ============================================================
window.addEventListener('DOMContentLoaded', () => {
  setTrials(10);
  resetAll();
});
window.addEventListener('load', () => {
  resizeAnimCanvas();
  clearAnim();
});
</script>
</body>
</html>
