<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Geometric Transformations Explorer</title>
<style>
  :root {
    --blue-dark:    #1a3a5c;
    --blue-mid:     #2563a8;
    --blue-light:   #4a90d9;
    --blue-pale:    #dbeafe;
    --blue-faint:   #eff6ff;
    --accent:       #f59e0b;
    --accent-light: #fef3c7;
    --green:        #16a34a;
    --red:          #dc2626;
    --purple:       #7c3aed;
    --grey-dark:    #1f2937;
    --grey-mid:     #6b7280;
    --grey-light:   #e5e7eb;
    --grey-faint:   #f9fafb;
    --white:        #ffffff;
    --shadow:       0 2px 8px rgba(0,0,0,0.12);
    --shadow-lg:    0 4px 20px rgba(0,0,0,0.15);
    --radius:       8px;
    --radius-lg:    12px;
    --font:         'Segoe UI', Arial, sans-serif;
  }

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: var(--font);
    background: var(--grey-faint);
    color: var(--grey-dark);
    min-height: 100vh;
  }

  /* HEADER */
  header {
    position: sticky;
    top: 0;
    z-index: 100;
    background: var(--blue-dark);
    color: var(--white);
    padding: 0 1.5rem;
    box-shadow: var(--shadow-lg);
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
    height: 56px;
  }
  header h1 {
    font-size: 1.2rem;
    font-weight: 700;
    letter-spacing: -0.01em;
    white-space: nowrap;
  }
  header h1 span { color: var(--accent); }
  .header-tabs {
    display: flex;
    gap: 4px;
  }
  .header-tab {
    background: transparent;
    border: 1px solid rgba(255,255,255,0.25);
    color: rgba(255,255,255,0.8);
    padding: 5px 14px;
    border-radius: 20px;
    cursor: pointer;
    font-size: 0.82rem;
    font-family: var(--font);
    transition: all 0.2s;
  }
  .header-tab.active, .header-tab:hover {
    background: var(--blue-mid);
    border-color: var(--blue-light);
    color: var(--white);
  }

  /* LAYOUT */
  .app-layout {
    display: grid;
    grid-template-columns: 280px 1fr 260px;
    grid-template-rows: 1fr;
    gap: 0;
    height: calc(100vh - 56px);
    overflow: hidden;
  }

  /* PANELS */
  .panel {
    background: var(--white);
    overflow-y: auto;
    border-right: 1px solid var(--grey-light);
  }
  .panel:last-child { border-right: none; border-left: 1px solid var(--grey-light); }
  .panel-section {
    padding: 1rem;
    border-bottom: 1px solid var(--grey-light);
  }
  .panel-section:last-child { border-bottom: none; }
  .panel-title {
    font-size: 0.7rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--grey-mid);
    margin-bottom: 0.6rem;
  }

  /* CANVAS AREA */
  .canvas-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: var(--grey-faint);
    padding: 1rem;
    position: relative;
    overflow: hidden;
  }
  #mainCanvas {
    border: 2px solid var(--blue-light);
    border-radius: var(--radius);
    background: var(--white);
    cursor: crosshair;
    box-shadow: var(--shadow);
    display: block;
    max-width: 100%;
  }
  .canvas-controls {
    display: flex;
    gap: 0.5rem;
    margin-top: 0.75rem;
    flex-wrap: wrap;
    justify-content: center;
  }

  /* BUTTONS */
  .btn {
    display: inline-flex;
    align-items: center;
    gap: 5px;
    padding: 7px 14px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    font-family: var(--font);
    font-size: 0.82rem;
    font-weight: 600;
    transition: all 0.18s;
    white-space: nowrap;
  }
  .btn-primary {
    background: var(--blue-mid);
    color: var(--white);
  }
  .btn-primary:hover { background: var(--blue-dark); }
  .btn-secondary {
    background: var(--grey-light);
    color: var(--grey-dark);
  }
  .btn-secondary:hover { background: #d1d5db; }
  .btn-success {
    background: var(--green);
    color: var(--white);
  }
  .btn-success:hover { background: #15803d; }
  .btn-accent {
    background: var(--accent);
    color: var(--grey-dark);
  }
  .btn-accent:hover { background: #d97706; }
  .btn-danger {
    background: var(--red);
    color: var(--white);
  }
  .btn-danger:hover { background: #b91c1c; }
  .btn-sm { padding: 5px 10px; font-size: 0.78rem; }
  .btn-full { width: 100%; justify-content: center; }

  /* SHAPE PRESETS */
  .shape-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 5px;
  }
  .shape-btn {
    background: var(--blue-faint);
    border: 2px solid var(--blue-pale);
    color: var(--blue-dark);
    padding: 8px 6px;
    border-radius: var(--radius);
    cursor: pointer;
    font-family: var(--font);
    font-size: 0.78rem;
    font-weight: 600;
    text-align: center;
    transition: all 0.18s;
  }
  .shape-btn:hover, .shape-btn.active {
    background: var(--blue-mid);
    border-color: var(--blue-mid);
    color: var(--white);
  }

  /* TRANSFORMATION TYPE */
  .transform-tabs {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 4px;
  }
  .transform-tab {
    padding: 7px 4px;
    border-radius: var(--radius);
    border: 2px solid var(--grey-light);
    background: var(--white);
    color: var(--grey-dark);
    cursor: pointer;
    font-family: var(--font);
    font-size: 0.75rem;
    font-weight: 600;
    text-align: center;
    transition: all 0.18s;
  }
  .transform-tab.active {
    border-color: var(--blue-mid);
    background: var(--blue-faint);
    color: var(--blue-dark);
  }
  .transform-tab:hover:not(.active) { border-color: var(--blue-light); }

  /* CONTROLS */
  .control-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 0.55rem;
  }
  .control-label {
    font-size: 0.78rem;
    font-weight: 600;
    color: var(--grey-dark);
    min-width: 70px;
    flex-shrink: 0;
  }
  .control-label small {
    display: block;
    font-size: 0.68rem;
    font-weight: 400;
    color: var(--grey-mid);
  }
  input[type="range"] {
    flex: 1;
    accent-color: var(--blue-mid);
    height: 4px;
  }
  input[type="number"] {
    width: 60px;
    padding: 4px 6px;
    border: 1px solid var(--grey-light);
    border-radius: 4px;
    font-family: var(--font);
    font-size: 0.82rem;
    text-align: center;
    color: var(--grey-dark);
  }
  input[type="number"]:focus {
    outline: none;
    border-color: var(--blue-mid);
  }
  select {
    width: 100%;
    padding: 6px 8px;
    border: 1px solid var(--grey-light);
    border-radius: var(--radius);
    font-family: var(--font);
    font-size: 0.82rem;
    color: var(--grey-dark);
    background: var(--white);
    cursor: pointer;
  }
  select:focus { outline: none; border-color: var(--blue-mid); }

  .value-badge {
    background: var(--blue-pale);
    color: var(--blue-dark);
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 0.78rem;
    font-weight: 700;
    min-width: 38px;
    text-align: center;
    flex-shrink: 0;
  }

  /* MATRIX DISPLAY */
  .matrix-container {
    background: var(--blue-faint);
    border: 1px solid var(--blue-pale);
    border-radius: var(--radius);
    padding: 0.75rem;
    text-align: center;
  }
  .matrix-label {
    font-size: 0.72rem;
    color: var(--grey-mid);
    font-weight: 600;
    margin-bottom: 0.4rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
  }
  .matrix-display {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    font-family: 'Courier New', monospace;
    font-size: 1rem;
  }
  .matrix-bracket {
    font-size: 2.2rem;
    color: var(--blue-dark);
    line-height: 1;
    font-weight: 100;
  }
  .matrix-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2px 12px;
    padding: 2px 6px;
  }
  .matrix-cell {
    font-weight: 700;
    color: var(--blue-dark);
    font-size: 1.05rem;
    text-align: center;
    min-width: 36px;
    transition: color 0.3s;
  }
  .matrix-cell.changed { color: var(--accent); }

  /* COORDINATES PANEL */
  .coord-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.8rem;
  }
  .coord-table th {
    background: var(--blue-faint);
    color: var(--blue-dark);
    font-weight: 700;
    padding: 5px 8px;
    text-align: center;
    border-bottom: 1px solid var(--blue-pale);
    font-size: 0.75rem;
  }
  .coord-table td {
    padding: 4px 8px;
    text-align: center;
    border-bottom: 1px solid var(--grey-light);
    font-family: 'Courier New', monospace;
  }
  .coord-table tr:last-child td { border-bottom: none; }
  .coord-orig { color: var(--blue-mid); font-weight: 700; }
  .coord-image { color: var(--green); font-weight: 700; }

  /* LEGEND */
  .legend {
    display: flex;
    flex-direction: column;
    gap: 5px;
  }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.78rem;
  }
  .legend-line {
    width: 28px;
    height: 3px;
    border-radius: 2px;
    flex-shrink: 0;
  }
  .legend-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  /* ANIMATION BUTTON */
  .animate-bar {
    display: flex;
    gap: 6px;
    align-items: center;
    flex-wrap: wrap;
  }
  .progress-track {
    flex: 1;
    height: 6px;
    background: var(--grey-light);
    border-radius: 3px;
    overflow: hidden;
    min-width: 60px;
  }
  .progress-fill {
    height: 100%;
    background: var(--blue-mid);
    border-radius: 3px;
    transition: width 0.05s linear;
    width: 0%;
  }

  /* INFO PANEL (tab 2) */
  #infoPanel {
    display: none;
    padding: 1.25rem 1.5rem;
    max-width: 820px;
    margin: 0 auto;
  }
  #infoPanel.active { display: block; }
  .app-layout.hidden { display: none; }

  .info-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
    margin-bottom: 1rem;
  }
  .info-card {
    background: var(--white);
    border: 1px solid var(--grey-light);
    border-radius: var(--radius-lg);
    padding: 1.1rem 1.2rem;
    box-shadow: var(--shadow);
  }
  .info-card h3 {
    font-size: 0.95rem;
    font-weight: 700;
    color: var(--blue-dark);
    margin-bottom: 0.5rem;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .info-card h3 .tag {
    font-size: 0.65rem;
    background: var(--blue-pale);
    color: var(--blue-mid);
    padding: 1px 7px;
    border-radius: 10px;
    font-weight: 700;
    letter-spacing: 0.06em;
    text-transform: uppercase;
  }
  .info-card p, .info-card li {
    font-size: 0.82rem;
    line-height: 1.65;
    color: #374151;
  }
  .info-card ul { padding-left: 1.1rem; }
  .info-card li { margin-bottom: 2px; }
  .info-formula {
    background: var(--blue-faint);
    border-left: 3px solid var(--blue-mid);
    padding: 6px 10px;
    border-radius: 0 4px 4px 0;
    margin-top: 0.5rem;
    font-family: 'Courier New', monospace;
    font-size: 0.82rem;
    color: var(--blue-dark);
    font-weight: 600;
  }
  .info-note {
    background: var(--accent-light);
    border: 1px solid #fcd34d;
    border-radius: var(--radius);
    padding: 0.7rem 0.9rem;
    font-size: 0.8rem;
    color: #92400e;
    margin-top: 0.75rem;
  }

  /* HINT BADGE */
  .hint {
    background: var(--accent-light);
    border: 1px solid #fde68a;
    border-radius: var(--radius);
    padding: 0.45rem 0.6rem;
    font-size: 0.73rem;
    color: #78350f;
    line-height: 1.4;
  }

  /* SCROLLBAR */
  ::-webkit-scrollbar { width: 5px; }
  ::-webkit-scrollbar-track { background: var(--grey-faint); }
  ::-webkit-scrollbar-thumb { background: var(--grey-light); border-radius: 3px; }
  ::-webkit-scrollbar-thumb:hover { background: var(--grey-mid); }

  /* RESPONSIVE */
  @media (max-width: 768px) {
    .app-layout {
      grid-template-columns: 1fr;
      grid-template-rows: auto 1fr auto;
      height: auto;
      overflow: visible;
    }
    .panel { max-height: 260px; border-right: none; border-bottom: 1px solid var(--grey-light); }
    .panel:last-child { border-left: none; border-top: 1px solid var(--grey-light); }
    .info-grid { grid-template-columns: 1fr; }
    header h1 { font-size: 0.95rem; }
  }
</style>
</head>
<body>

<header>
  <h1>Geometric <span>Transformations</span> Explorer</h1>
  <div class="header-tabs">
    <button class="header-tab active" onclick="switchTab('explorer')">Explorer</button>
    <button class="header-tab" onclick="switchTab('info')">GCSE Guide</button>
  </div>
</header>

<!-- INFO PANEL -->
<div id="infoPanel">
  <div style="max-width:820px;margin:0 auto;">
    <h2 style="font-size:1.3rem;color:var(--blue-dark);margin-bottom:1rem;padding-top:1rem;">GCSE Geometric Transformations</h2>
    <div class="info-grid">
      <div class="info-card">
        <h3>Translation <span class="tag">Vector</span></h3>
        <p>A translation moves every point of a shape the same distance in the same direction. No rotation or change in size occurs. The shape and its image are congruent.</p>
        <ul>
          <li>Described by a column vector: <strong>(x, y)</strong></li>
          <li>Positive x moves right; negative x moves left</li>
          <li>Positive y moves up; negative y moves down</li>
          <li>Object and image are congruent</li>
        </ul>
        <div class="info-formula">Image point: (x + a, y + b) for vector (a, b)</div>
      </div>
      <div class="info-card">
        <h3>Rotation <span class="tag">Angle + Centre</span></h3>
        <p>A rotation turns a shape through an angle about a fixed point called the centre of rotation. The shape and its image are congruent.</p>
        <ul>
          <li>Specify: angle, direction (CW/CCW), centre</li>
          <li>Positive angles: anticlockwise convention</li>
          <li>90° CW matrix: (x, y) &rarr; (y, -x)</li>
          <li>180° matrix: (x, y) &rarr; (-x, -y)</li>
        </ul>
        <div class="info-formula">x' = cx + (x-cx)cos&theta; - (y-cy)sin&theta;<br>y' = cy + (x-cx)sin&theta; + (y-cy)cos&theta;</div>
      </div>
      <div class="info-card">
        <h3>Reflection <span class="tag">Mirror Line</span></h3>
        <p>A reflection flips a shape in a mirror line. Every point on the image is the same distance from the mirror line as the corresponding point on the object, but on the opposite side.</p>
        <ul>
          <li>Common lines: y=0, x=0, y=x, y=-x</li>
          <li>Reflection in y=x: (x, y) &rarr; (y, x)</li>
          <li>Reflection in x-axis: (x, y) &rarr; (x, -y)</li>
          <li>Object and image are congruent</li>
        </ul>
        <div class="info-formula">Reflect in y=x: swap coordinates<br>Reflect in y=0: negate y-coordinate</div>
      </div>
      <div class="info-card">
        <h3>Enlargement <span class="tag">Scale Factor</span></h3>
        <p>An enlargement changes the size of a shape using a scale factor (SF) and a centre of enlargement. The shape and image are mathematically similar.</p>
        <ul>
          <li>SF &gt; 1: image is larger than object</li>
          <li>0 &lt; SF &lt; 1: image is smaller (reduction)</li>
          <li>SF &lt; 0: image is on opposite side of centre</li>
          <li>Distance from centre is multiplied by SF</li>
        </ul>
        <div class="info-formula">x' = cx + SF(x - cx)<br>y' = cy + SF(y - cy)</div>
        <div class="info-note">Note: enlargement does <strong>not</strong> preserve congruence (unless SF = &pm;1). Area is multiplied by SF&sup2;.</div>
      </div>
    </div>
    <div class="info-card" style="margin-bottom:1rem;">
      <h3>2&times;2 Transformation Matrices</h3>
      <p style="margin-bottom:0.5rem;">Many transformations about the origin can be represented as 2&times;2 matrices. The new coordinates are found by multiplying the matrix by the position vector of each point.</p>
      <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:0.75rem;margin-top:0.6rem;">
        <div style="text-align:center;background:var(--blue-faint);padding:0.6rem;border-radius:var(--radius);">
          <div style="font-size:0.7rem;font-weight:700;color:var(--grey-mid);margin-bottom:4px;">Rotation 90° CCW</div>
          <div style="font-family:monospace;font-size:0.9rem;color:var(--blue-dark);font-weight:700;">[ 0 -1 ]<br>[ 1  0 ]</div>
        </div>
        <div style="text-align:center;background:var(--blue-faint);padding:0.6rem;border-radius:var(--radius);">
          <div style="font-size:0.7rem;font-weight:700;color:var(--grey-mid);margin-bottom:4px;">Rotation 180°</div>
          <div style="font-family:monospace;font-size:0.9rem;color:var(--blue-dark);font-weight:700;">[-1  0 ]<br>[ 0 -1 ]</div>
        </div>
        <div style="text-align:center;background:var(--blue-faint);padding:0.6rem;border-radius:var(--radius);">
          <div style="font-size:0.7rem;font-weight:700;color:var(--grey-mid);margin-bottom:4px;">Reflect in y=x</div>
          <div style="font-family:monospace;font-size:0.9rem;color:var(--blue-dark);font-weight:700;">[ 0  1 ]<br>[ 1  0 ]</div>
        </div>
        <div style="text-align:center;background:var(--blue-faint);padding:0.6rem;border-radius:var(--radius);">
          <div style="font-size:0.7rem;font-weight:700;color:var(--grey-mid);margin-bottom:4px;">Reflect in x-axis</div>
          <div style="font-family:monospace;font-size:0.9rem;color:var(--blue-dark);font-weight:700;">[ 1  0 ]<br>[ 0 -1 ]</div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- MAIN EXPLORER LAYOUT -->
<div class="app-layout" id="explorerLayout">

  <!-- LEFT PANEL: Shape + Transform controls -->
  <div class="panel">

    <!-- Shape Presets -->
    <div class="panel-section">
      <div class="panel-title">Preset Shapes</div>
      <div class="shape-grid">
        <button class="shape-btn active" onclick="loadPreset('triangle')" id="btn-triangle">Triangle</button>
        <button class="shape-btn" onclick="loadPreset('square')" id="btn-square">Square</button>
        <button class="shape-btn" onclick="loadPreset('lshape')" id="btn-lshape">L-Shape</button>
        <button class="shape-btn" onclick="loadPreset('pentagon')" id="btn-pentagon">Pentagon</button>
      </div>
      <div style="margin-top:0.5rem;" class="hint">Drag the blue vertices on the grid to reshape.</div>
    </div>

    <!-- Transformation Type -->
    <div class="panel-section">
      <div class="panel-title">Transformation Type</div>
      <div class="transform-tabs">
        <button class="transform-tab active" onclick="setTransformType('translation')" id="tab-translation">Translation</button>
        <button class="transform-tab" onclick="setTransformType('rotation')" id="tab-rotation">Rotation</button>
        <button class="transform-tab" onclick="setTransformType('reflection')" id="tab-reflection">Reflection</button>
        <button class="transform-tab" onclick="setTransformType('enlargement')" id="tab-enlargement">Enlargement</button>
      </div>
    </div>

    <!-- Translation Controls -->
    <div class="panel-section" id="ctrl-translation">
      <div class="panel-title">Translation Vector</div>
      <div class="control-row">
        <div class="control-label">x <small>(right +)</small></div>
        <input type="range" min="-8" max="8" step="1" value="3" id="tx-slider" oninput="syncInput('tx')">
        <span class="value-badge" id="tx-val">3</span>
        <input type="number" min="-8" max="8" value="3" id="tx-num" oninput="syncSlider('tx')">
      </div>
      <div class="control-row">
        <div class="control-label">y <small>(up +)</small></div>
        <input type="range" min="-8" max="8" step="1" value="2" id="ty-slider" oninput="syncInput('ty')">
        <span class="value-badge" id="ty-val">2</span>
        <input type="number" min="-8" max="8" value="2" id="ty-num" oninput="syncSlider('ty')">
      </div>
    </div>

    <!-- Rotation Controls -->
    <div class="panel-section" id="ctrl-rotation" style="display:none;">
      <div class="panel-title">Rotation</div>
      <div class="control-row">
        <div class="control-label">Angle</div>
        <input type="range" min="-180" max="180" step="5" value="90" id="angle-slider" oninput="syncInput('angle')">
        <span class="value-badge" id="angle-val">90°</span>
        <input type="number" min="-180" max="180" value="90" id="angle-num" oninput="syncSlider('angle')">
      </div>
      <div class="control-row">
        <div class="control-label">Direction</div>
        <select id="rot-dir" onchange="redrawAll()">
          <option value="ccw">Anticlockwise</option>
          <option value="cw">Clockwise</option>
        </select>
      </div>
      <div class="control-row">
        <div class="control-label">Centre x</div>
        <input type="range" min="-8" max="8" step="1" value="0" id="cx-slider" oninput="syncInput('cx')">
        <span class="value-badge" id="cx-val">0</span>
        <input type="number" min="-8" max="8" value="0" id="cx-num" oninput="syncSlider('cx')">
      </div>
      <div class="control-row">
        <div class="control-label">Centre y</div>
        <input type="range" min="-8" max="8" step="1" value="0" id="cy-slider" oninput="syncInput('cy')">
        <span class="value-badge" id="cy-val">0</span>
        <input type="number" min="-8" max="8" value="0" id="cy-num" oninput="syncSlider('cy')">
      </div>
    </div>

    <!-- Reflection Controls -->
    <div class="panel-section" id="ctrl-reflection" style="display:none;">
      <div class="panel-title">Line of Reflection</div>
      <div class="control-row" style="flex-direction:column;align-items:flex-start;gap:4px;">
        <div class="control-label">Mirror Line</div>
        <select id="ref-line" onchange="updateReflectionCustom()">
          <option value="x-axis">x-axis (y = 0)</option>
          <option value="y-axis">y-axis (x = 0)</option>
          <option value="y=x">y = x</option>
          <option value="y=-x">y = -x</option>
          <option value="custom">Custom: y = mx + c</option>
        </select>
      </div>
      <div id="custom-ref-controls" style="display:none;margin-top:0.4rem;">
        <div class="control-row">
          <div class="control-label">Gradient m</div>
          <input type="range" min="-4" max="4" step="0.5" value="1" id="ref-m-slider" oninput="syncInput('ref-m')">
          <span class="value-badge" id="ref-m-val">1</span>
          <input type="number" step="0.5" value="1" id="ref-m-num" oninput="syncSlider('ref-m')">
        </div>
        <div class="control-row">
          <div class="control-label">Intercept c</div>
          <input type="range" min="-6" max="6" step="1" value="0" id="ref-c-slider" oninput="syncInput('ref-c')">
          <span class="value-badge" id="ref-c-val">0</span>
          <input type="number" value="0" id="ref-c-num" oninput="syncSlider('ref-c')">
        </div>
      </div>
    </div>

    <!-- Enlargement Controls -->
    <div class="panel-section" id="ctrl-enlargement" style="display:none;">
      <div class="panel-title">Enlargement</div>
      <div class="control-row">
        <div class="control-label">Scale Factor</div>
        <input type="range" min="-3" max="4" step="0.5" value="2" id="sf-slider" oninput="syncInput('sf')">
        <span class="value-badge" id="sf-val">2</span>
        <input type="number" step="0.5" value="2" id="sf-num" oninput="syncSlider('sf')">
      </div>
      <div class="control-row">
        <div class="control-label">Centre x</div>
        <input type="range" min="-8" max="8" step="1" value="0" id="ecx-slider" oninput="syncInput('ecx')">
        <span class="value-badge" id="ecx-val">0</span>
        <input type="number" min="-8" max="8" value="0" id="ecx-num" oninput="syncSlider('ecx')">
      </div>
      <div class="control-row">
        <div class="control-label">Centre y</div>
        <input type="range" min="-8" max="8" step="1" value="0" id="ecy-slider" oninput="syncInput('ecy')">
        <span class="value-badge" id="ecy-val">0</span>
        <input type="number" min="-8" max="8" value="0" id="ecy-num" oninput="syncSlider('ecy')">
      </div>
    </div>

  </div>

  <!-- CENTRE: Canvas -->
  <div class="canvas-area">
    <canvas id="mainCanvas" width="560" height="560"></canvas>
    <div class="canvas-controls">
      <button class="btn btn-success" onclick="animateTransform()">Animate</button>
      <div class="animate-bar">
        <div class="progress-track"><div class="progress-fill" id="animProgress"></div></div>
      </div>
      <button class="btn btn-secondary btn-sm" onclick="resetShape()">Reset Shape</button>
      <button class="btn btn-secondary btn-sm" onclick="toggleGrid()">Toggle Labels</button>
    </div>
  </div>

  <!-- RIGHT PANEL: Matrix + Coordinates -->
  <div class="panel">

    <!-- Matrix -->
    <div class="panel-section">
      <div class="panel-title">Transformation Matrix</div>
      <div class="matrix-container">
        <div class="matrix-label" id="matrix-label">About the origin</div>
        <div class="matrix-display">
          <span class="matrix-bracket">[</span>
          <div class="matrix-grid">
            <div class="matrix-cell" id="m00">1</div>
            <div class="matrix-cell" id="m01">0</div>
            <div class="matrix-cell" id="m10">0</div>
            <div class="matrix-cell" id="m11">1</div>
          </div>
          <span class="matrix-bracket">]</span>
        </div>
        <div id="matrix-note" style="font-size:0.7rem;color:var(--grey-mid);margin-top:0.4rem;"></div>
      </div>
    </div>

    <!-- Legend -->
    <div class="panel-section">
      <div class="panel-title">Legend</div>
      <div class="legend">
        <div class="legend-item">
          <div class="legend-line" style="background:var(--blue-mid);"></div>
          <span>Original shape (object)</span>
        </div>
        <div class="legend-item">
          <div class="legend-line" style="background:var(--green);"></div>
          <span>Image (after transformation)</span>
        </div>
        <div class="legend-item">
          <div class="legend-line" style="background:var(--red);border-top:2px dashed var(--red);height:0;"></div>
          <span>Mirror / construction line</span>
        </div>
        <div class="legend-item">
          <div class="legend-dot" style="background:var(--blue-mid);border:2px solid var(--blue-dark);"></div>
          <span>Draggable vertex</span>
        </div>
        <div class="legend-item">
          <div class="legend-dot" style="background:var(--accent);border:2px solid #d97706;"></div>
          <span>Centre of transformation</span>
        </div>
      </div>
    </div>

    <!-- Coordinates -->
    <div class="panel-section">
      <div class="panel-title">Coordinates</div>
      <table class="coord-table">
        <thead>
          <tr>
            <th>Vertex</th>
            <th class="coord-orig">Object</th>
            <th class="coord-image">Image</th>
          </tr>
        </thead>
        <tbody id="coordTableBody">
        </tbody>
      </table>
    </div>

    <!-- Description output -->
    <div class="panel-section">
      <div class="panel-title">Transformation Description</div>
      <div id="descriptionBox" style="font-size:0.8rem;line-height:1.6;color:var(--grey-dark);background:var(--grey-faint);border-radius:var(--radius);padding:0.6rem 0.75rem;border:1px solid var(--grey-light);">
        Select a transformation and adjust the controls.
      </div>
    </div>

  </div>

</div>

<script>
// ==================== STATE ====================
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');

const GRID_SIZE = 16;       // number of cells each side
const CELL = canvas.width / GRID_SIZE;  // pixels per grid unit
const ORIGIN = { x: canvas.width / 2, y: canvas.height / 2 };

let transformType = 'translation';
let showLabels = true;
let animFrame = null;
let currentPreset = 'triangle';

// Shape vertices in grid coords
let shapeVerts = [];
// Dragging state
let dragging = null;
let lastPrevMatrix = null;

// ==================== PRESETS ====================
const PRESETS = {
  triangle: [ {x:1,y:4}, {x:5,y:4}, {x:1,y:7} ],
  square:   [ {x:1,y:3}, {x:4,y:3}, {x:4,y:6}, {x:1,y:6} ],
  lshape:   [ {x:1,y:2}, {x:3,y:2}, {x:3,y:4}, {x:5,y:4}, {x:5,y:5}, {x:1,y:5} ],
  pentagon: (function(){
    const pts = [];
    for(let i=0;i<5;i++){
      const a = (Math.PI*2*i/5) - Math.PI/2;
      pts.push({x: Math.round(3*Math.cos(a)*2)/2, y: Math.round(3*Math.sin(a)*2)/2});
    }
    return pts.map(p=>({x: p.x+2, y: p.y+4}));
  })()
};

function loadPreset(name) {
  currentPreset = name;
  shapeVerts = PRESETS[name].map(p=>({...p}));
  document.querySelectorAll('.shape-btn').forEach(b=>b.classList.remove('active'));
  const btn = document.getElementById('btn-'+name);
  if(btn) btn.classList.add('active');
  redrawAll();
}

// ==================== COORDINATE CONVERSIONS ====================
function toCanvas(gx, gy) {
  return { x: ORIGIN.x + gx * CELL, y: ORIGIN.y - gy * CELL };
}
function toGrid(cx, cy) {
  return { x: (cx - ORIGIN.x) / CELL, y: -(cy - ORIGIN.y) / CELL };
}
function snapGrid(v) {
  return { x: Math.round(v.x), y: Math.round(v.y) };
}

// ==================== TRANSFORMATIONS ====================
function applyTranslation(pt, tx, ty) {
  return { x: pt.x + tx, y: pt.y + ty };
}

function applyRotation(pt, angle, cx, cy) {
  const dir = document.getElementById('rot-dir').value;
  let rad = angle * Math.PI / 180;
  if(dir === 'cw') rad = -rad;
  const dx = pt.x - cx, dy = pt.y - cy;
  return {
    x: cx + dx * Math.cos(rad) - dy * Math.sin(rad),
    y: cy + dx * Math.sin(rad) + dy * Math.cos(rad)
  };
}

function reflectPoint(pt, line, m, c) {
  let x = pt.x, y = pt.y;
  switch(line) {
    case 'x-axis': return {x, y: -y};
    case 'y-axis': return {x: -x, y};
    case 'y=x':   return {x: y, y: x};
    case 'y=-x':  return {x: -y, y: -x};
    case 'custom': {
      // Reflect in y = mx + c  (line: ax + by + c2 = 0 where a=m, b=-1, c2=c)
      const d = m * m + 1;
      const nx = ((1 - m*m)*x + 2*m*y - 2*m*c) / d;
      const ny = ((m*m - 1)*y + 2*m*x + 2*c) / d;
      return {x: nx, y: ny};
    }
  }
}

function applyEnlargement(pt, sf, cx, cy) {
  return {
    x: cx + sf * (pt.x - cx),
    y: cy + sf * (pt.y - cy)
  };
}

function getTransformedVerts(t) {
  const tx = parseFloat(document.getElementById('tx-slider').value);
  const ty = parseFloat(document.getElementById('ty-slider').value);
  const angle = parseFloat(document.getElementById('angle-slider').value);
  const cx = parseFloat(document.getElementById('cx-slider').value);
  const cy = parseFloat(document.getElementById('cy-slider').value);
  const sf = parseFloat(document.getElementById('sf-slider').value);
  const ecx = parseFloat(document.getElementById('ecx-slider').value);
  const ecy = parseFloat(document.getElementById('ecy-slider').value);
  const refLine = document.getElementById('ref-line').value;
  const refM = parseFloat(document.getElementById('ref-m-slider').value);
  const refC = parseFloat(document.getElementById('ref-c-slider').value);

  return shapeVerts.map(pt => {
    let res;
    switch(transformType) {
      case 'translation':  res = applyTranslation(pt, tx * (t||1), ty * (t||1)); break;
      case 'rotation':     res = applyRotation(pt, angle * (t||1), cx, cy); break;
      case 'reflection':
        // Interpolate for animation: lerp between original and reflected
        const refl = reflectPoint(pt, refLine, refM, refC);
        res = {x: pt.x + (refl.x - pt.x)*(t||1), y: pt.y + (refl.y - pt.y)*(t||1)};
        break;
      case 'enlargement':
        const sfT = 1 + (sf - 1) * (t||1);
        res = applyEnlargement(pt, sfT, ecx, ecy);
        break;
      default: res = {...pt};
    }
    return res;
  });
}

// ==================== MATRIX DISPLAY ====================
function computeMatrix() {
  const angle = parseFloat(document.getElementById('angle-slider').value);
  const dir = document.getElementById('rot-dir').value;
  const sf = parseFloat(document.getElementById('sf-slider').value);
  const refLine = document.getElementById('ref-line').value;
  const refM = parseFloat(document.getElementById('ref-m-slider').value);
  const tx = parseFloat(document.getElementById('tx-slider').value);
  const ty = parseFloat(document.getElementById('ty-slider').value);

  let m00=1, m01=0, m10=0, m11=1;
  let label = 'About the origin';
  let note = '';

  switch(transformType) {
    case 'translation':
      label = 'Translation (not a matrix mult.)';
      note = `Vector: (${tx}, ${ty})`;
      // Show identity
      break;
    case 'rotation': {
      let rad = angle * Math.PI / 180;
      if(dir === 'cw') rad = -rad;
      m00 = Math.cos(rad); m01 = -Math.sin(rad);
      m10 = Math.sin(rad); m11 = Math.cos(rad);
      label = `Rotation ${dir==='cw'?angle+'° clockwise':angle+'° anticlockwise'}`;
      const cx = parseFloat(document.getElementById('cx-slider').value);
      const cy = parseFloat(document.getElementById('cy-slider').value);
      if(cx!==0||cy!==0) note = `Centre (${cx}, ${cy}) — matrix valid about origin`;
      break;
    }
    case 'reflection': {
      switch(refLine) {
        case 'x-axis': m00=1;m01=0;m10=0;m11=-1; label='Reflect in x-axis (y=0)'; break;
        case 'y-axis': m00=-1;m01=0;m10=0;m11=1; label='Reflect in y-axis (x=0)'; break;
        case 'y=x':   m00=0;m01=1;m10=1;m11=0;   label='Reflect in y = x'; break;
        case 'y=-x':  m00=0;m01=-1;m10=-1;m11=0; label='Reflect in y = -x'; break;
        case 'custom': {
          const m2 = refM*refM;
          m00=(1-m2)/(m2+1); m01=(2*refM)/(m2+1);
          m10=(2*refM)/(m2+1); m11=(m2-1)/(m2+1);
          label=`Reflect in y=${refM}x (about origin)`;
          break;
        }
      }
      break;
    }
    case 'enlargement': {
      m00=sf; m01=0; m10=0; m11=sf;
      label = `Enlargement SF ${sf}`;
      const ecx=parseFloat(document.getElementById('ecx-slider').value);
      const ecy=parseFloat(document.getElementById('ecy-slider').value);
      if(ecx!==0||ecy!==0) note=`Centre (${ecx}, ${ecy}) — matrix valid about origin`;
      break;
    }
  }

  // Format
  const fmt = v => {
    const r = Math.round(v*100)/100;
    return r === 0 ? '0' : r === 1 ? '1' : r === -1 ? '-1' : r.toFixed(2);
  };

  const prev = lastPrevMatrix;
  const cur = [fmt(m00), fmt(m01), fmt(m10), fmt(m11)];

  document.getElementById('m00').textContent = cur[0];
  document.getElementById('m01').textContent = cur[1];
  document.getElementById('m10').textContent = cur[2];
  document.getElementById('m11').textContent = cur[3];
  document.getElementById('matrix-label').textContent = label;
  document.getElementById('matrix-note').textContent = note;

  if(prev) {
    ['m00','m01','m10','m11'].forEach((id,i)=>{
      const el = document.getElementById(id);
      el.classList.toggle('changed', cur[i]!==prev[i]);
    });
  }
  lastPrevMatrix = cur;
}

// ==================== DESCRIPTION ====================
function updateDescription() {
  const tx = parseFloat(document.getElementById('tx-slider').value);
  const ty = parseFloat(document.getElementById('ty-slider').value);
  const angle = parseFloat(document.getElementById('angle-slider').value);
  const dir = document.getElementById('rot-dir').value;
  const cx = parseFloat(document.getElementById('cx-slider').value);
  const cy = parseFloat(document.getElementById('cy-slider').value);
  const sf = parseFloat(document.getElementById('sf-slider').value);
  const ecx = parseFloat(document.getElementById('ecx-slider').value);
  const ecy = parseFloat(document.getElementById('ecy-slider').value);
  const refLine = document.getElementById('ref-line').value;
  const refM = parseFloat(document.getElementById('ref-m-slider').value);
  const refC = parseFloat(document.getElementById('ref-c-slider').value);

  let d = '';
  switch(transformType) {
    case 'translation':
      d = `Translation by vector (${tx}, ${ty}).`;
      if(tx>0) d+=' Moves right.'; else if(tx<0) d+=' Moves left.';
      if(ty>0) d+=' Moves up.'; else if(ty<0) d+=' Moves down.';
      break;
    case 'rotation':
      d = `Rotation of ${angle}° ${dir==='cw'?'clockwise':'anticlockwise'} about centre (${cx}, ${cy}).`;
      break;
    case 'reflection':
      if(refLine==='custom') d = `Reflection in the line y = ${refM}x + ${refC}.`;
      else if(refLine==='x-axis') d = `Reflection in the x-axis (y = 0).`;
      else if(refLine==='y-axis') d = `Reflection in the y-axis (x = 0).`;
      else d = `Reflection in the line ${refLine}.`;
      break;
    case 'enlargement':
      const area = Math.abs(sf * sf).toFixed(2);
      d = `Enlargement with scale factor ${sf}, centre (${ecx}, ${ecy}). Area of image = ${area} x area of object.`;
      if(sf<0) d += ' Negative SF: image is on the opposite side of the centre.';
      break;
  }
  document.getElementById('descriptionBox').textContent = d;
}

// ==================== COORDINATES TABLE ====================
function updateCoordsTable(imageVerts) {
  const labels = ['A','B','C','D','E','F'];
  const body = document.getElementById('coordTableBody');
  body.innerHTML = '';
  shapeVerts.forEach((v,i) => {
    const img = imageVerts[i];
    const row = document.createElement('tr');
    const fmt = n => Math.round(n*10)/10;
    row.innerHTML = `
      <td style="font-weight:700;">${labels[i]||i+1}</td>
      <td class="coord-orig">(${fmt(v.x)}, ${fmt(v.y)})</td>
      <td class="coord-image">(${fmt(img.x)}, ${fmt(img.y)})</td>`;
    body.appendChild(row);
  });
}

// ==================== DRAWING ====================
function drawGrid() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const W = canvas.width, H = canvas.height;
  const half = GRID_SIZE / 2;

  // Faint grid lines
  ctx.strokeStyle = '#e8edf5';
  ctx.lineWidth = 1;
  for(let i = -half; i <= half; i++) {
    const x = ORIGIN.x + i*CELL;
    const y = ORIGIN.y + i*CELL;
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }

  // Axes
  ctx.strokeStyle = '#9bb4d0';
  ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(0, ORIGIN.y); ctx.lineTo(W, ORIGIN.y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(ORIGIN.x, 0); ctx.lineTo(ORIGIN.x, H); ctx.stroke();

  // Axis arrows
  ctx.fillStyle = '#9bb4d0';
  const aw = 6, ah = 10;
  ctx.beginPath(); ctx.moveTo(W-2, ORIGIN.y); ctx.lineTo(W-2-ah, ORIGIN.y-aw); ctx.lineTo(W-2-ah, ORIGIN.y+aw); ctx.fill();
  ctx.beginPath(); ctx.moveTo(ORIGIN.x, 2); ctx.lineTo(ORIGIN.x-aw, 2+ah); ctx.lineTo(ORIGIN.x+aw, 2+ah); ctx.fill();

  // Axis labels
  if(showLabels) {
    ctx.fillStyle = '#7a9abf';
    ctx.font = '13px Segoe UI, Arial, sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('x', W-4, ORIGIN.y-8);
    ctx.textAlign = 'center';
    ctx.fillText('y', ORIGIN.x+14, 14);

    // Tick labels
    ctx.fillStyle = '#8fa8c0';
    ctx.font = '10px Segoe UI, Arial, sans-serif';
    for(let i = -half+1; i < half; i++) {
      if(i===0) continue;
      const xp = ORIGIN.x + i*CELL;
      const yp = ORIGIN.y + i*CELL;
      ctx.textAlign = 'center';
      ctx.fillText(i, xp, ORIGIN.y+13);
      ctx.textAlign = 'right';
      ctx.fillText(-i, ORIGIN.x-4, yp+4);
    }
  }
}

function drawPolygon(verts, fillCol, strokeCol, alpha, lineDash) {
  if(verts.length < 2) return;
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.setLineDash(lineDash||[]);
  ctx.strokeStyle = strokeCol;
  ctx.lineWidth = 2.5;
  ctx.fillStyle = fillCol;
  ctx.beginPath();
  const c0 = toCanvas(verts[0].x, verts[0].y);
  ctx.moveTo(c0.x, c0.y);
  for(let i=1;i<verts.length;i++){
    const c=toCanvas(verts[i].x,verts[i].y);
    ctx.lineTo(c.x,c.y);
  }
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  ctx.restore();
}

function drawVertices(verts, col, border) {
  verts.forEach((v,i) => {
    const c = toCanvas(v.x, v.y);
    ctx.beginPath();
    ctx.arc(c.x, c.y, 7, 0, Math.PI*2);
    ctx.fillStyle = col;
    ctx.fill();
    ctx.strokeStyle = border;
    ctx.lineWidth = 2;
    ctx.stroke();
    if(showLabels) {
      const labels = ['A','B','C','D','E','F'];
      ctx.fillStyle = border;
      ctx.font = 'bold 11px Segoe UI, Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(labels[i]||i+1, c.x, c.y-12);
    }
  });
}

function drawImageVertices(verts) {
  const labels = ["A'","B'","C'","D'","E'","F'"];
  verts.forEach((v,i) => {
    const c = toCanvas(v.x, v.y);
    ctx.beginPath();
    ctx.arc(c.x, c.y, 6, 0, Math.PI*2);
    ctx.fillStyle = '#86efac';
    ctx.fill();
    ctx.strokeStyle = '#16a34a';
    ctx.lineWidth = 2;
    ctx.stroke();
    if(showLabels) {
      ctx.fillStyle = '#15803d';
      ctx.font = 'bold 11px Segoe UI, Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(labels[i]||i+"'", c.x, c.y-11);
    }
  });
}

function drawCentreMark(gx, gy, col) {
  const c = toCanvas(gx, gy);
  ctx.strokeStyle = col;
  ctx.lineWidth = 2;
  const s = 7;
  ctx.beginPath(); ctx.moveTo(c.x-s,c.y); ctx.lineTo(c.x+s,c.y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(c.x,c.y-s); ctx.lineTo(c.x+s*0.6,c.y+s*0.6); ctx.stroke();
  ctx.beginPath(); ctx.arc(c.x,c.y,s,0,Math.PI*2); ctx.stroke();
  ctx.fillStyle = col+'33';
  ctx.beginPath(); ctx.arc(c.x,c.y,s,0,Math.PI*2); ctx.fill();
}

function drawMirrorLine() {
  const refLine = document.getElementById('ref-line').value;
  const refM = parseFloat(document.getElementById('ref-m-slider').value);
  const refC = parseFloat(document.getElementById('ref-c-slider').value);
  const W = canvas.width, H = canvas.height;

  ctx.save();
  ctx.strokeStyle = '#dc2626';
  ctx.lineWidth = 2;
  ctx.setLineDash([8,5]);
  ctx.globalAlpha = 0.7;
  ctx.beginPath();

  if(refLine==='x-axis') {
    const y = toCanvas(0,0).y;
    ctx.moveTo(0,y); ctx.lineTo(W,y);
  } else if(refLine==='y-axis') {
    const x = toCanvas(0,0).x;
    ctx.moveTo(x,0); ctx.lineTo(x,H);
  } else if(refLine==='y=x') {
    // from top-left to bottom-right in grid
    const a = toCanvas(-8,8), b = toCanvas(8,-8);
    ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y);
  } else if(refLine==='y=-x') {
    const a = toCanvas(-8,-8), b = toCanvas(8,8);
    ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y);
  } else if(refLine==='custom') {
    // y = mx + c at x = -8 and x = 8
    const x1=-8, y1=refM*x1+refC;
    const x2=8,  y2=refM*x2+refC;
    const p1=toCanvas(x1,y1), p2=toCanvas(x2,y2);
    ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y);
  }
  ctx.stroke();
  ctx.restore();
}

function drawTransformAid() {
  switch(transformType) {
    case 'rotation': {
      const cx = parseFloat(document.getElementById('cx-slider').value);
      const cy = parseFloat(document.getElementById('cy-slider').value);
      drawCentreMark(cx, cy, '#f59e0b');
      break;
    }
    case 'reflection':
      drawMirrorLine();
      break;
    case 'enlargement': {
      const ecx = parseFloat(document.getElementById('ecx-slider').value);
      const ecy = parseFloat(document.getElementById('ecy-slider').value);
      drawCentreMark(ecx, ecy, '#f59e0b');
      // Draw ray lines from centre through each vertex
      ctx.save();
      ctx.strokeStyle = '#f59e0b';
      ctx.lineWidth = 1;
      ctx.setLineDash([4,4]);
      ctx.globalAlpha = 0.45;
      const sf = parseFloat(document.getElementById('sf-slider').value);
      shapeVerts.forEach(v=>{
        const c0 = toCanvas(ecx, ecy);
        const cv = toCanvas(v.x, v.y);
        // Extend ray
        const dx = cv.x-c0.x, dy = cv.y-c0.y;
        const ext = toCanvas(ecx + (v.x-ecx)*sf*1.1, ecy + (v.y-ecy)*sf*1.1);
        ctx.beginPath(); ctx.moveTo(c0.x,c0.y); ctx.lineTo(ext.x,ext.y); ctx.stroke();
      });
      ctx.restore();
      break;
    }
  }
}

function redrawAll(animT) {
  const t = (animT !== undefined) ? animT : 1;
  const imageVerts = getTransformedVerts(t);

  drawGrid();
  drawTransformAid();

  // Original shape
  drawPolygon(shapeVerts, 'rgba(37,99,168,0.10)', '#2563a8', 1, []);
  drawVertices(shapeVerts, '#93c5fd', '#1a3a5c');

  // Image shape
  drawPolygon(imageVerts, 'rgba(22,163,74,0.12)', '#16a34a', 1, []);
  drawImageVertices(imageVerts);

  if(animT === undefined || animT === 1) {
    computeMatrix();
    updateCoordsTable(imageVerts);
    updateDescription();
  }
}

// ==================== ANIMATION ====================
function animateTransform() {
  if(animFrame) { cancelAnimationFrame(animFrame); animFrame=null; }
  const duration = 900;
  const start = performance.now();
  const progress = document.getElementById('animProgress');
  progress.style.width = '0%';

  function step(now) {
    const elapsed = now - start;
    let t = Math.min(elapsed / duration, 1);
    // ease in-out
    t = t < 0.5 ? 2*t*t : -1+(4-2*t)*t;
    redrawAll(t);
    progress.style.width = (t*100)+'%';
    if(elapsed < duration) {
      animFrame = requestAnimationFrame(step);
    } else {
      redrawAll(1);
      progress.style.width = '100%';
      setTimeout(()=>{ progress.style.width='0%'; }, 600);
    }
  }
  animFrame = requestAnimationFrame(step);
}

// ==================== DRAG VERTICES ====================
function getMouseGrid(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const cx = (e.clientX - rect.left) * scaleX;
  const cy = (e.clientY - rect.top) * scaleY;
  return toGrid(cx, cy);
}

function getTouchGrid(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const touch = e.touches[0];
  const cx = (touch.clientX - rect.left) * scaleX;
  const cy = (touch.clientY - rect.top) * scaleY;
  return toGrid(cx, cy);
}

function findNearestVertex(gx, gy, thresh) {
  let best = -1, bestD = thresh;
  shapeVerts.forEach((v,i) => {
    const d = Math.hypot(v.x-gx, v.y-gy);
    if(d < bestD) { bestD=d; best=i; }
  });
  return best;
}

canvas.addEventListener('mousedown', e => {
  const g = getMouseGrid(e);
  const idx = findNearestVertex(g.x, g.y, 1.2);
  if(idx >= 0) dragging = idx;
});
canvas.addEventListener('mousemove', e => {
  if(dragging === null) return;
  const g = getMouseGrid(e);
  shapeVerts[dragging] = snapGrid(g);
  redrawAll();
});
canvas.addEventListener('mouseup', ()=>{ dragging=null; });
canvas.addEventListener('mouseleave', ()=>{ dragging=null; });

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const g = getTouchGrid(e);
  const idx = findNearestVertex(g.x, g.y, 1.5);
  if(idx >= 0) dragging = idx;
}, {passive:false});
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if(dragging === null) return;
  const g = getTouchGrid(e);
  shapeVerts[dragging] = snapGrid(g);
  redrawAll();
}, {passive:false});
canvas.addEventListener('touchend', ()=>{ dragging=null; });

// ==================== SLIDER/INPUT SYNC ====================
function syncInput(id) {
  const slider = document.getElementById(id+'-slider');
  const num    = document.getElementById(id+'-num');
  const val    = document.getElementById(id+'-val');
  if(num) num.value = slider.value;
  if(val) {
    const suffix = id==='angle'?'°':'';
    val.textContent = slider.value + suffix;
  }
  redrawAll();
}
function syncSlider(id) {
  const slider = document.getElementById(id+'-slider');
  const num    = document.getElementById(id+'-num');
  const val    = document.getElementById(id+'-val');
  if(slider && num) slider.value = num.value;
  if(val) {
    const suffix = id==='angle'?'°':'';
    val.textContent = num.value + suffix;
  }
  redrawAll();
}

// ==================== TRANSFORM TYPE ====================
function setTransformType(type) {
  transformType = type;
  ['translation','rotation','reflection','enlargement'].forEach(t => {
    document.getElementById('ctrl-'+t).style.display = t===type?'':'none';
    document.getElementById('tab-'+t).classList.toggle('active', t===type);
  });
  redrawAll();
}

// ==================== REFLECTION LINE ====================
function updateReflectionCustom() {
  const refLine = document.getElementById('ref-line').value;
  document.getElementById('custom-ref-controls').style.display = refLine==='custom'?'':'none';
  redrawAll();
}

// ==================== RESET ====================
function resetShape() {
  loadPreset(currentPreset);
}

function toggleGrid() {
  showLabels = !showLabels;
  redrawAll();
}

// ==================== TAB SWITCHING ====================
function switchTab(tab) {
  const explorerLayout = document.getElementById('explorerLayout');
  const infoPanel = document.getElementById('infoPanel');
  document.querySelectorAll('.header-tab').forEach((b,i) => {
    b.classList.toggle('active', (tab==='explorer'&&i===0)||(tab==='info'&&i===1));
  });
  if(tab==='explorer') {
    explorerLayout.style.display = '';
    infoPanel.style.display = 'none';
    redrawAll();
  } else {
    explorerLayout.style.display = 'none';
    infoPanel.style.display = 'block';
  }
}

// ==================== RESPONSIVE CANVAS ====================
function resizeCanvas() {
  const area = document.querySelector('.canvas-area');
  if(!area) return;
  const w = area.clientWidth - 32;
  const h = area.clientHeight - 80;
  const size = Math.max(200, Math.min(w, h, 560));
  canvas.style.width  = size + 'px';
  canvas.style.height = size + 'px';
}
window.addEventListener('resize', () => { resizeCanvas(); redrawAll(); });

// ==================== INIT ====================
loadPreset('triangle');
setTransformType('translation');
resizeCanvas();
redrawAll();
</script>
</body>
</html>
