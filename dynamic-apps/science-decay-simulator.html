<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radioactive Decay Simulator</title>
    <style>
        :root {
            --primary: #2e7d32;
            --primary-light: #4caf50;
            --primary-dark: #1b5e20;
            --primary-pale: #e8f5e9;
            --accent: #66bb6a;
            --accent-glow: #a5d6a7;
            --bg: #f1f8e9;
            --bg-card: #ffffff;
            --text: #1b1b1b;
            --text-muted: #555;
            --border: #c8e6c9;
            --danger: #e53935;
            --danger-light: #ef9a9a;
            --warning: #ff9800;
            --info: #0288d1;
            --radius: 10px;
            --shadow: 0 2px 8px rgba(0,0,0,0.08);
            --shadow-lg: 0 4px 16px rgba(0,0,0,0.12);
            --transition: 0.2s ease;
            --font: 'Segoe UI', system-ui, -apple-system, sans-serif;
            --mono: 'Consolas', 'Courier New', monospace;
        }

        *, *::before, *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font);
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            min-height: 100vh;
        }

        /* Sticky Header */
        .header {
            position: sticky;
            top: 0;
            z-index: 100;
            background: linear-gradient(135deg, var(--primary-dark), var(--primary));
            color: #fff;
            padding: 14px 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: var(--shadow-lg);
        }

        .header h1 {
            font-size: 1.35rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header h1 .icon {
            font-size: 1.5rem;
        }

        .header-badge {
            background: rgba(255,255,255,0.18);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        /* Main Layout */
        .main {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Cards */
        .card {
            background: var(--bg-card);
            border-radius: var(--radius);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        .card-header {
            background: var(--primary-pale);
            padding: 12px 18px;
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--primary-dark);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .card-body {
            padding: 18px;
        }

        /* Controls Panel */
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            align-items: end;
        }

        .control-group label {
            display: block;
            font-size: 0.82rem;
            font-weight: 600;
            color: var(--text-muted);
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .range-value {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--primary);
            float: right;
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 9px 18px;
            border: none;
            border-radius: 6px;
            font-size: 0.88rem;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition);
            font-family: var(--font);
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(0,0,0,0.15);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-primary {
            background: var(--primary);
            color: #fff;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
        }

        .btn-danger {
            background: var(--danger);
            color: #fff;
        }

        .btn-danger:hover {
            background: #c62828;
        }

        .btn-outline {
            background: transparent;
            color: var(--primary);
            border: 2px solid var(--primary);
        }

        .btn-outline:hover {
            background: var(--primary-pale);
        }

        .btn-outline.active {
            background: var(--primary);
            color: #fff;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Speed Toggle */
        .speed-btns {
            display: flex;
            gap: 4px;
        }

        .speed-btns .btn {
            padding: 6px 12px;
            font-size: 0.8rem;
            border-radius: 4px;
        }

        /* Stats Bar */
        .stats-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
        }

        .stat-item {
            text-align: centre;
            padding: 12px;
            background: var(--primary-pale);
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-dark);
            font-family: var(--mono);
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.3px;
            margin-top: 2px;
        }

        /* Simulation Area */
        .sim-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .atom-grid-wrapper {
            position: relative;
            background: #111;
            border-radius: var(--radius);
            overflow: hidden;
            aspect-ratio: 1;
            max-height: 500px;
        }

        .atom-grid-wrapper canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .grid-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.65);
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.78rem;
            font-family: var(--mono);
        }

        /* Decay Curve */
        .curve-wrapper {
            position: relative;
            background: #fff;
            border-radius: var(--radius);
            border: 1px solid var(--border);
        }

        .curve-wrapper canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Mode Toggle */
        .mode-toggle {
            display: flex;
            background: var(--primary-pale);
            border-radius: 8px;
            padding: 4px;
            width: fit-content;
        }

        .mode-toggle .btn {
            border-radius: 6px;
            padding: 7px 16px;
            background: transparent;
            color: var(--primary-dark);
            border: none;
            font-size: 0.85rem;
        }

        .mode-toggle .btn.active {
            background: var(--primary);
            color: #fff;
            box-shadow: 0 1px 4px rgba(0,0,0,0.15);
        }

        /* Info Panel */
        .info-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .info-tab {
            padding: 7px 14px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: #fff;
            cursor: pointer;
            font-size: 0.82rem;
            font-weight: 500;
            color: var(--text-muted);
            transition: all var(--transition);
        }

        .info-tab:hover {
            border-color: var(--primary-light);
            color: var(--primary);
        }

        .info-tab.active {
            background: var(--primary);
            color: #fff;
            border-color: var(--primary);
        }

        .info-content {
            display: none;
            line-height: 1.7;
            font-size: 0.92rem;
        }

        .info-content.active {
            display: block;
        }

        .info-content h3 {
            color: var(--primary-dark);
            margin-bottom: 8px;
            font-size: 1.05rem;
        }

        .info-content p {
            margin-bottom: 10px;
        }

        .info-content ul {
            padding-left: 22px;
            margin-bottom: 10px;
        }

        .info-content li {
            margin-bottom: 4px;
        }

        .info-highlight {
            background: var(--primary-pale);
            border-left: 3px solid var(--primary);
            padding: 10px 14px;
            border-radius: 0 6px 6px 0;
            margin: 10px 0;
            font-size: 0.88rem;
        }

        .info-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            font-size: 0.88rem;
        }

        .info-table th, .info-table td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .info-table th {
            background: var(--primary-pale);
            color: var(--primary-dark);
            font-weight: 600;
        }

        /* Progress bar for half-life tick */
        .tick-progress {
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 8px;
        }

        .tick-progress-fill {
            height: 100%;
            background: var(--primary-light);
            border-radius: 2px;
            width: 0%;
            transition: width 0.1s linear;
        }

        /* Dice mode overlay */
        .dice-display {
            display: none;
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.82rem;
            font-family: var(--mono);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header {
                padding: 10px 16px;
            }

            .header h1 {
                font-size: 1.1rem;
            }

            .main {
                padding: 12px;
                gap: 14px;
            }

            .sim-layout {
                grid-template-columns: 1fr;
            }

            .atom-grid-wrapper {
                max-height: 350px;
            }

            .curve-wrapper {
                min-height: 280px;
            }

            .controls-grid {
                grid-template-columns: 1fr 1fr;
            }

            .stats-bar {
                grid-template-columns: repeat(3, 1fr);
            }

            .stat-value {
                font-size: 1.2rem;
            }

            .btn-group {
                justify-content: center;
            }
        }

        @media (max-width: 480px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }

            .stats-bar {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>

<header class="header">
    <h1><span class="icon">&#9762;</span> Radioactive Decay Simulator</h1>
    <span class="header-badge">Physics</span>
</header>

<main class="main">

    <!-- Controls -->
    <div class="card">
        <div class="card-header">&#9881; Controls</div>
        <div class="card-body">
            <div class="controls-grid">
                <div class="control-group">
                    <label>Half-life <span class="range-value" id="halfLifeValue">5s</span></label>
                    <input type="range" id="halfLifeSlider" min="1" max="30" value="5" step="1">
                </div>
                <div class="control-group">
                    <label>Sample Size <span class="range-value" id="sampleValue">200</span></label>
                    <input type="range" id="sampleSlider" min="50" max="500" value="200" step="10">
                </div>
                <div class="control-group">
                    <label>Speed</label>
                    <div class="speed-btns">
                        <button class="btn btn-outline active" data-speed="1">1x</button>
                        <button class="btn btn-outline" data-speed="2">2x</button>
                        <button class="btn btn-outline" data-speed="5">5x</button>
                        <button class="btn btn-outline" data-speed="10">10x</button>
                    </div>
                </div>
                <div class="control-group">
                    <label>Mode</label>
                    <div class="mode-toggle">
                        <button class="btn active" id="modeAtom" data-mode="atom">Atom</button>
                        <button class="btn" id="modeDice" data-mode="dice">Dice</button>
                    </div>
                </div>
            </div>
            <div style="margin-top: 16px; display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                <div class="btn-group">
                    <button class="btn btn-primary" id="btnPlay">&#9654; Play</button>
                    <button class="btn btn-outline" id="btnPause" disabled>&#10074;&#10074; Pause</button>
                    <button class="btn btn-danger" id="btnReset">&#8635; Reset</button>
                </div>
                <div class="tick-progress" style="flex: 1; min-width: 120px;">
                    <div class="tick-progress-fill" id="tickProgress"></div>
                </div>
                <span id="tickLabel" style="font-size: 0.82rem; color: var(--text-muted); font-family: var(--mono);">
                    Half-life: 0 / 0
                </span>
            </div>
        </div>
    </div>

    <!-- Stats Bar -->
    <div class="stats-bar">
        <div class="stat-item">
            <div class="stat-value" id="statUndecayed">200</div>
            <div class="stat-label">Undecayed</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="statDecayed">0</div>
            <div class="stat-label">Decayed</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="statPercent">100%</div>
            <div class="stat-label">Remaining</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="statHalfLives">0</div>
            <div class="stat-label">Half-lives</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="statElapsed">0.0s</div>
            <div class="stat-label">Time Elapsed</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="statActivity">0</div>
            <div class="stat-label">Last Tick Decays</div>
        </div>
    </div>

    <!-- Simulation Area -->
    <div class="sim-layout">
        <div class="card">
            <div class="card-header">&#9883; Atom Grid</div>
            <div class="card-body" style="padding: 0;">
                <div class="atom-grid-wrapper" id="atomGridWrapper">
                    <canvas id="atomCanvas"></canvas>
                    <div class="grid-overlay" id="gridOverlay">Ready</div>
                    <div class="dice-display" id="diceDisplay">Dice: rolling...</div>
                </div>
            </div>
        </div>
        <div class="card">
            <div class="card-header">&#128200; Decay Curve</div>
            <div class="card-body" style="padding: 8px;">
                <div class="curve-wrapper">
                    <canvas id="curveCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Info Panel -->
    <div class="card">
        <div class="card-header">&#128218; Information</div>
        <div class="card-body">
            <div class="info-tabs">
                <button class="info-tab active" data-info="decay">Radioactive Decay</button>
                <button class="info-tab" data-info="halflife">Half-life</button>
                <button class="info-tab" data-info="radiation">Radiation Types</button>
                <button class="info-tab" data-info="carbon">Carbon Dating</button>
                <button class="info-tab" data-info="howto">How to Use</button>
            </div>

            <div class="info-content active" id="info-decay">
                <h3>What is Radioactive Decay?</h3>
                <p>Radioactive decay is a random process in which an unstable atomic nucleus loses energy by emitting radiation. Each unstable atom has a fixed probability of decaying in any given time interval, but it is impossible to predict exactly when a particular atom will decay.</p>
                <div class="info-highlight">
                    Key idea: Radioactive decay is spontaneous and random. You cannot make it happen faster by heating, cooling, or chemically changing the substance.
                </div>
                <p>When a nucleus decays, it transforms into a different element or a more stable isotope. The original atom is called the <strong>parent nucleus</strong> and the result is the <strong>daughter nucleus</strong>.</p>
                <p>In this simulation, green circles represent undecayed (parent) atoms and grey circles represent decayed (daughter) atoms. Each half-life tick, every undecayed atom has a 50% chance of decaying.</p>
            </div>

            <div class="info-content" id="info-halflife">
                <h3>Understanding Half-life</h3>
                <p>The <strong>half-life</strong> of a radioactive isotope is the average time it takes for half of the undecayed nuclei in a sample to decay. After one half-life, roughly 50% of the original atoms remain. After two half-lives, roughly 25% remain, and so on.</p>
                <div class="info-highlight">
                    After <em>n</em> half-lives, the fraction remaining is approximately (1/2)<sup>n</sup>. For example, after 3 half-lives, about 1/8 (12.5%) of the original sample remains.
                </div>
                <table class="info-table">
                    <thead>
                        <tr><th>Half-lives</th><th>Fraction Remaining</th><th>Percentage</th></tr>
                    </thead>
                    <tbody>
                        <tr><td>0</td><td>1</td><td>100%</td></tr>
                        <tr><td>1</td><td>1/2</td><td>50%</td></tr>
                        <tr><td>2</td><td>1/4</td><td>25%</td></tr>
                        <tr><td>3</td><td>1/8</td><td>12.5%</td></tr>
                        <tr><td>4</td><td>1/16</td><td>6.25%</td></tr>
                        <tr><td>5</td><td>1/32</td><td>3.125%</td></tr>
                    </tbody>
                </table>
                <p>Different isotopes have vastly different half-lives. Uranium-238 has a half-life of about 4.5 billion years, whilst Polonium-214 has a half-life of just 0.00016 seconds.</p>
            </div>

            <div class="info-content" id="info-radiation">
                <h3>Types of Radiation</h3>
                <p>When nuclei decay, they can emit three main types of nuclear radiation:</p>
                <table class="info-table">
                    <thead>
                        <tr><th>Type</th><th>Symbol</th><th>What is it?</th><th>Penetration</th><th>Ionising Power</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><strong>Alpha</strong></td><td>&alpha;</td><td>2 protons + 2 neutrons (helium nucleus)</td><td>Stopped by paper or skin</td><td>Strongly ionising</td></tr>
                        <tr><td><strong>Beta</strong></td><td>&beta;</td><td>High-speed electron from the nucleus</td><td>Stopped by aluminium (few mm)</td><td>Moderately ionising</td></tr>
                        <tr><td><strong>Gamma</strong></td><td>&gamma;</td><td>Electromagnetic radiation (high-energy photon)</td><td>Reduced by thick lead or concrete</td><td>Weakly ionising</td></tr>
                    </tbody>
                </table>
                <div class="info-highlight">
                    Alpha particles are the most ionising but least penetrating. Gamma rays are the least ionising but most penetrating. This is important when considering safety and shielding.
                </div>
            </div>

            <div class="info-content" id="info-carbon">
                <h3>Carbon Dating</h3>
                <p>Carbon-14 is a radioactive isotope of carbon with a half-life of approximately 5,730 years. Living organisms constantly take in carbon from the atmosphere (including a small proportion of carbon-14). When the organism dies, it stops absorbing carbon, and the carbon-14 it contains begins to decay.</p>
                <p>By measuring the proportion of carbon-14 remaining in a sample, scientists can estimate how long ago the organism died. This technique is called <strong>radiocarbon dating</strong>.</p>
                <div class="info-highlight">
                    Carbon dating is effective for samples up to about 50,000 years old. Beyond that, too little carbon-14 remains for accurate measurement. For older samples, scientists use isotopes with longer half-lives, such as potassium-40 (1.25 billion years) or uranium-238 (4.5 billion years).
                </div>
                <p>Applications include dating archaeological artefacts, ancient wood, bone, and peat, as well as verifying the age of historical documents and artworks.</p>
            </div>

            <div class="info-content" id="info-howto">
                <h3>How to Use This Simulator</h3>
                <ul>
                    <li><strong>Half-life slider:</strong> Set how many seconds each half-life lasts (1 to 30 seconds).</li>
                    <li><strong>Sample size slider:</strong> Set the number of atoms in your sample (50 to 500).</li>
                    <li><strong>Speed buttons:</strong> Increase simulation speed (1x, 2x, 5x, or 10x).</li>
                    <li><strong>Mode:</strong> Switch between Atom mode (random 50% chance each tick) and Dice mode (each atom "rolls a die"; it decays if it rolls a 1, giving a 1 in 6 chance per tick).</li>
                    <li><strong>Play:</strong> Start the simulation. Each half-life tick, undecayed atoms are tested for decay.</li>
                    <li><strong>Pause:</strong> Temporarily stop the simulation.</li>
                    <li><strong>Reset:</strong> Clear all data and return to the starting state.</li>
                </ul>
                <div class="info-highlight">
                    In Atom mode, each undecayed atom has a 50% chance of decaying per tick (modelling one half-life). In Dice mode, each atom has a 1 in 6 chance per tick, so the decay is slower and more closely mirrors the classic classroom experiment of rolling dice.
                </div>
            </div>
        </div>
    </div>

</main>

<script>
(function() {
    'use strict';

    /* ===================== STATE ===================== */
    const state = {
        halfLife: 5,
        sampleSize: 200,
        speed: 1,
        mode: 'atom',        // 'atom' or 'dice'
        running: false,
        paused: false,
        atoms: [],            // { decayed: bool, x, y, decayTick }
        dataPoints: [],       // { tick, undecayed, elapsed }
        currentTick: 0,
        elapsed: 0,
        lastTickDecays: 0,
        tickTimer: null,
        tickElapsed: 0,       // ms elapsed within current tick
        animFrame: null
    };

    /* ===================== DOM REFS ===================== */
    const $ = id => document.getElementById(id);
    const halfLifeSlider = $('halfLifeSlider');
    const halfLifeValue = $('halfLifeValue');
    const sampleSlider = $('sampleSlider');
    const sampleValue = $('sampleValue');
    const btnPlay = $('btnPlay');
    const btnPause = $('btnPause');
    const btnReset = $('btnReset');
    const tickProgress = $('tickProgress');
    const tickLabel = $('tickLabel');
    const atomCanvas = $('atomCanvas');
    const curveCanvas = $('curveCanvas');
    const atomGridWrapper = $('atomGridWrapper');
    const gridOverlay = $('gridOverlay');
    const diceDisplay = $('diceDisplay');

    const statUndecayed = $('statUndecayed');
    const statDecayed = $('statDecayed');
    const statPercent = $('statPercent');
    const statHalfLives = $('statHalfLives');
    const statElapsed = $('statElapsed');
    const statActivity = $('statActivity');

    const atomCtx = atomCanvas.getContext('2d');
    const curveCtx = curveCanvas.getContext('2d');

    /* ===================== HELPERS ===================== */
    function getUndecayed() {
        return state.atoms.filter(a => !a.decayed).length;
    }

    function layoutAtoms() {
        const n = state.sampleSize;
        const cols = Math.ceil(Math.sqrt(n * 1.1));
        const rows = Math.ceil(n / cols);
        const w = atomCanvas.width;
        const h = atomCanvas.height;
        const cellW = w / (cols + 1);
        const cellH = h / (rows + 1);
        const radius = Math.min(cellW, cellH) * 0.38;

        state.atoms = [];
        for (let i = 0; i < n; i++) {
            const col = i % cols;
            const row = Math.floor(i / cols);
            state.atoms.push({
                decayed: false,
                x: cellW * (col + 1),
                y: cellH * (row + 1),
                radius: radius,
                decayTick: -1,
                flash: 0
            });
        }
    }

    function resizeCanvases() {
        const wrapRect = atomGridWrapper.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        const aw = wrapRect.width;
        const ah = wrapRect.height || wrapRect.width;
        atomCanvas.width = aw * dpr;
        atomCanvas.height = ah * dpr;
        atomCanvas.style.width = aw + 'px';
        atomCanvas.style.height = ah + 'px';
        atomCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

        const curveWrap = curveCanvas.parentElement;
        const cRect = curveWrap.getBoundingClientRect();
        const cw = cRect.width;
        const ch = cRect.height || 350;
        curveCanvas.width = cw * dpr;
        curveCanvas.height = ch * dpr;
        curveCanvas.style.width = cw + 'px';
        curveCanvas.style.height = ch + 'px';
        curveCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    /* ===================== DRAWING: ATOM GRID ===================== */
    function drawAtomGrid() {
        const w = atomCanvas.width / (window.devicePixelRatio || 1);
        const h = atomCanvas.height / (window.devicePixelRatio || 1);
        atomCtx.clearRect(0, 0, w, h);

        // Background
        atomCtx.fillStyle = '#0d1117';
        atomCtx.fillRect(0, 0, w, h);

        // Subtle grid lines
        atomCtx.strokeStyle = 'rgba(255,255,255,0.03)';
        atomCtx.lineWidth = 0.5;
        for (let x = 0; x < w; x += 40) {
            atomCtx.beginPath();
            atomCtx.moveTo(x, 0);
            atomCtx.lineTo(x, h);
            atomCtx.stroke();
        }
        for (let y = 0; y < h; y += 40) {
            atomCtx.beginPath();
            atomCtx.moveTo(0, y);
            atomCtx.lineTo(w, y);
            atomCtx.stroke();
        }

        // Atoms
        for (const atom of state.atoms) {
            const r = atom.radius;

            if (atom.flash > 0) {
                // Flash effect on recent decay
                atomCtx.beginPath();
                atomCtx.arc(atom.x, atom.y, r * (1 + atom.flash * 0.5), 0, Math.PI * 2);
                atomCtx.fillStyle = `rgba(255, 160, 0, ${atom.flash * 0.4})`;
                atomCtx.fill();
                atom.flash = Math.max(0, atom.flash - 0.03);
            }

            atomCtx.beginPath();
            atomCtx.arc(atom.x, atom.y, r, 0, Math.PI * 2);

            if (atom.decayed) {
                atomCtx.fillStyle = '#3a3a3a';
                atomCtx.fill();
                atomCtx.strokeStyle = '#555';
                atomCtx.lineWidth = 0.5;
                atomCtx.stroke();
            } else {
                // Glow
                const grad = atomCtx.createRadialGradient(
                    atom.x - r * 0.25, atom.y - r * 0.25, r * 0.1,
                    atom.x, atom.y, r
                );
                grad.addColorStop(0, '#81c784');
                grad.addColorStop(0.7, '#43a047');
                grad.addColorStop(1, '#2e7d32');
                atomCtx.fillStyle = grad;
                atomCtx.fill();
                atomCtx.strokeStyle = '#1b5e20';
                atomCtx.lineWidth = 0.5;
                atomCtx.stroke();
            }
        }
    }

    /* ===================== DRAWING: DECAY CURVE ===================== */
    function drawDecayCurve() {
        const w = curveCanvas.width / (window.devicePixelRatio || 1);
        const h = curveCanvas.height / (window.devicePixelRatio || 1);
        const pad = { top: 30, right: 20, bottom: 45, left: 55 };
        const plotW = w - pad.left - pad.right;
        const plotH = h - pad.top - pad.bottom;

        curveCtx.clearRect(0, 0, w, h);
        curveCtx.fillStyle = '#fff';
        curveCtx.fillRect(0, 0, w, h);

        const n0 = state.sampleSize;
        const maxTick = Math.max(state.currentTick, 6);
        const maxTime = maxTick * state.halfLife;

        // Axes
        curveCtx.strokeStyle = '#333';
        curveCtx.lineWidth = 1.5;
        curveCtx.beginPath();
        curveCtx.moveTo(pad.left, pad.top);
        curveCtx.lineTo(pad.left, pad.top + plotH);
        curveCtx.lineTo(pad.left + plotW, pad.top + plotH);
        curveCtx.stroke();

        // Y-axis labels
        curveCtx.fillStyle = '#555';
        curveCtx.font = '11px ' + getComputedStyle(document.body).fontFamily;
        curveCtx.textAlign = 'right';
        curveCtx.textBaseline = 'middle';
        for (let i = 0; i <= 4; i++) {
            const val = n0 * (i / 4);
            const y = pad.top + plotH - (i / 4) * plotH;
            curveCtx.fillText(Math.round(val).toString(), pad.left - 8, y);
            // Grid line
            if (i > 0) {
                curveCtx.strokeStyle = '#e0e0e0';
                curveCtx.lineWidth = 0.5;
                curveCtx.beginPath();
                curveCtx.moveTo(pad.left, y);
                curveCtx.lineTo(pad.left + plotW, y);
                curveCtx.stroke();
            }
        }

        // X-axis labels
        curveCtx.textAlign = 'center';
        curveCtx.textBaseline = 'top';
        const xSteps = Math.min(maxTick, 8);
        for (let i = 0; i <= xSteps; i++) {
            const tickNum = Math.round((i / xSteps) * maxTick);
            const x = pad.left + (tickNum / maxTick) * plotW;
            const timeVal = tickNum * state.halfLife;
            curveCtx.fillStyle = '#555';
            curveCtx.fillText(timeVal + 's', x, pad.top + plotH + 8);

            // Tick marks
            curveCtx.strokeStyle = '#999';
            curveCtx.lineWidth = 1;
            curveCtx.beginPath();
            curveCtx.moveTo(x, pad.top + plotH);
            curveCtx.lineTo(x, pad.top + plotH + 4);
            curveCtx.stroke();
        }

        // Axis titles
        curveCtx.fillStyle = '#333';
        curveCtx.font = 'bold 12px ' + getComputedStyle(document.body).fontFamily;
        curveCtx.textAlign = 'center';
        curveCtx.fillText('Time', pad.left + plotW / 2, pad.top + plotH + 30);

        curveCtx.save();
        curveCtx.translate(14, pad.top + plotH / 2);
        curveCtx.rotate(-Math.PI / 2);
        curveCtx.fillText('Undecayed Atoms', 0, 0);
        curveCtx.restore();

        // Theoretical curve (dashed)
        curveCtx.strokeStyle = 'rgba(46, 125, 50, 0.3)';
        curveCtx.lineWidth = 1.5;
        curveCtx.setLineDash([5, 4]);
        curveCtx.beginPath();
        for (let px = 0; px <= plotW; px += 2) {
            const t = (px / plotW) * maxTick;
            let remaining;
            if (state.mode === 'atom') {
                remaining = n0 * Math.pow(0.5, t);
            } else {
                remaining = n0 * Math.pow(5 / 6, t);
            }
            const y = pad.top + plotH - (remaining / n0) * plotH;
            if (px === 0) curveCtx.moveTo(pad.left + px, y);
            else curveCtx.lineTo(pad.left + px, y);
        }
        curveCtx.stroke();
        curveCtx.setLineDash([]);

        // Half-life marker lines
        for (let hl = 1; hl <= maxTick; hl++) {
            const x = pad.left + (hl / maxTick) * plotW;
            let remaining;
            if (state.mode === 'atom') {
                remaining = n0 * Math.pow(0.5, hl);
            } else {
                remaining = n0 * Math.pow(5 / 6, hl);
            }
            const y = pad.top + plotH - (remaining / n0) * plotH;

            curveCtx.strokeStyle = 'rgba(255, 152, 0, 0.25)';
            curveCtx.lineWidth = 1;
            curveCtx.setLineDash([3, 3]);
            curveCtx.beginPath();
            curveCtx.moveTo(x, pad.top);
            curveCtx.lineTo(x, pad.top + plotH);
            curveCtx.stroke();
            curveCtx.setLineDash([]);

            // Small label at top
            if (hl <= 6) {
                curveCtx.fillStyle = 'rgba(255, 152, 0, 0.6)';
                curveCtx.font = '9px ' + getComputedStyle(document.body).fontFamily;
                curveCtx.textAlign = 'center';
                curveCtx.fillText('t\u00BD=' + hl, x, pad.top - 5);
            }
        }

        // Actual data points and line
        if (state.dataPoints.length > 0) {
            curveCtx.strokeStyle = '#2e7d32';
            curveCtx.lineWidth = 2.5;
            curveCtx.beginPath();
            for (let i = 0; i < state.dataPoints.length; i++) {
                const dp = state.dataPoints[i];
                const x = pad.left + (dp.tick / maxTick) * plotW;
                const y = pad.top + plotH - (dp.undecayed / n0) * plotH;
                if (i === 0) curveCtx.moveTo(x, y);
                else curveCtx.lineTo(x, y);
            }
            curveCtx.stroke();

            // Data points
            for (const dp of state.dataPoints) {
                const x = pad.left + (dp.tick / maxTick) * plotW;
                const y = pad.top + plotH - (dp.undecayed / n0) * plotH;
                curveCtx.beginPath();
                curveCtx.arc(x, y, 4, 0, Math.PI * 2);
                curveCtx.fillStyle = '#2e7d32';
                curveCtx.fill();
                curveCtx.strokeStyle = '#fff';
                curveCtx.lineWidth = 1.5;
                curveCtx.stroke();
            }
        }

        // Legend
        const legX = pad.left + plotW - 130;
        const legY = pad.top + 8;
        curveCtx.fillStyle = 'rgba(255,255,255,0.9)';
        curveCtx.fillRect(legX, legY, 126, 42);
        curveCtx.strokeStyle = '#ccc';
        curveCtx.lineWidth = 0.5;
        curveCtx.strokeRect(legX, legY, 126, 42);

        curveCtx.font = '10px ' + getComputedStyle(document.body).fontFamily;
        curveCtx.textAlign = 'left';

        // Theoretical
        curveCtx.strokeStyle = 'rgba(46, 125, 50, 0.4)';
        curveCtx.lineWidth = 1.5;
        curveCtx.setLineDash([4, 3]);
        curveCtx.beginPath();
        curveCtx.moveTo(legX + 6, legY + 12);
        curveCtx.lineTo(legX + 28, legY + 12);
        curveCtx.stroke();
        curveCtx.setLineDash([]);
        curveCtx.fillStyle = '#555';
        curveCtx.fillText('Theoretical', legX + 32, legY + 15);

        // Simulated
        curveCtx.strokeStyle = '#2e7d32';
        curveCtx.lineWidth = 2.5;
        curveCtx.beginPath();
        curveCtx.moveTo(legX + 6, legY + 30);
        curveCtx.lineTo(legX + 28, legY + 30);
        curveCtx.stroke();
        curveCtx.fillStyle = '#555';
        curveCtx.fillText('Simulated', legX + 32, legY + 33);
    }

    /* ===================== STATS UPDATE ===================== */
    function updateStats() {
        const undecayed = getUndecayed();
        const decayed = state.sampleSize - undecayed;
        const pct = (undecayed / state.sampleSize * 100).toFixed(1);

        statUndecayed.textContent = undecayed;
        statDecayed.textContent = decayed;
        statPercent.textContent = pct + '%';
        statHalfLives.textContent = state.currentTick;
        statElapsed.textContent = state.elapsed.toFixed(1) + 's';
        statActivity.textContent = state.lastTickDecays;

        tickLabel.textContent = 'Tick: ' + state.currentTick + ' | ' + undecayed + ' remaining';
    }

    /* ===================== SIMULATION TICK ===================== */
    function performTick() {
        const undecayedAtoms = state.atoms.filter(a => !a.decayed);
        let decayCount = 0;

        if (state.mode === 'atom') {
            // 50% chance per atom
            for (const atom of undecayedAtoms) {
                if (Math.random() < 0.5) {
                    atom.decayed = true;
                    atom.decayTick = state.currentTick + 1;
                    atom.flash = 1.0;
                    decayCount++;
                }
            }
        } else {
            // Dice mode: 1 in 6 chance
            for (const atom of undecayedAtoms) {
                const roll = Math.floor(Math.random() * 6) + 1;
                if (roll === 1) {
                    atom.decayed = true;
                    atom.decayTick = state.currentTick + 1;
                    atom.flash = 1.0;
                    decayCount++;
                }
            }
        }

        state.currentTick++;
        state.lastTickDecays = decayCount;
        state.elapsed = state.currentTick * state.halfLife;

        state.dataPoints.push({
            tick: state.currentTick,
            undecayed: getUndecayed(),
            elapsed: state.elapsed
        });

        updateStats();
        gridOverlay.textContent = 'Tick ' + state.currentTick + ': ' + decayCount + ' decayed';

        if (state.mode === 'dice') {
            diceDisplay.textContent = 'Dice: ' + decayCount + ' rolled a 1';
        }

        // Stop if all decayed
        if (getUndecayed() === 0) {
            stopSimulation();
            gridOverlay.textContent = 'All atoms decayed!';
        }
    }

    /* ===================== ANIMATION LOOP ===================== */
    let lastTimestamp = 0;

    function animLoop(timestamp) {
        if (!state.running || state.paused) {
            drawAtomGrid();
            drawDecayCurve();
            return;
        }

        if (!lastTimestamp) lastTimestamp = timestamp;
        const dt = (timestamp - lastTimestamp) * state.speed;
        lastTimestamp = timestamp;

        state.tickElapsed += dt;
        const tickDuration = state.halfLife * 1000; // ms

        // Update progress bar
        const progress = Math.min(state.tickElapsed / tickDuration, 1);
        tickProgress.style.width = (progress * 100) + '%';

        if (state.tickElapsed >= tickDuration) {
            state.tickElapsed -= tickDuration;
            performTick();
        }

        drawAtomGrid();
        drawDecayCurve();

        if (state.running) {
            state.animFrame = requestAnimationFrame(animLoop);
        }
    }

    /* ===================== CONTROLS ===================== */
    function initSimulation() {
        state.currentTick = 0;
        state.elapsed = 0;
        state.lastTickDecays = 0;
        state.tickElapsed = 0;
        state.dataPoints = [{ tick: 0, undecayed: state.sampleSize, elapsed: 0 }];

        resizeCanvases();
        layoutAtoms();
        updateStats();
        drawAtomGrid();
        drawDecayCurve();

        gridOverlay.textContent = 'Ready';
        tickProgress.style.width = '0%';
        diceDisplay.style.display = state.mode === 'dice' ? 'block' : 'none';
        if (state.mode === 'dice') {
            diceDisplay.textContent = 'Dice mode: 1/6 chance';
        }
    }

    function startSimulation() {
        if (state.running && !state.paused) return;

        if (!state.running) {
            // Fresh start
            state.running = true;
            state.paused = false;
        } else if (state.paused) {
            // Resume
            state.paused = false;
        }

        btnPlay.disabled = true;
        btnPause.disabled = false;
        halfLifeSlider.disabled = true;
        sampleSlider.disabled = true;

        lastTimestamp = 0;
        state.animFrame = requestAnimationFrame(animLoop);
    }

    function pauseSimulation() {
        state.paused = true;
        btnPlay.disabled = false;
        btnPause.disabled = true;
        gridOverlay.textContent = 'Paused (Tick ' + state.currentTick + ')';
    }

    function stopSimulation() {
        state.running = false;
        state.paused = false;
        if (state.animFrame) cancelAnimationFrame(state.animFrame);

        btnPlay.disabled = true;
        btnPause.disabled = true;
    }

    function resetSimulation() {
        stopSimulation();
        btnPlay.disabled = false;
        btnPause.disabled = true;
        halfLifeSlider.disabled = false;
        sampleSlider.disabled = false;
        initSimulation();
    }

    /* ===================== EVENT LISTENERS ===================== */
    halfLifeSlider.addEventListener('input', function() {
        state.halfLife = parseInt(this.value);
        halfLifeValue.textContent = this.value + 's';
    });

    sampleSlider.addEventListener('input', function() {
        state.sampleSize = parseInt(this.value);
        sampleValue.textContent = this.value;
        if (!state.running) initSimulation();
    });

    btnPlay.addEventListener('click', startSimulation);
    btnPause.addEventListener('click', pauseSimulation);
    btnReset.addEventListener('click', resetSimulation);

    // Speed buttons
    document.querySelectorAll('[data-speed]').forEach(function(btn) {
        btn.addEventListener('click', function() {
            document.querySelectorAll('[data-speed]').forEach(function(b) {
                b.classList.remove('active');
            });
            this.classList.add('active');
            state.speed = parseInt(this.dataset.speed);
        });
    });

    // Mode toggle
    document.querySelectorAll('[data-mode]').forEach(function(btn) {
        btn.addEventListener('click', function() {
            document.querySelectorAll('[data-mode]').forEach(function(b) {
                b.classList.remove('active');
            });
            this.classList.add('active');
            state.mode = this.dataset.mode;
            diceDisplay.style.display = state.mode === 'dice' ? 'block' : 'none';
            if (state.mode === 'dice') {
                diceDisplay.textContent = 'Dice mode: 1/6 chance';
            }
            if (!state.running) {
                drawDecayCurve();
            }
        });
    });

    // Info tabs
    document.querySelectorAll('.info-tab').forEach(function(tab) {
        tab.addEventListener('click', function() {
            document.querySelectorAll('.info-tab').forEach(function(t) {
                t.classList.remove('active');
            });
            document.querySelectorAll('.info-content').forEach(function(c) {
                c.classList.remove('active');
            });
            this.classList.add('active');
            var target = document.getElementById('info-' + this.dataset.info);
            if (target) target.classList.add('active');
        });
    });

    // Resize handling
    let resizeTimeout;
    window.addEventListener('resize', function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function() {
            resizeCanvases();
            layoutAtoms();
            // Re-apply decay state
            var currentAtoms = state.atoms;
            // layoutAtoms resets, so we re-decay based on dataPoints
            // Simpler: just re-layout and keep decayed state via index tracking
        }, 150);
    });

    // Better resize: preserve decay state
    var originalResize = window.onresize;
    window.addEventListener('resize', function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function() {
            var decayedIndices = [];
            var flashStates = [];
            for (var i = 0; i < state.atoms.length; i++) {
                decayedIndices.push(state.atoms[i].decayed);
                flashStates.push(state.atoms[i].flash);
            }

            resizeCanvases();
            layoutAtoms();

            for (var j = 0; j < state.atoms.length && j < decayedIndices.length; j++) {
                state.atoms[j].decayed = decayedIndices[j];
                state.atoms[j].flash = flashStates[j];
            }

            drawAtomGrid();
            drawDecayCurve();
        }, 150);
    });

    /* ===================== INIT ===================== */
    initSimulation();

})();
</script>

</body>
</html>