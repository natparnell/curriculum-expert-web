<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Forces &amp; Motion Simulator</title>
<style>
:root {
  --bg-primary: #1a2332;
  --bg-secondary: #243447;
  --bg-panel: #2c3e50;
  --bg-card: #34495e;
  --text-primary: #ecf0f1;
  --text-secondary: #bdc3c7;
  --text-muted: #95a5a6;
  --accent: #3498db;
  --accent-hover: #2980b9;
  --force-right: #e74c3c;
  --force-left: #3498db;
  --force-up: #2ecc71;
  --force-down: #e67e22;
  --force-friction: #9b59b6;
  --force-gravity: #f39c12;
  --force-resultant: #1abc9c;
  --border: #4a6274;
  --success: #27ae60;
  --warning: #f39c12;
  --radius: 8px;
  --shadow: 0 2px 8px rgba(0,0,0,0.3);
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg-primary);
  color: var(--text-primary);
  line-height: 1.5;
  min-height: 100vh;
}

header {
  position: sticky;
  top: 0;
  z-index: 100;
  background: linear-gradient(135deg, var(--bg-secondary), var(--bg-panel));
  padding: 14px 24px;
  border-bottom: 2px solid var(--accent);
  box-shadow: var(--shadow);
}

header h1 {
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--text-primary);
}

header p {
  font-size: 0.85rem;
  color: var(--text-secondary);
  margin-top: 2px;
}

.app-layout {
  display: grid;
  grid-template-columns: 280px 1fr 300px;
  gap: 16px;
  padding: 16px;
  max-width: 1600px;
  margin: 0 auto;
}

@media (max-width: 1100px) {
  .app-layout { grid-template-columns: 1fr; }
}

.panel {
  background: var(--bg-secondary);
  border-radius: var(--radius);
  padding: 16px;
  box-shadow: var(--shadow);
}

.panel h2 {
  font-size: 1rem;
  font-weight: 600;
  color: var(--accent);
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.panel h3 {
  font-size: 0.85rem;
  font-weight: 600;
  color: var(--text-secondary);
  margin: 12px 0 6px;
}

/* Controls Panel */
.control-group { margin-bottom: 14px; }

.control-group label {
  display: block;
  font-size: 0.8rem;
  color: var(--text-secondary);
  margin-bottom: 4px;
}

.control-group .value-display {
  font-weight: 600;
  color: var(--accent);
  float: right;
}

input[type="range"] {
  width: 100%;
  height: 6px;
  -webkit-appearance: none;
  appearance: none;
  background: var(--bg-card);
  border-radius: 3px;
  outline: none;
  cursor: pointer;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
}

.direction-btns {
  display: grid;
  grid-template-areas: ". up ." "left . right" ". down .";
  grid-template-columns: repeat(3, 1fr);
  gap: 4px;
  max-width: 180px;
  margin: 8px auto;
}

.dir-btn {
  padding: 8px;
  border: none;
  border-radius: var(--radius);
  font-size: 0.8rem;
  font-weight: 600;
  cursor: pointer;
  color: #fff;
  transition: opacity 0.2s;
}

.dir-btn:hover { opacity: 0.85; }
.dir-btn[data-dir="up"] { grid-area: up; background: var(--force-up); }
.dir-btn[data-dir="down"] { grid-area: down; background: var(--force-down); }
.dir-btn[data-dir="left"] { grid-area: left; background: var(--force-left); }
.dir-btn[data-dir="right"] { grid-area: right; background: var(--force-right); }

.force-list {
  list-style: none;
  max-height: 180px;
  overflow-y: auto;
}

.force-item {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 8px;
  margin-bottom: 4px;
  background: var(--bg-card);
  border-radius: 4px;
  font-size: 0.78rem;
}

.force-item .dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  flex-shrink: 0;
}

.force-item input[type="range"] { flex: 1; height: 4px; }

.force-item .mag { min-width: 36px; text-align: right; font-weight: 600; }

.force-item .remove-btn {
  background: none;
  border: none;
  color: var(--force-right);
  cursor: pointer;
  font-size: 1rem;
  line-height: 1;
  padding: 0 2px;
}

.toggle-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 8px;
}

.toggle-row span { font-size: 0.8rem; color: var(--text-secondary); }

.toggle {
  position: relative;
  width: 40px;
  height: 22px;
  cursor: pointer;
}

.toggle input { display: none; }

.toggle .slider {
  position: absolute;
  inset: 0;
  background: var(--bg-card);
  border-radius: 11px;
  transition: background 0.3s;
}

.toggle .slider::before {
  content: '';
  position: absolute;
  width: 16px;
  height: 16px;
  left: 3px;
  top: 3px;
  background: var(--text-secondary);
  border-radius: 50%;
  transition: transform 0.3s, background 0.3s;
}

.toggle input:checked + .slider { background: var(--accent); }
.toggle input:checked + .slider::before { transform: translateX(18px); background: #fff; }

.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding: 8px 16px;
  border: none;
  border-radius: var(--radius);
  font-size: 0.85rem;
  font-weight: 600;
  cursor: pointer;
  transition: background 0.2s, transform 0.1s;
  color: #fff;
}

.btn:active { transform: scale(0.97); }
.btn-primary { background: var(--accent); }
.btn-primary:hover { background: var(--accent-hover); }
.btn-success { background: var(--success); }
.btn-success:hover { background: #219a52; }
.btn-warning { background: var(--warning); }
.btn-warning:hover { background: #d68910; }
.btn-danger { background: var(--force-right); }
.btn-danger:hover { background: #c0392b; }

.btn-row { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 10px; }

/* Canvas Area */
.canvas-area { display: flex; flex-direction: column; gap: 12px; }

.sim-canvas-wrap {
  position: relative;
  background: var(--bg-panel);
  border-radius: var(--radius);
  overflow: hidden;
  border: 1px solid var(--border);
}

canvas#simCanvas {
  display: block;
  width: 100%;
  height: 380px;
}

.readout-bar {
  display: flex;
  gap: 16px;
  flex-wrap: wrap;
  padding: 10px 14px;
  background: var(--bg-card);
  border-radius: var(--radius);
  font-size: 0.8rem;
}

.readout-item {
  display: flex;
  align-items: center;
  gap: 4px;
}

.readout-item .label { color: var(--text-muted); }
.readout-item .val { font-weight: 700; color: var(--text-primary); }

.equation-bar {
  padding: 12px 16px;
  background: var(--bg-card);
  border-radius: var(--radius);
  text-align: center;
  font-size: 1rem;
}

.equation-bar .eq {
  font-weight: 700;
  color: var(--force-resultant);
  font-size: 1.15rem;
}

.graphs-row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

@media (max-width: 700px) {
  .graphs-row { grid-template-columns: 1fr; }
}

.graph-wrap {
  background: var(--bg-panel);
  border-radius: var(--radius);
  padding: 10px;
  border: 1px solid var(--border);
}

.graph-wrap h3 {
  font-size: 0.78rem;
  color: var(--text-muted);
  margin-bottom: 6px;
  text-align: center;
}

canvas.graph {
  display: block;
  width: 100%;
  height: 160px;
  background: var(--bg-primary);
  border-radius: 4px;
}

/* Presets */
.preset-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 6px;
}

.preset-btn {
  padding: 8px;
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  color: var(--text-primary);
  font-size: 0.75rem;
  cursor: pointer;
  text-align: center;
  transition: border-color 0.2s, background 0.2s;
}

.preset-btn:hover {
  border-color: var(--accent);
  background: var(--bg-panel);
}

/* Info Panel */
.info-section { margin-bottom: 14px; }

.info-section h3 {
  font-size: 0.85rem;
  color: var(--warning);
  margin-bottom: 4px;
}

.info-section p, .info-section li {
  font-size: 0.78rem;
  color: var(--text-secondary);
  line-height: 1.6;
}

.info-section ul {
  padding-left: 16px;
  margin-top: 4px;
}

.law-badge {
  display: inline-block;
  background: var(--accent);
  color: #fff;
  font-size: 0.7rem;
  font-weight: 700;
  padding: 2px 8px;
  border-radius: 10px;
  margin-right: 6px;
}

.scrollable-info {
  max-height: calc(100vh - 140px);
  overflow-y: auto;
}

.scrollable-info::-webkit-scrollbar { width: 5px; }
.scrollable-info::-webkit-scrollbar-track { background: transparent; }
.scrollable-info::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
</style>
</head>
<body>

<header>
  <h1>Forces &amp; Motion Simulator</h1>
  <p>Interactive free body diagrams, resultant force calculations, and Newton's laws in action</p>
</header>

<div class="app-layout">
  <!-- LEFT: Controls -->
  <div class="panel" id="controlsPanel">
    <h2>Controls</h2>

    <h3>Add Forces</h3>
    <div class="direction-btns">
      <button class="dir-btn" data-dir="up">Up</button>
      <button class="dir-btn" data-dir="left">Left</button>
      <button class="dir-btn" data-dir="right">Right</button>
      <button class="dir-btn" data-dir="down">Down</button>
    </div>

    <h3>Active Forces</h3>
    <ul class="force-list" id="forceList"></ul>

    <h3>Object Mass</h3>
    <div class="control-group">
      <label>Mass <span class="value-display" id="massVal">10 kg</span></label>
      <input type="range" id="massSlider" min="1" max="50" value="10">
    </div>

    <h3>Environment</h3>
    <div class="toggle-row">
      <span>Gravity (9.8 m/s&sup2;)</span>
      <label class="toggle">
        <input type="checkbox" id="gravityToggle">
        <span class="slider"></span>
      </label>
    </div>
    <div class="toggle-row">
      <span>Friction</span>
      <label class="toggle">
        <input type="checkbox" id="frictionToggle">
        <span class="slider"></span>
      </label>
    </div>
    <div class="control-group" id="frictionGroup" style="display:none;">
      <label>Coefficient <span class="value-display" id="frictionVal">0.30</span></label>
      <input type="range" id="frictionSlider" min="0" max="100" value="30">
    </div>

    <h3>Preset Scenarios</h3>
    <div class="preset-grid">
      <button class="preset-btn" data-preset="falling">Falling Object</button>
      <button class="preset-btn" data-preset="braking">Car Braking</button>
      <button class="preset-btn" data-preset="slope">Object on Slope</button>
      <button class="preset-btn" data-preset="tugofwar">Tug of War</button>
    </div>

    <div class="btn-row">
      <button class="btn btn-success" id="simulateBtn">Simulate</button>
      <button class="btn btn-warning" id="resetBtn">Reset</button>
      <button class="btn btn-danger" id="clearBtn">Clear All</button>
    </div>
  </div>

  <!-- CENTRE: Canvas & Graphs -->
  <div class="canvas-area">
    <div class="sim-canvas-wrap">
      <canvas id="simCanvas"></canvas>
    </div>

    <div class="equation-bar">
      <span>F = ma :&nbsp;</span>
      <span class="eq" id="eqDisplay">0 N = 10 kg &times; 0 m/s&sup2;</span>
    </div>

    <div class="readout-bar">
      <div class="readout-item"><span class="label">Resultant F:</span><span class="val" id="rForce">0 N</span></div>
      <div class="readout-item"><span class="label">Acceleration:</span><span class="val" id="rAccel">0 m/s&sup2;</span></div>
      <div class="readout-item"><span class="label">Velocity:</span><span class="val" id="rVel">0 m/s</span></div>
      <div class="readout-item"><span class="label">Distance:</span><span class="val" id="rDist">0 m</span></div>
      <div class="readout-item"><span class="label">Time:</span><span class="val" id="rTime">0.0 s</span></div>
    </div>

    <div class="graphs-row">
      <div class="graph-wrap">
        <h3>Distance vs Time</h3>
        <canvas class="graph" id="distGraph"></canvas>
      </div>
      <div class="graph-wrap">
        <h3>Velocity vs Time</h3>
        <canvas class="graph" id="velGraph"></canvas>
      </div>
    </div>
  </div>

  <!-- RIGHT: Info -->
  <div class="panel">
    <h2>Newton's Laws</h2>
    <div class="scrollable-info">
      <div class="info-section">
        <h3><span class="law-badge">1st</span>Law of Inertia</h3>
        <p>An object at rest stays at rest, and an object in motion stays in motion at constant velocity, unless acted upon by an unbalanced force.</p>
        <p style="margin-top:4px;">Try setting all forces to zero and hitting Simulate: the object will not accelerate.</p>
      </div>
      <div class="info-section">
        <h3><span class="law-badge">2nd</span>F = ma</h3>
        <p>The acceleration of an object is proportional to the net force acting on it and inversely proportional to its mass.</p>
        <ul>
          <li>Double the force = double the acceleration</li>
          <li>Double the mass = half the acceleration</li>
        </ul>
      </div>
      <div class="info-section">
        <h3><span class="law-badge">3rd</span>Action &amp; Reaction</h3>
        <p>For every action there is an equal and opposite reaction. The forces act on different objects.</p>
        <p style="margin-top:4px;">When gravity pulls the box down, the surface pushes back up with a normal force.</p>
      </div>
      <div class="info-section">
        <h3>Balanced vs Unbalanced</h3>
        <p><strong>Balanced forces</strong> have a resultant of 0 N. The object stays at rest or moves at constant velocity (1st Law).</p>
        <p><strong>Unbalanced forces</strong> produce a non-zero resultant, causing acceleration (2nd Law).</p>
      </div>
      <div class="info-section">
        <h3>Friction</h3>
        <p>Friction is a contact force that opposes motion. Its magnitude depends on:</p>
        <ul>
          <li>The coefficient of friction between surfaces</li>
          <li>The normal contact force (weight on a flat surface)</li>
        </ul>
        <p style="margin-top:4px;">Formula: F<sub>friction</sub> = &mu; &times; N</p>
      </div>
      <div class="info-section">
        <h3>Key Equations</h3>
        <ul>
          <li>Weight: W = m &times; g</li>
          <li>Net force: F<sub>net</sub> = &Sigma;F</li>
          <li>Acceleration: a = F<sub>net</sub> / m</li>
          <li>v = u + at</li>
          <li>s = ut + &frac12;at&sup2;</li>
        </ul>
      </div>
    </div>
  </div>
</div>

<script>
(function() {
  'use strict';

  // --- State ---
  const state = {
    forces: [],
    mass: 10,
    gravity: false,
    friction: false,
    frictionCoeff: 0.3,
    simulating: false,
    simTime: 0,
    velocity: { x: 0, y: 0 },
    position: { x: 0, y: 0 },
    objectScreenPos: { x: 0, y: 0 },
    graphData: { time: [], dist: [], vel: [] },
    animId: null
  };

  let nextForceId = 1;

  const COLORS = {
    right: '#e74c3c',
    left: '#3498db',
    up: '#2ecc71',
    down: '#e67e22'
  };

  const DIR_VECTORS = {
    right: { x: 1, y: 0 },
    left: { x: -1, y: 0 },
    up: { x: 0, y: -1 },
    down: { x: 0, y: 1 }
  };

  // --- DOM refs ---
  const simCanvas = document.getElementById('simCanvas');
  const simCtx = simCanvas.getContext('2d');
  const distCanvas = document.getElementById('distGraph');
  const distCtx = distCanvas.getContext('2d');
  const velCanvas = document.getElementById('velGraph');
  const velCtx = velCanvas.getContext('2d');
  const forceListEl = document.getElementById('forceList');
  const massSlider = document.getElementById('massSlider');
  const massVal = document.getElementById('massVal');
  const gravityToggle = document.getElementById('gravityToggle');
  const frictionToggle = document.getElementById('frictionToggle');
  const frictionGroup = document.getElementById('frictionGroup');
  const frictionSlider = document.getElementById('frictionSlider');
  const frictionVal = document.getElementById('frictionVal');
  const eqDisplay = document.getElementById('eqDisplay');
  const rForce = document.getElementById('rForce');
  const rAccel = document.getElementById('rAccel');
  const rVel = document.getElementById('rVel');
  const rDist = document.getElementById('rDist');
  const rTime = document.getElementById('rTime');

  // --- Canvas sizing ---
  function resizeCanvas(canvas) {
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * window.devicePixelRatio;
    canvas.height = rect.height * window.devicePixelRatio;
    const ctx = canvas.getContext('2d');
    ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
  }

  function resizeAll() {
    resizeCanvas(simCanvas);
    resizeCanvas(distCanvas);
    resizeCanvas(velCanvas);
    drawFBD();
    drawGraphs();
  }

  window.addEventListener('resize', resizeAll);
  setTimeout(resizeAll, 50);

  // --- Force management ---
  function addForce(dir, magnitude) {
    const f = { id: nextForceId++, dir, magnitude: magnitude || 30 };
    state.forces.push(f);
    renderForceList();
    updateCalculations();
    drawFBD();
  }

  function removeForce(id) {
    state.forces = state.forces.filter(f => f.id !== id);
    renderForceList();
    updateCalculations();
    drawFBD();
  }

  function renderForceList() {
    forceListEl.innerHTML = '';
    state.forces.forEach(f => {
      const li = document.createElement('li');
      li.className = 'force-item';
      li.innerHTML = `
        <span class="dot" style="background:${COLORS[f.dir]}"></span>
        <span style="min-width:36px;font-size:0.75rem;">${f.dir.charAt(0).toUpperCase() + f.dir.slice(1)}</span>
        <input type="range" min="0" max="100" value="${f.magnitude}" data-id="${f.id}">
        <span class="mag">${f.magnitude}N</span>
        <button class="remove-btn" data-id="${f.id}">&times;</button>
      `;
      forceListEl.appendChild(li);
    });

    forceListEl.querySelectorAll('input[type="range"]').forEach(inp => {
      inp.addEventListener('input', (e) => {
        const id = parseInt(e.target.dataset.id);
        const force = state.forces.find(f => f.id === id);
        if (force) {
          force.magnitude = parseInt(e.target.value);
          e.target.parentElement.querySelector('.mag').textContent = force.magnitude + 'N';
          updateCalculations();
          drawFBD();
        }
      });
    });

    forceListEl.querySelectorAll('.remove-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        removeForce(parseInt(e.target.dataset.id));
      });
    });
  }

  // --- Calculations ---
  function getNetForce() {
    let fx = 0, fy = 0;

    state.forces.forEach(f => {
      const v = DIR_VECTORS[f.dir];
      fx += v.x * f.magnitude;
      fy += v.y * f.magnitude;
    });

    if (state.gravity) {
      fy += state.mass * 9.8;
    }

    if (state.friction) {
      const normalForce = state.gravity ? state.mass * 9.8 : state.mass * 9.8;
      const frictionMag = state.frictionCoeff * normalForce;
      const speed = Math.sqrt(fx * fx + fy * fy);
      if (speed > 0.01) {
        const frictionApplied = Math.min(frictionMag, Math.abs(fx));
        if (fx > 0) fx -= frictionApplied;
        else if (fx < 0) fx += frictionApplied;
        else {
          // no horizontal component
        }
      }
    }

    return { x: fx, y: fy };
  }

  function updateCalculations() {
    const net = getNetForce();
    const fMag = Math.sqrt(net.x * net.x + net.y * net.y);
    const accel = fMag / state.mass;

    rForce.textContent = fMag.toFixed(1) + ' N';
    rAccel.textContent = accel.toFixed(2) + ' m/s\u00B2';

    const dir = fMag > 0.01 ? ` (${getAngleLabel(net)})` : '';
    eqDisplay.innerHTML = `${fMag.toFixed(1)} N = ${state.mass} kg &times; ${accel.toFixed(2)} m/s&sup2;${dir}`;
  }

  function getAngleLabel(net) {
    if (Math.abs(net.x) < 0.01 && Math.abs(net.y) < 0.01) return 'none';
    const labels = [];
    if (net.y < -0.5) labels.push('up');
    if (net.y > 0.5) labels.push('down');
    if (net.x < -0.5) labels.push('left');
    if (net.x > 0.5) labels.push('right');
    return labels.join('-') || 'none';
  }

  // --- Drawing: Free Body Diagram ---
  function drawFBD() {
    const w = simCanvas.getBoundingClientRect().width;
    const h = simCanvas.getBoundingClientRect().height;
    const ctx = simCtx;
    ctx.clearRect(0, 0, w, h);

    // Ground line
    ctx.strokeStyle = '#4a6274';
    ctx.lineWidth = 1;
    ctx.setLineDash([6, 4]);
    ctx.beginPath();
    ctx.moveTo(0, h * 0.7);
    ctx.lineTo(w, h * 0.7);
    ctx.stroke();
    ctx.setLineDash([]);

    // Object position
    let objX, objY;
    if (state.simulating) {
      objX = state.objectScreenPos.x;
      objY = state.objectScreenPos.y;
    } else {
      objX = w / 2;
      objY = h * 0.7 - 30;
      state.objectScreenPos.x = objX;
      state.objectScreenPos.y = objY;
    }

    // Draw object (box)
    const boxW = 56;
    const boxH = 44;
    ctx.fillStyle = '#5d6d7e';
    ctx.strokeStyle = '#85929e';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(objX - boxW / 2, objY - boxH / 2, boxW, boxH, 4);
    ctx.fill();
    ctx.stroke();

    // Mass label on object
    ctx.fillStyle = '#fff';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(state.mass + ' kg', objX, objY);

    // Draw applied force arrows
    state.forces.forEach(f => {
      if (f.magnitude < 1) return;
      const v = DIR_VECTORS[f.dir];
      const len = Math.max(20, f.magnitude * 1.2);
      const startX = objX + v.x * (boxW / 2 + 2);
      const startY = objY + v.y * (boxH / 2 + 2);
      const endX = startX + v.x * len;
      const endY = startY + v.y * len;
      drawArrow(ctx, startX, startY, endX, endY, COLORS[f.dir], 3);
      // Label
      const lx = endX + v.x * 10;
      const ly = endY + v.y * 12;
      ctx.fillStyle = COLORS[f.dir];
      ctx.font = 'bold 11px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(f.magnitude + ' N', lx, ly);
    });

    // Gravity arrow
    if (state.gravity) {
      const gForce = state.mass * 9.8;
      const gLen = Math.max(20, gForce * 0.6);
      const sy = objY + boxH / 2 + 2;
      drawArrow(ctx, objX, sy, objX, sy + gLen, '#f39c12', 3);
      ctx.fillStyle = '#f39c12';
      ctx.font = 'bold 11px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('W=' + gForce.toFixed(0) + 'N', objX + 36, sy + gLen / 2);
    }

    // Friction arrow (if applicable)
    if (state.friction) {
      const net = { x: 0, y: 0 };
      state.forces.forEach(f => {
        const v = DIR_VECTORS[f.dir];
        net.x += v.x * f.magnitude;
      });
      if (Math.abs(net.x) > 0.5) {
        const normalForce = state.mass * 9.8;
        const fMag = Math.min(state.frictionCoeff * normalForce, Math.abs(net.x));
        const fDir = net.x > 0 ? -1 : 1;
        const fLen = Math.max(15, fMag * 1.0);
        const startX = objX + fDir * (boxW / 2 + 2);
        drawArrow(ctx, startX, objY, startX + fDir * fLen, objY, '#9b59b6', 2);
        ctx.fillStyle = '#9b59b6';
        ctx.font = 'bold 10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('f=' + fMag.toFixed(0) + 'N', startX + fDir * fLen + fDir * 24, objY - 10);
      }
    }

    // Normal force (when gravity on and object on ground)
    if (state.gravity && !state.simulating) {
      const nForce = state.mass * 9.8;
      const nLen = Math.max(20, nForce * 0.6);
      const sy = objY - boxH / 2 - 2;
      drawArrow(ctx, objX, sy, objX, sy - nLen, '#1abc9c', 2);
      ctx.fillStyle = '#1abc9c';
      ctx.font = 'bold 10px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('N=' + nForce.toFixed(0) + 'N', objX - 38, sy - nLen / 2);
    }

    // Resultant force arrow
    const resultant = getNetForce();
    const rMag = Math.sqrt(resultant.x * resultant.x + resultant.y * resultant.y);
    if (rMag > 0.5) {
      const rLen = Math.max(25, rMag * 0.8);
      const nx = resultant.x / rMag;
      const ny = resultant.y / rMag;
      const sx = objX + nx * (boxW / 2 + 10);
      const sy = objY + ny * (boxH / 2 + 10);
      ctx.setLineDash([4, 3]);
      drawArrow(ctx, sx, sy, sx + nx * rLen, sy + ny * rLen, '#1abc9c', 3);
      ctx.setLineDash([]);
      ctx.fillStyle = '#1abc9c';
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('R=' + rMag.toFixed(1) + 'N', sx + nx * (rLen + 24), sy + ny * (rLen + 14));
    }
  }

  function drawArrow(ctx, x1, y1, x2, y2, color, width) {
    const headLen = 10;
    const dx = x2 - x1;
    const dy = y2 - y1;
    const angle = Math.atan2(dy, dx);

    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = width;
    ctx.lineCap = 'round';

    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(x2, y2);
    ctx.lineTo(x2 - headLen * Math.cos(angle - Math.PI / 6), y2 - headLen * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(x2 - headLen * Math.cos(angle + Math.PI / 6), y2 - headLen * Math.sin(angle + Math.PI / 6));
    ctx.closePath();
    ctx.fill();
  }

  // --- Graphs ---
  function drawGraphs() {
    drawGraph(distCtx, distCanvas, state.graphData.time, state.graphData.dist, '#3498db', 'Distance (m)');
    drawGraph(velCtx, velCanvas, state.graphData.time, state.graphData.vel, '#e74c3c', 'Velocity (m/s)');
  }

  function drawGraph(ctx, canvas, xData, yData, color, yLabel) {
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const pad = { l: 48, r: 12, t: 10, b: 26 };
    const gw = w - pad.l - pad.r;
    const gh = h - pad.t - pad.b;

    ctx.clearRect(0, 0, w, h);

    // Axes
    ctx.strokeStyle = '#4a6274';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad.l, pad.t);
    ctx.lineTo(pad.l, pad.t + gh);
    ctx.lineTo(pad.l + gw, pad.t + gh);
    ctx.stroke();

    // Labels
    ctx.fillStyle = '#95a5a6';
    ctx.font = '9px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Time (s)', pad.l + gw / 2, h - 2);
    ctx.save();
    ctx.translate(12, pad.t + gh / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();

    if (xData.length < 2) return;

    const maxX = Math.max(...xData, 1);
    const maxY = Math.max(...yData.map(Math.abs), 1);
    const minY = Math.min(...yData, 0);
    const yRange = Math.max(maxY - minY, 1);

    // Grid lines
    ctx.strokeStyle = '#2c3e50';
    ctx.lineWidth = 0.5;
    for (let i = 0; i <= 4; i++) {
      const yPos = pad.t + gh - (i / 4) * gh;
      ctx.beginPath();
      ctx.moveTo(pad.l, yPos);
      ctx.lineTo(pad.l + gw, yPos);
      ctx.stroke();
      ctx.fillStyle = '#7f8c8d';
      ctx.font = '9px sans-serif';
      ctx.textAlign = 'right';
      const val = minY + (i / 4) * yRange;
      ctx.fillText(val.toFixed(1), pad.l - 4, yPos + 3);
    }

    // Tick labels on x
    for (let i = 0; i <= 4; i++) {
      const xPos = pad.l + (i / 4) * gw;
      ctx.fillStyle = '#7f8c8d';
      ctx.font = '9px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText((maxX * i / 4).toFixed(1), xPos, pad.t + gh + 14);
    }

    // Plot line
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.lineJoin = 'round';
    ctx.beginPath();
    for (let i = 0; i < xData.length; i++) {
      const px = pad.l + (xData[i] / maxX) * gw;
      const py = pad.t + gh - ((yData[i] - minY) / yRange) * gh;
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.stroke();
  }

  // --- Simulation ---
  function startSimulation() {
    if (state.simulating) return;

    state.simulating = true;
    state.simTime = 0;
    state.velocity = { x: 0, y: 0 };
    state.position = { x: 0, y: 0 };
    state.graphData = { time: [0], dist: [0], vel: [0] };

    const w = simCanvas.getBoundingClientRect().width;
    const h = simCanvas.getBoundingClientRect().height;
    state.objectScreenPos.x = w / 2;
    state.objectScreenPos.y = h * 0.7 - 30;

    document.getElementById('simulateBtn').textContent = 'Running...';
    document.getElementById('simulateBtn').disabled = true;

    const net = getNetForce();
    const accelX = net.x / state.mass;
    const accelY = net.y / state.mass;
    const maxTime = 10;
    let lastTs = null;

    function frame(ts) {
      if (!state.simulating) return;
      if (!lastTs) lastTs = ts;
      const dt = Math.min((ts - lastTs) / 1000, 0.05);
      lastTs = ts;

      state.simTime += dt;
      if (state.simTime > maxTime) {
        stopSimulation();
        return;
      }

      state.velocity.x += accelX * dt;
      state.velocity.y += accelY * dt;
      state.position.x += state.velocity.x * dt;
      state.position.y += state.velocity.y * dt;

      const speed = Math.sqrt(state.velocity.x ** 2 + state.velocity.y ** 2);
      const dist = Math.sqrt(state.position.x ** 2 + state.position.y ** 2);

      // Update screen position (scaled)
      const cw = simCanvas.getBoundingClientRect().width;
      const ch = simCanvas.getBoundingClientRect().height;
      const scale = 2.0;
      let sx = cw / 2 + state.position.x * scale;
      let sy = ch * 0.7 - 30 + state.position.y * scale;

      // Clamp to canvas bounds
      sx = Math.max(40, Math.min(cw - 40, sx));
      sy = Math.max(30, Math.min(ch - 20, sy));
      state.objectScreenPos.x = sx;
      state.objectScreenPos.y = sy;

      // Record graph data (sample every ~0.1s)
      if (state.graphData.time.length === 0 ||
          state.simTime - state.graphData.time[state.graphData.time.length - 1] >= 0.08) {
        state.graphData.time.push(state.simTime);
        state.graphData.dist.push(dist);
        state.graphData.vel.push(speed);
      }

      // Update readouts
      rVel.textContent = speed.toFixed(2) + ' m/s';
      rDist.textContent = dist.toFixed(2) + ' m';
      rTime.textContent = state.simTime.toFixed(1) + ' s';

      drawFBD();
      drawGraphs();

      state.animId = requestAnimationFrame(frame);
    }

    state.animId = requestAnimationFrame(frame);
  }

  function stopSimulation() {
    state.simulating = false;
    if (state.animId) {
      cancelAnimationFrame(state.animId);
      state.animId = null;
    }
    document.getElementById('simulateBtn').textContent = 'Simulate';
    document.getElementById('simulateBtn').disabled = false;
  }

  function resetSim() {
    stopSimulation();
    state.simTime = 0;
    state.velocity = { x: 0, y: 0 };
    state.position = { x: 0, y: 0 };
    state.graphData = { time: [], dist: [], vel: [] };
    rVel.textContent = '0 m/s';
    rDist.textContent = '0 m';
    rTime.textContent = '0.0 s';
    drawFBD();
    drawGraphs();
  }

  function clearAll() {
    resetSim();
    state.forces = [];
    state.mass = 10;
    state.gravity = false;
    state.friction = false;
    state.frictionCoeff = 0.3;
    massSlider.value = 10;
    massVal.textContent = '10 kg';
    gravityToggle.checked = false;
    frictionToggle.checked = false;
    frictionSlider.value = 30;
    frictionVal.textContent = '0.30';
    frictionGroup.style.display = 'none';
    renderForceList();
    updateCalculations();
    drawFBD();
    drawGraphs();
  }

  // --- Presets ---
  function loadPreset(name) {
    clearAll();
    switch (name) {
      case 'falling':
        state.mass = 5;
        massSlider.value = 5;
        massVal.textContent = '5 kg';
        state.gravity = true;
        gravityToggle.checked = true;
        break;

      case 'braking':
        state.mass = 20;
        massSlider.value = 20;
        massVal.textContent = '20 kg';
        state.friction = true;
        frictionToggle.checked = true;
        state.frictionCoeff = 0.7;
        frictionSlider.value = 70;
        frictionVal.textContent = '0.70';
        frictionGroup.style.display = 'block';
        addForce('right', 80);
        break;

      case 'slope':
        state.mass = 10;
        massSlider.value = 10;
        massVal.textContent = '10 kg';
        state.gravity = true;
        gravityToggle.checked = true;
        state.friction = true;
        frictionToggle.checked = true;
        state.frictionCoeff = 0.2;
        frictionSlider.value = 20;
        frictionVal.textContent = '0.20';
        frictionGroup.style.display = 'block';
        addForce('right', 40);
        addForce('down', 20);
        break;

      case 'tugofwar':
        state.mass = 15;
        massSlider.value = 15;
        massVal.textContent = '15 kg';
        addForce('left', 60);
        addForce('right', 75);
        break;
    }
    updateCalculations();
    drawFBD();
  }

  // --- Event Listeners ---
  document.querySelectorAll('.dir-btn').forEach(btn => {
    btn.addEventListener('click', () => addForce(btn.dataset.dir));
  });

  massSlider.addEventListener('input', () => {
    state.mass = parseInt(massSlider.value);
    massVal.textContent = state.mass + ' kg';
    updateCalculations();
    drawFBD();
  });

  gravityToggle.addEventListener('change', () => {
    state.gravity = gravityToggle.checked;
    updateCalculations();
    drawFBD();
  });

  frictionToggle.addEventListener('change', () => {
    state.friction = frictionToggle.checked;
    frictionGroup.style.display = state.friction ? 'block' : 'none';
    updateCalculations();
    drawFBD();
  });

  frictionSlider.addEventListener('input', () => {
    state.frictionCoeff = parseInt(frictionSlider.value) / 100;
    frictionVal.textContent = state.frictionCoeff.toFixed(2);
    updateCalculations();
    drawFBD();
  });

  document.getElementById('simulateBtn').addEventListener('click', startSimulation);
  document.getElementById('resetBtn').addEventListener('click', resetSim);
  document.getElementById('clearBtn').addEventListener('click', clearAll);

  document.querySelectorAll('.preset-btn').forEach(btn => {
    btn.addEventListener('click', () => loadPreset(btn.dataset.preset));
  });

  // --- Initialise ---
  updateCalculations();
  drawFBD();
  drawGraphs();

})();
</script>
</body>
</html>
