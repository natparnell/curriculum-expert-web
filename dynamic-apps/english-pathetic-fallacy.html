<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pathetic Fallacy Landscape</title>
<style>
  :root {
    --bg-primary: #0d1b2a;
    --bg-secondary: #1b2838;
    --bg-panel: #162232;
    --bg-card: #1e2d40;
    --border-colour: #2a3f56;
    --text-primary: #e0e6ed;
    --text-secondary: #8a9bb0;
    --text-muted: #5a6f85;
    --accent-gold: #d4a843;
    --accent-gold-dim: #a07e30;
    --accent-blue: #4a8fb8;
    --accent-red: #c0392b;
    --accent-green: #27ae60;
    --slider-track: #2a3f56;
    --joy-colour: #f1c40f;
    --anger-colour: #e74c3c;
    --sadness-colour: #5dade2;
    --fear-colour: #8e44ad;
    --peace-colour: #2ecc71;
    --radius: 8px;
    --shadow: 0 2px 12px rgba(0,0,0,0.4);
    --font-main: 'Segoe UI', system-ui, -apple-system, sans-serif;
    --font-serif: 'Georgia', 'Times New Roman', serif;
  }

  *, *::before, *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  body {
    font-family: var(--font-main);
    background: var(--bg-primary);
    color: var(--text-primary);
    min-height: 100vh;
    line-height: 1.6;
  }

  /* ── Sticky Header ── */
  .header {
    position: sticky;
    top: 0;
    z-index: 100;
    background: linear-gradient(135deg, var(--bg-secondary) 0%, #0f1e30 100%);
    border-bottom: 1px solid var(--border-colour);
    padding: 14px 24px;
    box-shadow: var(--shadow);
  }

  .header h1 {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--accent-gold);
    letter-spacing: 0.5px;
  }

  .header p {
    font-size: 0.85rem;
    color: var(--text-secondary);
    margin-top: 2px;
  }

  /* ── Main Layout ── */
  .main-layout {
    display: grid;
    grid-template-columns: 280px 1fr;
    gap: 0;
    min-height: calc(100vh - 80px);
  }

  /* ── Left Panel (Sliders) ── */
  .controls-panel {
    background: var(--bg-panel);
    border-right: 1px solid var(--border-colour);
    padding: 20px;
    overflow-y: auto;
  }

  .controls-panel h2 {
    font-size: 0.95rem;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: var(--accent-gold);
    margin-bottom: 18px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border-colour);
  }

  .slider-group {
    margin-bottom: 20px;
  }

  .slider-label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
  }

  .slider-label span:first-child {
    font-size: 0.9rem;
    font-weight: 600;
  }

  .slider-label .slider-value {
    font-size: 0.8rem;
    color: var(--text-muted);
    background: var(--bg-primary);
    padding: 1px 8px;
    border-radius: 10px;
    min-width: 36px;
    text-align: center;
  }

  .emotion-icon {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    margin-right: 6px;
    vertical-align: middle;
  }

  .emotion-icon.joy { background: var(--joy-colour); }
  .emotion-icon.anger { background: var(--anger-colour); }
  .emotion-icon.sadness { background: var(--sadness-colour); }
  .emotion-icon.fear { background: var(--fear-colour); }
  .emotion-icon.peace { background: var(--peace-colour); }

  input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: var(--slider-track);
    outline: none;
    cursor: pointer;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    border: 2px solid var(--bg-primary);
    cursor: pointer;
  }

  input[type="range"].joy-slider::-webkit-slider-thumb { background: var(--joy-colour); }
  input[type="range"].anger-slider::-webkit-slider-thumb { background: var(--anger-colour); }
  input[type="range"].sadness-slider::-webkit-slider-thumb { background: var(--sadness-colour); }
  input[type="range"].fear-slider::-webkit-slider-thumb { background: var(--fear-colour); }
  input[type="range"].peace-slider::-webkit-slider-thumb { background: var(--peace-colour); }

  input[type="range"]::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    border: 2px solid var(--bg-primary);
    cursor: pointer;
  }

  input[type="range"].joy-slider::-moz-range-thumb { background: var(--joy-colour); }
  input[type="range"].anger-slider::-moz-range-thumb { background: var(--anger-colour); }
  input[type="range"].sadness-slider::-moz-range-thumb { background: var(--sadness-colour); }
  input[type="range"].fear-slider::-moz-range-thumb { background: var(--fear-colour); }
  input[type="range"].peace-slider::-moz-range-thumb { background: var(--peace-colour); }

  .preset-buttons {
    margin-top: 24px;
    padding-top: 16px;
    border-top: 1px solid var(--border-colour);
  }

  .preset-buttons h3 {
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--text-muted);
    margin-bottom: 10px;
  }

  .preset-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 6px;
  }

  .preset-btn {
    background: var(--bg-card);
    border: 1px solid var(--border-colour);
    color: var(--text-secondary);
    padding: 6px 8px;
    border-radius: var(--radius);
    font-size: 0.75rem;
    cursor: pointer;
    transition: all 0.2s;
  }

  .preset-btn:hover {
    background: var(--border-colour);
    color: var(--text-primary);
  }

  .reset-btn {
    width: 100%;
    margin-top: 10px;
    background: transparent;
    border: 1px solid var(--accent-gold-dim);
    color: var(--accent-gold);
    padding: 8px;
    border-radius: var(--radius);
    font-size: 0.8rem;
    cursor: pointer;
    transition: all 0.2s;
  }

  .reset-btn:hover {
    background: var(--accent-gold-dim);
    color: var(--bg-primary);
  }

  /* ── Right Panel (Canvas + Text) ── */
  .canvas-panel {
    padding: 24px;
    overflow-y: auto;
  }

  .canvas-wrapper {
    background: #000;
    border-radius: var(--radius);
    overflow: hidden;
    box-shadow: var(--shadow);
    margin-bottom: 20px;
  }

  #landscapeCanvas {
    display: block;
    width: 100%;
    height: auto;
  }

  /* ── Descriptive Text ── */
  .description-card {
    background: var(--bg-card);
    border: 1px solid var(--border-colour);
    border-radius: var(--radius);
    padding: 20px 24px;
    margin-bottom: 20px;
  }

  .description-card h3 {
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--accent-gold);
    margin-bottom: 10px;
  }

  .description-text {
    font-family: var(--font-serif);
    font-size: 1.05rem;
    line-height: 1.8;
    color: var(--text-primary);
    font-style: italic;
    min-height: 60px;
    transition: opacity 0.3s;
  }

  .dominant-mood {
    margin-top: 10px;
    font-size: 0.8rem;
    color: var(--text-muted);
  }

  /* ── Info Panel ── */
  .info-panel {
    background: var(--bg-card);
    border: 1px solid var(--border-colour);
    border-radius: var(--radius);
    padding: 24px;
  }

  .info-panel h3 {
    font-size: 1.1rem;
    color: var(--accent-gold);
    margin-bottom: 12px;
  }

  .info-panel h4 {
    font-size: 0.95rem;
    color: var(--accent-blue);
    margin-top: 16px;
    margin-bottom: 6px;
  }

  .info-panel p, .info-panel li {
    font-size: 0.88rem;
    color: var(--text-secondary);
    line-height: 1.7;
  }

  .info-panel ul {
    padding-left: 20px;
    margin-top: 4px;
  }

  .info-panel li {
    margin-bottom: 4px;
  }

  .info-quote {
    border-left: 3px solid var(--accent-gold-dim);
    padding: 10px 16px;
    margin: 12px 0;
    background: rgba(212, 168, 67, 0.05);
    border-radius: 0 var(--radius) var(--radius) 0;
  }

  .info-quote p {
    font-family: var(--font-serif);
    font-style: italic;
    color: var(--text-primary);
  }

  .info-quote .attribution {
    font-style: normal;
    font-size: 0.8rem;
    color: var(--text-muted);
    margin-top: 4px;
  }

  /* ── Responsive ── */
  @media (max-width: 900px) {
    .main-layout {
      grid-template-columns: 1fr;
    }

    .controls-panel {
      border-right: none;
      border-bottom: 1px solid var(--border-colour);
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0 24px;
    }

    .controls-panel h2 {
      grid-column: 1 / -1;
    }

    .preset-buttons {
      grid-column: 1 / -1;
    }
  }

  @media (max-width: 560px) {
    .controls-panel {
      grid-template-columns: 1fr;
    }

    .header h1 {
      font-size: 1.2rem;
    }

    .canvas-panel {
      padding: 12px;
    }
  }
</style>
</head>
<body>

<!-- ── Header ── -->
<header class="header">
  <h1>Pathetic Fallacy Landscape</h1>
  <p>Adjust the emotion sliders and watch the landscape transform. See how weather and setting can reflect character emotion.</p>
</header>

<!-- ── Main Layout ── -->
<div class="main-layout">

  <!-- Left Panel: Sliders -->
  <aside class="controls-panel">
    <h2>Emotion Controls</h2>

    <div class="slider-group">
      <div class="slider-label">
        <span><span class="emotion-icon joy"></span>Joy</span>
        <span class="slider-value" id="joyVal">0</span>
      </div>
      <input type="range" id="joySlider" class="joy-slider" min="0" max="100" value="0">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span><span class="emotion-icon anger"></span>Anger</span>
        <span class="slider-value" id="angerVal">0</span>
      </div>
      <input type="range" id="angerSlider" class="anger-slider" min="0" max="100" value="0">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span><span class="emotion-icon sadness"></span>Sadness</span>
        <span class="slider-value" id="sadnessVal">0</span>
      </div>
      <input type="range" id="sadnessSlider" class="sadness-slider" min="0" max="100" value="0">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span><span class="emotion-icon fear"></span>Fear</span>
        <span class="slider-value" id="fearVal">0</span>
      </div>
      <input type="range" id="fearSlider" class="fear-slider" min="0" max="100" value="0">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span><span class="emotion-icon peace"></span>Peace</span>
        <span class="slider-value" id="peaceVal">0</span>
      </div>
      <input type="range" id="peaceSlider" class="peace-slider" min="0" max="100" value="0">
    </div>

    <div class="preset-buttons">
      <h3>Presets</h3>
      <div class="preset-grid">
        <button class="preset-btn" data-preset="stormy">Stormy Night</button>
        <button class="preset-btn" data-preset="sunny">Summer Day</button>
        <button class="preset-btn" data-preset="melancholy">Melancholy</button>
        <button class="preset-btn" data-preset="gothic">Gothic Horror</button>
        <button class="preset-btn" data-preset="tranquil">Tranquil Lake</button>
        <button class="preset-btn" data-preset="conflict">Inner Conflict</button>
      </div>
      <button class="reset-btn" id="resetBtn">Reset All</button>
    </div>
  </aside>

  <!-- Right Panel: Canvas + Text + Info -->
  <main class="canvas-panel">
    <div class="canvas-wrapper">
      <canvas id="landscapeCanvas" width="800" height="500"></canvas>
    </div>

    <div class="description-card">
      <h3>Generated Descriptive Passage</h3>
      <div class="description-text" id="descriptionText">
        A still, empty landscape waits in silence. Move the sliders to breathe emotion into the scene.
      </div>
      <div class="dominant-mood" id="dominantMood"></div>
    </div>

    <div class="info-panel">
      <h3>What is Pathetic Fallacy?</h3>
      <p>
        <strong>Pathetic fallacy</strong> is a literary device in which human emotions are attributed
        to nature or inanimate objects, particularly weather and landscape. The term was coined by the
        Victorian critic <strong>John Ruskin</strong> in <em>Modern Painters</em> (1856). Ruskin used
        "pathetic" in its original Greek sense of <em>pathos</em> (feeling), and "fallacy" to indicate
        that the attribution is technically false: the sky does not truly "weep," nor does the wind
        truly "howl" with rage.
      </p>

      <div class="info-quote">
        <p>
          "All violent feelings ... produce in us a falseness in all our impressions of external things,
          which I would generally characterize as the 'pathetic fallacy.'"
        </p>
        <div class="attribution">John Ruskin, <em>Modern Painters</em>, Volume III (1856)</div>
      </div>

      <h4>Why Writers Use It</h4>
      <ul>
        <li><strong>Atmosphere:</strong> Sets the emotional tone of a scene without explicitly stating the character's feelings.</li>
        <li><strong>Foreshadowing:</strong> A storm gathering on the horizon can hint at coming conflict.</li>
        <li><strong>Symbolism:</strong> Seasons and weather can mirror inner transformation (spring for renewal, winter for despair).</li>
        <li><strong>Empathy:</strong> Helps readers feel what characters feel by immersing them in an emotionally charged world.</li>
      </ul>

      <h4>Key Examples in Literature</h4>
      <ul>
        <li><strong>Shakespeare, <em>King Lear</em>:</strong> The storm on the heath mirrors Lear's descent into madness.</li>
        <li><strong>Shelley, <em>Frankenstein</em>:</strong> Dark, icy landscapes reflect the creature's isolation.</li>
        <li><strong>Bronte, <em>Wuthering Heights</em>:</strong> The wild Yorkshire moors echo the passionate, untamed emotions of the characters.</li>
        <li><strong>Dickens, <em>Bleak House</em>:</strong> The opening fog represents the suffocating confusion of the legal system.</li>
        <li><strong>Hardy, <em>Far from the Madding Crowd</em>:</strong> Storms and seasons track the fortunes of the characters.</li>
      </ul>

      <h4>How to Use This Tool</h4>
      <p>
        Adjust the five emotion sliders on the left to see how different feelings transform the
        same landscape. Notice how blending emotions creates complex atmospheric effects. The
        generated passage below the canvas shows how you might describe the scene in writing.
        Try using the presets for inspiration, or create your own unique combinations.
      </p>
    </div>
  </main>
</div>

<script>
(function() {
  "use strict";

  // ── Canvas Setup ──
  const canvas = document.getElementById("landscapeCanvas");
  const ctx = canvas.getContext("2d");
  const W = canvas.width;
  const H = canvas.height;

  // ── Slider References ──
  const sliders = {
    joy:     document.getElementById("joySlider"),
    anger:   document.getElementById("angerSlider"),
    sadness: document.getElementById("sadnessSlider"),
    fear:    document.getElementById("fearSlider"),
    peace:   document.getElementById("peaceSlider")
  };

  const valDisplays = {
    joy:     document.getElementById("joyVal"),
    anger:   document.getElementById("angerVal"),
    sadness: document.getElementById("sadnessVal"),
    fear:    document.getElementById("fearVal"),
    peace:   document.getElementById("peaceVal")
  };

  const descriptionEl = document.getElementById("descriptionText");
  const dominantMoodEl = document.getElementById("dominantMood");

  // ── State ──
  let emotions = { joy: 0, anger: 0, sadness: 0, fear: 0, peace: 0 };
  let time = 0;
  let raindrops = [];
  let lightningTimer = 0;
  let lightningFlash = 0;
  let particles = []; // fireflies, mist wisps, etc.

  // Initialise rain particles
  for (let i = 0; i < 200; i++) {
    raindrops.push({
      x: Math.random() * W,
      y: Math.random() * H,
      speed: 4 + Math.random() * 6,
      length: 8 + Math.random() * 12
    });
  }

  // Initialise mist / firefly particles
  for (let i = 0; i < 60; i++) {
    particles.push({
      x: Math.random() * W,
      y: H * 0.4 + Math.random() * H * 0.4,
      vx: (Math.random() - 0.5) * 0.5,
      vy: (Math.random() - 0.5) * 0.3,
      radius: 1 + Math.random() * 3,
      alpha: Math.random(),
      phase: Math.random() * Math.PI * 2
    });
  }

  // ── Colour Utilities ──
  function lerp(a, b, t) { return a + (b - a) * t; }

  function lerpColour(c1, c2, t) {
    return [
      Math.round(lerp(c1[0], c2[0], t)),
      Math.round(lerp(c1[1], c2[1], t)),
      Math.round(lerp(c1[2], c2[2], t))
    ];
  }

  function rgb(c) { return "rgb(" + c[0] + "," + c[1] + "," + c[2] + ")"; }
  function rgba(c, a) { return "rgba(" + c[0] + "," + c[1] + "," + c[2] + "," + a + ")"; }

  function blendColours(colours) {
    // colours is array of { colour: [r,g,b], weight: 0-1 }
    let totalWeight = 0;
    let r = 0, g = 0, b = 0;
    for (const c of colours) {
      r += c.colour[0] * c.weight;
      g += c.colour[1] * c.weight;
      b += c.colour[2] * c.weight;
      totalWeight += c.weight;
    }
    if (totalWeight === 0) return [40, 45, 55];
    return [Math.round(r / totalWeight), Math.round(g / totalWeight), Math.round(b / totalWeight)];
  }

  // ── Scene Colour Palettes ──
  const palettes = {
    neutral: {
      skyTop: [40, 45, 55], skyBottom: [70, 75, 85],
      ground: [35, 50, 35], water: [50, 65, 80],
      sun: [180, 180, 160], mountain: [55, 60, 65]
    },
    joy: {
      skyTop: [80, 160, 230], skyBottom: [170, 220, 255],
      ground: [60, 140, 50], water: [70, 150, 210],
      sun: [255, 230, 80], mountain: [90, 130, 90]
    },
    anger: {
      skyTop: [60, 10, 10], skyBottom: [140, 40, 20],
      ground: [50, 30, 20], water: [60, 35, 30],
      sun: [180, 50, 20], mountain: [70, 30, 25]
    },
    sadness: {
      skyTop: [70, 80, 95], skyBottom: [110, 115, 125],
      ground: [55, 65, 55], water: [80, 90, 100],
      sun: [140, 140, 140], mountain: [75, 80, 85]
    },
    fear: {
      skyTop: [15, 10, 30], skyBottom: [35, 25, 50],
      ground: [25, 20, 30], water: [30, 25, 45],
      sun: [100, 80, 120], mountain: [35, 25, 40]
    },
    peace: {
      skyTop: [120, 80, 140], skyBottom: [220, 160, 100],
      ground: [70, 120, 60], water: [130, 140, 160],
      sun: [250, 200, 100], mountain: [100, 110, 100]
    }
  };

  function getBlendedPalette() {
    const w = {
      joy: emotions.joy / 100,
      anger: emotions.anger / 100,
      sadness: emotions.sadness / 100,
      fear: emotions.fear / 100,
      peace: emotions.peace / 100
    };
    const total = w.joy + w.anger + w.sadness + w.fear + w.peace;

    const result = {};
    const keys = Object.keys(palettes.neutral);

    for (const key of keys) {
      if (total === 0) {
        result[key] = palettes.neutral[key].slice();
      } else {
        const blended = blendColours([
          { colour: palettes.joy[key], weight: w.joy },
          { colour: palettes.anger[key], weight: w.anger },
          { colour: palettes.sadness[key], weight: w.sadness },
          { colour: palettes.fear[key], weight: w.fear },
          { colour: palettes.peace[key], weight: w.peace }
        ]);
        // Mix with neutral based on total intensity
        const intensity = Math.min(total, 1);
        result[key] = lerpColour(palettes.neutral[key], blended, intensity);
      }
    }
    return result;
  }

  // ── Drawing Functions ──

  function drawSky(pal) {
    const grad = ctx.createLinearGradient(0, 0, 0, H * 0.55);
    grad.addColorStop(0, rgb(pal.skyTop));
    grad.addColorStop(1, rgb(pal.skyBottom));
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H * 0.55);
  }

  function drawSun(pal) {
    const joyW = emotions.joy / 100;
    const peaceW = emotions.peace / 100;
    const angerW = emotions.anger / 100;
    const visibility = Math.max(joyW, peaceW * 0.8) - emotions.sadness / 200 - emotions.fear / 200;
    if (visibility <= 0.05) return;

    const sunX = lerp(W * 0.7, W * 0.5, peaceW);
    const sunY = lerp(H * 0.2, H * 0.38, peaceW);
    const sunRadius = 30 + joyW * 20;
    const alpha = Math.min(visibility, 1);

    // Glow
    const glowGrad = ctx.createRadialGradient(sunX, sunY, sunRadius * 0.5, sunX, sunY, sunRadius * 4);
    glowGrad.addColorStop(0, rgba(pal.sun, 0.3 * alpha));
    glowGrad.addColorStop(1, rgba(pal.sun, 0));
    ctx.fillStyle = glowGrad;
    ctx.beginPath();
    ctx.arc(sunX, sunY, sunRadius * 4, 0, Math.PI * 2);
    ctx.fill();

    // Sun body
    ctx.fillStyle = rgba(pal.sun, alpha);
    ctx.beginPath();
    ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
    ctx.fill();

    // Anger: make sun reddish and angry
    if (angerW > 0.2) {
      ctx.fillStyle = rgba([200, 50, 20], angerW * 0.4);
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunRadius * 0.8, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawClouds() {
    const sadW = emotions.sadness / 100;
    const angerW = emotions.anger / 100;
    const fearW = emotions.fear / 100;
    const cloudiness = Math.max(sadW, angerW * 0.8, fearW * 0.7);
    if (cloudiness < 0.05) return;

    const numClouds = Math.floor(3 + cloudiness * 8);

    for (let i = 0; i < numClouds; i++) {
      const cx = ((i * 137 + time * 0.3 * (0.5 + i * 0.1)) % (W + 200)) - 100;
      const cy = 20 + (i % 4) * 35 + Math.sin(i * 2.3) * 20;
      const scale = 0.8 + (i % 3) * 0.3;

      let cloudColour;
      if (angerW > sadW && angerW > fearW) {
        cloudColour = lerpColour([80, 70, 70], [50, 20, 20], angerW);
      } else if (fearW > sadW) {
        cloudColour = lerpColour([60, 55, 70], [30, 20, 40], fearW);
      } else {
        cloudColour = lerpColour([140, 145, 155], [90, 95, 100], sadW);
      }

      ctx.fillStyle = rgba(cloudColour, 0.5 + cloudiness * 0.4);
      drawCloudShape(cx, cy, scale);
    }
  }

  function drawCloudShape(x, y, scale) {
    ctx.beginPath();
    ctx.arc(x, y, 30 * scale, 0, Math.PI * 2);
    ctx.arc(x + 25 * scale, y - 10 * scale, 25 * scale, 0, Math.PI * 2);
    ctx.arc(x + 50 * scale, y, 28 * scale, 0, Math.PI * 2);
    ctx.arc(x + 20 * scale, y + 5 * scale, 22 * scale, 0, Math.PI * 2);
    ctx.arc(x - 15 * scale, y + 5 * scale, 20 * scale, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawMountains(pal) {
    const mountainData = [
      { cx: W * 0.15, peak: H * 0.28, baseY: H * 0.55, width: 220 },
      { cx: W * 0.45, peak: H * 0.22, baseY: H * 0.55, width: 280 },
      { cx: W * 0.75, peak: H * 0.3, baseY: H * 0.55, width: 240 },
      { cx: W * 0.95, peak: H * 0.32, baseY: H * 0.55, width: 200 }
    ];

    const fearW = emotions.fear / 100;

    for (let i = 0; i < mountainData.length; i++) {
      const m = mountainData[i];
      const shade = i % 2 === 0 ? 1 : 0.85;

      // Jaggedness from fear
      ctx.fillStyle = rgb(lerpColour(
        pal.mountain,
        [pal.mountain[0] * shade, pal.mountain[1] * shade, pal.mountain[2] * shade],
        0.5
      ));

      ctx.beginPath();
      ctx.moveTo(m.cx - m.width / 2, m.baseY);

      if (fearW > 0.3) {
        // Jagged, twisted peaks
        const steps = 12;
        for (let s = 0; s <= steps; s++) {
          const t = s / steps;
          const x = m.cx - m.width / 2 + m.width * t;
          const baseHeight = m.baseY - (m.baseY - m.peak) * (1 - Math.abs(t * 2 - 1));
          const jagged = Math.sin(s * 3.7 + i) * 15 * fearW;
          ctx.lineTo(x, baseHeight + jagged);
        }
      } else {
        ctx.lineTo(m.cx, m.peak);
        ctx.lineTo(m.cx + m.width / 2, m.baseY);
      }

      ctx.closePath();
      ctx.fill();
    }
  }

  function drawGround(pal) {
    const grad = ctx.createLinearGradient(0, H * 0.55, 0, H);
    grad.addColorStop(0, rgb(pal.ground));
    const darkerGround = [pal.ground[0] * 0.6, pal.ground[1] * 0.6, pal.ground[2] * 0.6];
    grad.addColorStop(1, rgb(darkerGround));
    ctx.fillStyle = grad;
    ctx.fillRect(0, H * 0.55, W, H * 0.45);
  }

  function drawWater(pal) {
    const waterY = H * 0.65;
    const waterH = H * 0.35;
    const angerW = emotions.anger / 100;
    const peaceW = emotions.peace / 100;

    // Water body
    const grad = ctx.createLinearGradient(0, waterY, 0, H);
    grad.addColorStop(0, rgba(pal.water, 0.7));
    const deepWater = [pal.water[0] * 0.5, pal.water[1] * 0.5, pal.water[2] * 0.6];
    grad.addColorStop(1, rgba(deepWater, 0.9));
    ctx.fillStyle = grad;
    ctx.fillRect(W * 0.05, waterY, W * 0.9, waterH);

    // Waves
    const waveIntensity = 1 + angerW * 8;
    const waveSpeed = 0.02 + angerW * 0.05;
    ctx.strokeStyle = rgba([255, 255, 255], 0.1 + angerW * 0.15);
    ctx.lineWidth = 1;

    for (let row = 0; row < 8; row++) {
      const wy = waterY + 10 + row * (waterH / 9);
      ctx.beginPath();
      for (let x = W * 0.05; x < W * 0.95; x += 2) {
        const y = wy + Math.sin(x * 0.02 + time * waveSpeed + row * 1.5) * waveIntensity
                     + Math.sin(x * 0.005 + time * waveSpeed * 0.7) * waveIntensity * 0.5;
        if (x === W * 0.05) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
    }

    // Reflections (peace makes them clearer)
    if (peaceW > 0.2) {
      ctx.fillStyle = rgba(pal.sun, peaceW * 0.15);
      const refX = W * 0.5;
      for (let i = 0; i < 6; i++) {
        const ry = waterY + 20 + i * 20;
        const rw = 40 - i * 5 + Math.sin(time * 0.03 + i) * 5;
        ctx.fillRect(refX - rw / 2, ry, rw, 3);
      }
    }
  }

  function drawTrees(pal) {
    const joyW = emotions.joy / 100;
    const angerW = emotions.anger / 100;
    const fearW = emotions.fear / 100;
    const peaceW = emotions.peace / 100;
    const sadW = emotions.sadness / 100;

    const treePositions = [
      { x: 60, baseY: H * 0.55, size: 1.1 },
      { x: 150, baseY: H * 0.58, size: 0.8 },
      { x: W - 80, baseY: H * 0.56, size: 1.0 },
      { x: W - 160, baseY: H * 0.59, size: 0.7 },
      { x: W * 0.3, baseY: H * 0.6, size: 0.6 },
      { x: W * 0.7, baseY: H * 0.57, size: 0.9 }
    ];

    for (const tree of treePositions) {
      const trunkH = 60 * tree.size;
      const tx = tree.x;
      const ty = tree.baseY;

      // Trunk
      const trunkColour = fearW > 0.3
        ? lerpColour([60, 40, 30], [30, 15, 25], fearW)
        : [70, 50, 35];

      ctx.fillStyle = rgb(trunkColour);

      if (fearW > 0.3) {
        // Twisted trunks
        ctx.save();
        ctx.translate(tx, ty);
        ctx.beginPath();
        const twist = Math.sin(time * 0.01 + tree.x) * 8 * fearW;
        ctx.moveTo(-4, 0);
        ctx.quadraticCurveTo(-6 + twist, -trunkH * 0.5, -3 + twist * 0.5, -trunkH);
        ctx.lineTo(3 + twist * 0.5, -trunkH);
        ctx.quadraticCurveTo(6 + twist, -trunkH * 0.5, 4, 0);
        ctx.closePath();
        ctx.fill();

        // Bare branches
        drawBranches(0, -trunkH, trunkH * 0.5, 3, fearW, tree.size);
        ctx.restore();
      } else {
        // Straight trunks
        ctx.fillRect(tx - 4 * tree.size, ty - trunkH, 8 * tree.size, trunkH);

        // Canopy
        const leafGreen = joyW > 0.3
          ? lerpColour(pal.ground, [50, 180, 50], joyW * 0.5)
          : pal.ground;

        const canopyAlpha = angerW > 0.5 ? 1 - angerW * 0.6 : 1 - sadW * 0.3;

        if (canopyAlpha > 0.1) {
          ctx.fillStyle = rgba(leafGreen, Math.max(0.3, canopyAlpha));
          const canopyR = 25 * tree.size;
          const canopyY = ty - trunkH - canopyR * 0.6;

          // Slight sway from peace breeze
          const sway = peaceW > 0.2
            ? Math.sin(time * 0.02 + tree.x * 0.1) * 3 * peaceW
            : 0;

          ctx.beginPath();
          ctx.arc(tx + sway, canopyY, canopyR, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(tx - canopyR * 0.6 + sway, canopyY + 5, canopyR * 0.8, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(tx + canopyR * 0.6 + sway, canopyY + 5, canopyR * 0.8, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
  }

  function drawBranches(x, y, length, depth, fearW, scale) {
    if (depth <= 0 || length < 5) return;

    const angleSpread = 0.4 + fearW * 0.5;

    for (let side = -1; side <= 1; side += 2) {
      const angle = -Math.PI / 2 + side * angleSpread + Math.sin(time * 0.015 + x + side) * 0.1 * fearW;
      const endX = x + Math.cos(angle) * length;
      const endY = y + Math.sin(angle) * length;

      ctx.strokeStyle = rgba([50, 30, 25], 0.7);
      ctx.lineWidth = depth * 0.8 * scale;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(endX, endY);
      ctx.stroke();

      drawBranches(endX, endY, length * 0.65, depth - 1, fearW, scale);
    }
  }

  function drawFlowers() {
    const joyW = emotions.joy / 100;
    if (joyW < 0.15) return;

    const numFlowers = Math.floor(joyW * 30);
    const colours = [
      [255, 100, 100], [255, 200, 50], [200, 100, 255],
      [255, 150, 180], [100, 200, 255], [255, 255, 100]
    ];

    for (let i = 0; i < numFlowers; i++) {
      const fx = 30 + ((i * 97 + 13) % (W - 60));
      const fy = H * 0.56 + ((i * 53 + 7) % (H * 0.12));
      const colour = colours[i % colours.length];
      const size = 3 + joyW * 3;

      // Petals
      ctx.fillStyle = rgba(colour, 0.6 + joyW * 0.3);
      for (let p = 0; p < 5; p++) {
        const a = (p / 5) * Math.PI * 2 + time * 0.005;
        ctx.beginPath();
        ctx.arc(fx + Math.cos(a) * size * 0.6, fy + Math.sin(a) * size * 0.6, size * 0.4, 0, Math.PI * 2);
        ctx.fill();
      }

      // Centre
      ctx.fillStyle = rgba([255, 230, 100], 0.8);
      ctx.beginPath();
      ctx.arc(fx, fy, size * 0.25, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawGrass() {
    const peaceW = emotions.peace / 100;
    const joyW = emotions.joy / 100;
    const greenness = Math.max(peaceW, joyW);
    if (greenness < 0.1) return;

    const grassColour = lerpColour([50, 80, 40], [70, 160, 50], greenness);

    for (let i = 0; i < 120; i++) {
      const gx = ((i * 73 + 11) % W);
      const gy = H * 0.54 + ((i * 47) % (H * 0.15));
      const height = 8 + greenness * 12;
      const sway = Math.sin(time * 0.025 + gx * 0.05) * (3 + peaceW * 5);

      ctx.strokeStyle = rgba(grassColour, 0.4 + greenness * 0.3);
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(gx, gy);
      ctx.quadraticCurveTo(gx + sway * 0.5, gy - height * 0.5, gx + sway, gy - height);
      ctx.stroke();
    }
  }

  function drawRain() {
    const sadW = emotions.sadness / 100;
    const angerW = emotions.anger / 100;
    const rainIntensity = Math.max(sadW, angerW * 0.6);
    if (rainIntensity < 0.1) return;

    const numActive = Math.floor(rainIntensity * raindrops.length);
    const windAngle = angerW > sadW ? 0.3 : 0.05;

    ctx.strokeStyle = rgba([180, 195, 220], 0.2 + rainIntensity * 0.3);
    ctx.lineWidth = 1;

    for (let i = 0; i < numActive; i++) {
      const drop = raindrops[i];
      ctx.beginPath();
      ctx.moveTo(drop.x, drop.y);
      ctx.lineTo(drop.x + windAngle * drop.length, drop.y + drop.length);
      ctx.stroke();

      // Update position
      drop.y += drop.speed * (0.5 + rainIntensity);
      drop.x += windAngle * drop.speed;
      if (drop.y > H) {
        drop.y = -drop.length;
        drop.x = Math.random() * W;
      }
      if (drop.x > W) drop.x = 0;
    }
  }

  function drawLightning() {
    const angerW = emotions.anger / 100;
    if (angerW < 0.3) { lightningFlash = 0; return; }

    lightningTimer++;
    const flashInterval = Math.floor(120 - angerW * 80);

    if (lightningTimer > flashInterval && Math.random() < 0.05 * angerW) {
      lightningFlash = 8;
      lightningTimer = 0;
    }

    if (lightningFlash > 0) {
      // Screen flash
      ctx.fillStyle = rgba([255, 255, 255], lightningFlash * 0.02);
      ctx.fillRect(0, 0, W, H);

      // Lightning bolt
      if (lightningFlash > 4) {
        const startX = W * 0.3 + Math.random() * W * 0.4;
        drawLightningBolt(startX, 0, startX + (Math.random() - 0.5) * 60, H * 0.55, 4);
      }
      lightningFlash--;
    }
  }

  function drawLightningBolt(x1, y1, x2, y2, branches) {
    ctx.strokeStyle = rgba([255, 255, 220], 0.9);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x1, y1);

    let cx = x1;
    let cy = y1;
    const segments = 8;
    const dx = (x2 - x1) / segments;
    const dy = (y2 - y1) / segments;

    for (let i = 0; i < segments; i++) {
      cx += dx + (Math.random() - 0.5) * 40;
      cy += dy;
      ctx.lineTo(cx, cy);

      // Small branches
      if (branches > 0 && Math.random() < 0.3) {
        const bx = cx + (Math.random() - 0.5) * 60;
        const by = cy + 20 + Math.random() * 40;
        ctx.moveTo(cx, cy);
        ctx.lineTo(bx, by);
        ctx.moveTo(cx, cy);
      }
    }
    ctx.stroke();

    // Glow
    ctx.strokeStyle = rgba([200, 200, 255], 0.3);
    ctx.lineWidth = 6;
    ctx.stroke();
  }

  function drawFog() {
    const sadW = emotions.sadness / 100;
    const fearW = emotions.fear / 100;
    const fogIntensity = Math.max(sadW * 0.7, fearW * 0.9);
    if (fogIntensity < 0.1) return;

    for (let i = 0; i < particles.length * fogIntensity; i++) {
      const p = particles[i];
      const alpha = (0.1 + Math.sin(p.phase + time * 0.01) * 0.05) * fogIntensity;

      let fogColour;
      if (fearW > sadW) {
        fogColour = [80, 60, 100];
      } else {
        fogColour = [160, 165, 175];
      }

      ctx.fillStyle = rgba(fogColour, alpha);
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius * (5 + fogIntensity * 15), 0, Math.PI * 2);
      ctx.fill();

      // Drift
      p.x += p.vx + Math.sin(time * 0.005 + p.phase) * 0.3;
      p.y += p.vy + Math.cos(time * 0.003 + p.phase) * 0.2;
      if (p.x > W + 50) p.x = -50;
      if (p.x < -50) p.x = W + 50;
      if (p.y > H) p.y = H * 0.4;
      if (p.y < H * 0.3) p.y = H * 0.8;
    }
  }

  function drawShadows() {
    const fearW = emotions.fear / 100;
    if (fearW < 0.2) return;

    // Dark vignette
    const vignetteGrad = ctx.createRadialGradient(W / 2, H / 2, W * 0.2, W / 2, H / 2, W * 0.7);
    vignetteGrad.addColorStop(0, rgba([0, 0, 0], 0));
    vignetteGrad.addColorStop(1, rgba([0, 0, 0], fearW * 0.5));
    ctx.fillStyle = vignetteGrad;
    ctx.fillRect(0, 0, W, H);

    // Creeping shadows at bottom
    for (let i = 0; i < 8; i++) {
      const sx = (i / 8) * W + Math.sin(time * 0.01 + i * 2) * 30;
      const sy = H - 20;
      const sHeight = 30 + fearW * 40 + Math.sin(time * 0.02 + i) * 10;

      ctx.fillStyle = rgba([10, 5, 20], fearW * 0.3);
      ctx.beginPath();
      ctx.ellipse(sx, sy, 60, sHeight, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawStars() {
    const fearW = emotions.fear / 100;
    const peaceW = emotions.peace / 100;
    const darkness = Math.max(fearW, 0);
    const starVisibility = darkness * 0.5 + peaceW * 0.3;
    if (starVisibility < 0.1) return;

    for (let i = 0; i < 40; i++) {
      const sx = (i * 197 + 31) % W;
      const sy = (i * 83 + 17) % (H * 0.4);
      const flicker = 0.3 + Math.sin(time * 0.05 + i * 1.7) * 0.3;
      const size = 1 + (i % 3) * 0.5;

      ctx.fillStyle = rgba([220, 220, 240], flicker * starVisibility);
      ctx.beginPath();
      ctx.arc(sx, sy, size, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // ── Main Render ──
  function render() {
    time++;

    const pal = getBlendedPalette();

    // Clear
    ctx.clearRect(0, 0, W, H);

    // Layer order matters
    drawSky(pal);
    drawStars();
    drawSun(pal);
    drawClouds();
    drawMountains(pal);
    drawGround(pal);
    drawGrass();
    drawFlowers();
    drawTrees(pal);
    drawWater(pal);
    drawFog();
    drawRain();
    drawShadows();
    drawLightning();

    requestAnimationFrame(render);
  }

  // ── Descriptive Text Generation ──
  const descriptions = {
    joy: [
      "Sunlight spilled across the meadow like honey, warming every blade of grass until the whole hillside seemed to glow.",
      "The sky opened into a vast cathedral of blue, and wildflowers nodded along the water's edge as if in cheerful agreement.",
      "Golden light danced on the surface of the lake, and somewhere above, a lark poured out its bright, cascading song.",
      "The world was drenched in colour: buttercup yellow, cornflower blue, and the deep, contented green of summer."
    ],
    anger: [
      "The sky bruised to a furious crimson, and the horizon crackled with the threat of something terrible approaching.",
      "Thunder rolled across the hills like the growl of some immense, unseen beast, and the waves tore at the shore.",
      "Lightning split the darkness with white fury, illuminating bare trees that clawed at the sky like skeletal hands.",
      "The wind shrieked through the valley, bending the world to its will, as if nature itself had lost all patience."
    ],
    sadness: [
      "A grey curtain of rain fell steadily over the landscape, blurring the edges of everything until the world seemed to dissolve.",
      "The sky hung low and heavy, pressing down on the hills, and a thin mist crept along the water like a sigh.",
      "Colour had drained from the land. Everything stood in muted greys and faded greens, as if mourning something lost.",
      "Raindrops stippled the surface of the lake, each one a tiny, fleeting circle, gone almost before it appeared."
    ],
    fear: [
      "Darkness gathered at the edges of the landscape, and the twisted shapes of the trees seemed to lean inward, watching.",
      "An eerie mist coiled around the base of the hills, and the silence was the wrong kind of silence: expectant, waiting.",
      "Shadows pooled in the hollows of the land like spilled ink, and the sky offered no comfort, only a deep, starless void.",
      "The trees stood like crooked sentinels, their bare limbs reaching out as if to catch whatever dared to pass beneath them."
    ],
    peace: [
      "The lake lay perfectly still, a mirror reflecting the soft apricot and lavender of the fading sky.",
      "A gentle breeze moved through the long grass, carrying the scent of warm earth and distant wildflowers.",
      "The sun sank slowly behind the hills, painting the clouds in shades of rose and amber, and all the world was quiet.",
      "Everything was held in a moment of perfect stillness: the water, the sky, the softly swaying grass, all in gentle harmony."
    ],
    neutral: [
      "A still, empty landscape waits in silence. Move the sliders to breathe emotion into the scene.",
      "The land lies quiet, neither bright nor dark, poised on the edge of feeling."
    ],
    blended: [
      "The landscape shifted between moods, as if unable to settle on a single feeling. Light and shadow played across the hills in an uneasy truce.",
      "Contradictions hung in the air: warmth and chill, brightness and gloom, calm and unease, all woven together in a single, complicated moment.",
      "The scene was restless, caught between competing forces. The sky could not decide whether to clear or darken, and the land reflected its indecision."
    ]
  };

  function updateDescription() {
    const total = emotions.joy + emotions.anger + emotions.sadness + emotions.fear + emotions.peace;

    if (total < 10) {
      const idx = Math.floor(time * 0.001) % descriptions.neutral.length;
      descriptionEl.textContent = descriptions.neutral[idx];
      dominantMoodEl.textContent = "";
      return;
    }

    // Find dominant emotion(s)
    const sorted = Object.entries(emotions).sort((a, b) => b[1] - a[1]);
    const dominant = sorted[0];
    const second = sorted[1];

    let passage;
    let moodLabel;

    // Check if blended (two strong emotions)
    if (dominant[1] > 20 && second[1] > 20 && (second[1] / dominant[1]) > 0.5) {
      // Use a blend of two descriptions
      const idx1 = Math.floor(time * 0.001) % descriptions[dominant[0]].length;
      const idx2 = Math.floor(time * 0.001 + 2) % descriptions[second[0]].length;

      if (Math.random() < 0.3 || (dominant[1] - second[1]) < 10) {
        const blendIdx = Math.floor(time * 0.001) % descriptions.blended.length;
        passage = descriptions.blended[blendIdx];
      } else {
        passage = descriptions[dominant[0]][idx1];
      }
      moodLabel = "Dominant mood: " + capitalise(dominant[0]) + " (" + dominant[1] + "%) blended with " + capitalise(second[0]) + " (" + second[1] + "%)";
    } else {
      const idx = Math.floor(time * 0.001) % descriptions[dominant[0]].length;
      passage = descriptions[dominant[0]][idx];
      moodLabel = "Dominant mood: " + capitalise(dominant[0]) + " (" + dominant[1] + "%)";
    }

    descriptionEl.textContent = passage;
    dominantMoodEl.textContent = moodLabel;
  }

  function capitalise(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

  // ── Slider Event Handling ──
  let descUpdateTimer = 0;

  function onSliderInput(emotion) {
    return function() {
      emotions[emotion] = parseInt(this.value);
      valDisplays[emotion].textContent = this.value;

      clearTimeout(descUpdateTimer);
      descUpdateTimer = setTimeout(updateDescription, 300);
    };
  }

  for (const key of Object.keys(sliders)) {
    sliders[key].addEventListener("input", onSliderInput(key));
  }

  // ── Presets ──
  const presets = {
    stormy:     { joy: 0,  anger: 75, sadness: 40, fear: 20, peace: 0 },
    sunny:      { joy: 90, anger: 0,  sadness: 0,  fear: 0,  peace: 30 },
    melancholy: { joy: 5,  anger: 0,  sadness: 85, fear: 10, peace: 0 },
    gothic:     { joy: 0,  anger: 30, sadness: 20, fear: 90, peace: 0 },
    tranquil:   { joy: 20, anger: 0,  sadness: 0,  fear: 0,  peace: 95 },
    conflict:   { joy: 30, anger: 60, sadness: 40, fear: 20, peace: 0 }
  };

  function applyPreset(name) {
    const p = presets[name];
    if (!p) return;

    // Animate sliders towards target
    const startVals = { ...emotions };
    const steps = 30;
    let step = 0;

    function animateStep() {
      step++;
      const t = step / steps;
      const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

      for (const key of Object.keys(p)) {
        const val = Math.round(lerp(startVals[key], p[key], ease));
        emotions[key] = val;
        sliders[key].value = val;
        valDisplays[key].textContent = val;
      }

      if (step < steps) {
        requestAnimationFrame(animateStep);
      } else {
        updateDescription();
      }
    }
    animateStep();
  }

  document.querySelectorAll(".preset-btn").forEach(function(btn) {
    btn.addEventListener("click", function() {
      applyPreset(this.getAttribute("data-preset"));
    });
  });

  document.getElementById("resetBtn").addEventListener("click", function() {
    applyPreset({ joy: 0, anger: 0, sadness: 0, fear: 0, peace: 0 } && "reset" || "reset");
    // Direct reset
    const target = { joy: 0, anger: 0, sadness: 0, fear: 0, peace: 0 };
    const startVals = { ...emotions };
    const steps = 20;
    let step = 0;

    function animReset() {
      step++;
      const t = step / steps;
      for (const key of Object.keys(target)) {
        const val = Math.round(lerp(startVals[key], 0, t));
        emotions[key] = val;
        sliders[key].value = val;
        valDisplays[key].textContent = val;
      }
      if (step < steps) requestAnimationFrame(animReset);
      else updateDescription();
    }
    animReset();
  });

  // ── Start ──
  updateDescription();
  render();

})();
</script>
</body>
</html>