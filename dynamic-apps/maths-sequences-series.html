<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sequences &amp; Series Explorer</title>
<style>
:root {
  --bg: #f5f7fa;
  --surface: #ffffff;
  --text: #1e293b;
  --text-muted: #64748b;
  --border: #e2e8f0;
  --accent: #4f46e5;
  --accent-light: #e0e7ff;
  --arithmetic: #2563eb;
  --arithmetic-light: #dbeafe;
  --geometric: #9333ea;
  --geometric-light: #f3e8ff;
  --fibonacci: #059669;
  --fibonacci-light: #d1fae5;
  --custom: #d97706;
  --custom-light: #fef3c7;
  --danger: #dc2626;
  --radius: 8px;
  --shadow: 0 1px 3px rgba(0,0,0,0.08), 0 1px 2px rgba(0,0,0,0.06);
  --shadow-md: 0 4px 6px rgba(0,0,0,0.07), 0 2px 4px rgba(0,0,0,0.06);
}
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: var(--bg); color: var(--text); line-height: 1.6; }

/* Header */
.header { position: sticky; top: 0; z-index: 100; background: var(--accent); color: #fff; padding: 16px 24px; box-shadow: var(--shadow-md); }
.header h1 { font-size: 1.5rem; font-weight: 700; letter-spacing: -0.02em; }
.header p { font-size: 0.85rem; opacity: 0.85; margin-top: 2px; }

/* Layout */
.container { max-width: 1200px; margin: 0 auto; padding: 20px; }

/* Tabs */
.tabs { display: flex; gap: 6px; margin-bottom: 20px; flex-wrap: wrap; }
.tab-btn { padding: 10px 20px; border: 2px solid var(--border); background: var(--surface); border-radius: var(--radius); cursor: pointer; font-size: 0.9rem; font-weight: 600; transition: all 0.2s; }
.tab-btn:hover { transform: translateY(-1px); box-shadow: var(--shadow); }
.tab-btn[data-type="arithmetic"] { color: var(--arithmetic); }
.tab-btn[data-type="geometric"] { color: var(--geometric); }
.tab-btn[data-type="fibonacci"] { color: var(--fibonacci); }
.tab-btn[data-type="custom"] { color: var(--custom); }
.tab-btn.active[data-type="arithmetic"] { background: var(--arithmetic); color: #fff; border-color: var(--arithmetic); }
.tab-btn.active[data-type="geometric"] { background: var(--geometric); color: #fff; border-color: var(--geometric); }
.tab-btn.active[data-type="fibonacci"] { background: var(--fibonacci); color: #fff; border-color: var(--fibonacci); }
.tab-btn.active[data-type="custom"] { background: var(--custom); color: #fff; border-color: var(--custom); }

/* Panels */
.tab-panel { display: none; }
.tab-panel.active { display: block; }

/* Cards */
.card { background: var(--surface); border-radius: var(--radius); padding: 20px; margin-bottom: 16px; box-shadow: var(--shadow); border: 1px solid var(--border); }
.card h3 { font-size: 1.1rem; margin-bottom: 12px; }
.card h4 { font-size: 0.95rem; margin-bottom: 8px; color: var(--text-muted); }

/* Inputs */
.input-row { display: flex; gap: 16px; flex-wrap: wrap; align-items: flex-end; margin-bottom: 16px; }
.input-group { display: flex; flex-direction: column; gap: 4px; }
.input-group label { font-size: 0.8rem; font-weight: 600; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em; }
.input-group input { padding: 8px 12px; border: 2px solid var(--border); border-radius: var(--radius); font-size: 1rem; width: 120px; transition: border-color 0.2s; }
.input-group input:focus { outline: none; border-color: var(--accent); }
.input-group input.wide { width: 300px; }
.btn { padding: 8px 20px; border: none; border-radius: var(--radius); font-size: 0.9rem; font-weight: 600; cursor: pointer; transition: all 0.2s; }
.btn-primary { background: var(--accent); color: #fff; }
.btn-primary:hover { opacity: 0.9; }

/* Term blocks */
.term-grid { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px; }
.term-block { display: flex; flex-direction: column; align-items: center; padding: 8px 6px; border-radius: var(--radius); min-width: 52px; transition: transform 0.2s; }
.term-block:hover { transform: scale(1.08); }
.term-block .term-index { font-size: 0.65rem; font-weight: 700; opacity: 0.6; margin-bottom: 2px; }
.term-block .term-value { font-size: 0.95rem; font-weight: 700; }

/* Formula box */
.formula-box { background: #f8fafc; border: 2px dashed var(--border); border-radius: var(--radius); padding: 16px; margin-bottom: 16px; font-family: 'Cambria Math', 'Times New Roman', serif; }
.formula-box .formula-label { font-size: 0.75rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-muted); margin-bottom: 6px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
.formula-box .formula { font-size: 1.2rem; color: var(--text); }
.formula-box .formula sub { font-size: 0.7em; }
.formula-box .formula sup { font-size: 0.7em; }

/* Chart area */
.chart-container { position: relative; width: 100%; height: 300px; background: #fafbfc; border-radius: var(--radius); border: 1px solid var(--border); overflow: hidden; }
canvas { width: 100% !important; height: 100% !important; }

/* Bar chart */
.bar-chart { display: flex; align-items: flex-end; gap: 3px; height: 200px; padding: 10px 4px; }
.bar { border-radius: 3px 3px 0 0; min-width: 8px; flex: 1; transition: height 0.4s ease; position: relative; cursor: pointer; }
.bar:hover::after { content: attr(data-tip); position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background: var(--text); color: #fff; padding: 3px 8px; border-radius: 4px; font-size: 0.75rem; white-space: nowrap; }

/* Sum display */
.sum-display { font-size: 1.8rem; font-weight: 700; text-align: center; padding: 16px; }

/* Convergence badge */
.convergence-badge { display: inline-block; padding: 4px 12px; border-radius: 20px; font-size: 0.8rem; font-weight: 600; margin-left: 8px; }
.converges { background: #d1fae5; color: #065f46; }
.diverges { background: #fee2e2; color: #991b1b; }

/* Info panel */
.info-panel { background: linear-gradient(135deg, #eff6ff 0%, #f5f3ff 100%); border-radius: var(--radius); padding: 24px; margin-top: 20px; border: 1px solid var(--border); }
.info-panel h3 { color: var(--accent); margin-bottom: 12px; }
.info-panel p, .info-panel li { font-size: 0.9rem; color: var(--text-muted); margin-bottom: 8px; }
.info-panel ul { padding-left: 20px; }

/* Grid layout */
.grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }

/* Golden ratio display */
.golden-ratio { text-align: center; padding: 16px; }
.golden-ratio .phi { font-size: 2.5rem; font-weight: 700; color: var(--fibonacci); }
.golden-ratio .phi-label { font-size: 0.85rem; color: var(--text-muted); }

/* Custom result */
.pattern-result { padding: 12px 16px; border-radius: var(--radius); font-weight: 600; margin-top: 12px; }
.pattern-found { background: #d1fae5; color: #065f46; }
.pattern-none { background: #fef3c7; color: #92400e; }

/* Responsive */
@media (max-width: 768px) {
  .grid-2 { grid-template-columns: 1fr; }
  .header h1 { font-size: 1.2rem; }
  .input-group input { width: 90px; }
  .input-group input.wide { width: 100%; }
  .tabs { gap: 4px; }
  .tab-btn { padding: 8px 14px; font-size: 0.8rem; }
  .container { padding: 12px; }
}
</style>
</head>
<body>

<div class="header">
  <h1>Sequences &amp; Series Explorer</h1>
  <p>Arithmetic, geometric, Fibonacci and custom sequences: nth term formulas, visual representations, and sum calculations</p>
</div>

<div class="container">
  <div class="tabs">
    <button class="tab-btn active" data-type="arithmetic" onclick="switchTab('arithmetic')">Arithmetic</button>
    <button class="tab-btn" data-type="geometric" onclick="switchTab('geometric')">Geometric</button>
    <button class="tab-btn" data-type="fibonacci" onclick="switchTab('fibonacci')">Fibonacci</button>
    <button class="tab-btn" data-type="custom" onclick="switchTab('custom')">Custom</button>
  </div>

  <!-- ARITHMETIC -->
  <div class="tab-panel active" id="panel-arithmetic">
    <div class="card">
      <h3>Arithmetic Sequence Parameters</h3>
      <div class="input-row">
        <div class="input-group">
          <label>First term (a)</label>
          <input type="number" id="arith-a" value="3" onchange="updateArithmetic()">
        </div>
        <div class="input-group">
          <label>Common difference (d)</label>
          <input type="number" id="arith-d" value="5" step="any" onchange="updateArithmetic()">
        </div>
        <div class="input-group">
          <label>Number of terms</label>
          <input type="number" id="arith-n" value="20" min="2" max="50" onchange="updateArithmetic()">
        </div>
      </div>
    </div>

    <div class="card">
      <h3>Formulas</h3>
      <div class="grid-2">
        <div class="formula-box">
          <div class="formula-label">nth term</div>
          <div class="formula" id="arith-nth-formula">a<sub>n</sub> = a + (n - 1)d</div>
        </div>
        <div class="formula-box">
          <div class="formula-label">Sum of first n terms</div>
          <div class="formula" id="arith-sum-formula">S<sub>n</sub> = n/2 (2a + (n - 1)d)</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h3>Terms</h3>
      <div class="term-grid" id="arith-terms"></div>
    </div>

    <div class="grid-2">
      <div class="card">
        <h3>Bar Chart</h3>
        <div class="bar-chart" id="arith-bars"></div>
      </div>
      <div class="card">
        <h3>Line Graph</h3>
        <div class="chart-container"><canvas id="arith-chart"></canvas></div>
      </div>
    </div>

    <div class="card">
      <h3>Sum Calculator</h3>
      <div class="input-row">
        <div class="input-group">
          <label>Sum of first n terms</label>
          <input type="number" id="arith-sum-n" value="10" min="1" max="100" onchange="updateArithmeticSum()">
        </div>
      </div>
      <div class="sum-display" id="arith-sum-value" style="color: var(--arithmetic);">S<sub>10</sub> = 255</div>
      <div class="bar-chart" id="arith-sum-bars" style="height:140px;"></div>
    </div>
  </div>

  <!-- GEOMETRIC -->
  <div class="tab-panel" id="panel-geometric">
    <div class="card">
      <h3>Geometric Sequence Parameters</h3>
      <div class="input-row">
        <div class="input-group">
          <label>First term (a)</label>
          <input type="number" id="geo-a" value="2" step="any" onchange="updateGeometric()">
        </div>
        <div class="input-group">
          <label>Common ratio (r)</label>
          <input type="number" id="geo-r" value="1.5" step="any" onchange="updateGeometric()">
        </div>
        <div class="input-group">
          <label>Number of terms</label>
          <input type="number" id="geo-n" value="15" min="2" max="30" onchange="updateGeometric()">
        </div>
      </div>
    </div>

    <div class="card">
      <h3>Formulas <span id="geo-convergence-badge"></span></h3>
      <div class="grid-2">
        <div class="formula-box">
          <div class="formula-label">nth term</div>
          <div class="formula" id="geo-nth-formula">a<sub>n</sub> = a . r<sup>(n-1)</sup></div>
        </div>
        <div class="formula-box">
          <div class="formula-label">Sum of first n terms</div>
          <div class="formula" id="geo-sum-formula">S<sub>n</sub> = a(1 - r<sup>n</sup>) / (1 - r)</div>
        </div>
      </div>
      <div class="formula-box" id="geo-infinite-sum" style="display:none;">
        <div class="formula-label">Sum to infinity (|r| &lt; 1)</div>
        <div class="formula" id="geo-inf-formula">S<sub>&infin;</sub> = a / (1 - r)</div>
      </div>
    </div>

    <div class="card">
      <h3>Terms</h3>
      <div class="term-grid" id="geo-terms"></div>
    </div>

    <div class="grid-2">
      <div class="card">
        <h3>Bar Chart</h3>
        <div class="bar-chart" id="geo-bars"></div>
      </div>
      <div class="card">
        <h3>Line Graph</h3>
        <div class="chart-container"><canvas id="geo-chart"></canvas></div>
      </div>
    </div>

    <div class="card">
      <h3>Sum Calculator</h3>
      <div class="input-row">
        <div class="input-group">
          <label>Sum of first n terms</label>
          <input type="number" id="geo-sum-n" value="10" min="1" max="50" onchange="updateGeometricSum()">
        </div>
      </div>
      <div class="sum-display" id="geo-sum-value" style="color: var(--geometric);">S<sub>10</sub> = 0</div>
      <div id="geo-convergence-info" style="text-align:center;font-size:0.9rem;color:var(--text-muted);margin-top:8px;"></div>
    </div>
  </div>

  <!-- FIBONACCI -->
  <div class="tab-panel" id="panel-fibonacci">
    <div class="card">
      <h3>Fibonacci Sequence</h3>
      <p style="color:var(--text-muted);margin-bottom:12px;">Each term is the sum of the two preceding terms: F(n) = F(n-1) + F(n-2), starting with F(1) = 1 and F(2) = 1.</p>
      <div class="input-row">
        <div class="input-group">
          <label>Number of terms</label>
          <input type="number" id="fib-n" value="20" min="2" max="40" onchange="updateFibonacci()">
        </div>
      </div>
    </div>

    <div class="card">
      <h3>Terms</h3>
      <div class="term-grid" id="fib-terms"></div>
    </div>

    <div class="grid-2">
      <div class="card">
        <h3>Fibonacci Spiral</h3>
        <div class="chart-container"><canvas id="fib-spiral"></canvas></div>
      </div>
      <div class="card">
        <h3>Golden Ratio Convergence</h3>
        <div class="golden-ratio">
          <div class="phi">&phi; = 1.6180339...</div>
          <div class="phi-label">The ratio F(n+1)/F(n) approaches the golden ratio</div>
        </div>
        <div class="chart-container" style="height:200px;margin-top:12px;"><canvas id="fib-ratio-chart"></canvas></div>
      </div>
    </div>

    <div class="card">
      <h3>Growth Chart</h3>
      <div class="chart-container"><canvas id="fib-chart"></canvas></div>
    </div>
  </div>

  <!-- CUSTOM -->
  <div class="tab-panel" id="panel-custom">
    <div class="card">
      <h3>Custom Sequence Identifier</h3>
      <p style="color:var(--text-muted);margin-bottom:12px;">Enter at least 3 terms separated by commas. The app will try to identify the pattern and predict the next terms.</p>
      <div class="input-row">
        <div class="input-group">
          <label>Enter terms (comma-separated)</label>
          <input type="text" id="custom-input" class="wide" value="2, 6, 18, 54" placeholder="e.g. 2, 5, 8, 11">
        </div>
        <button class="btn btn-primary" onclick="analyseCustom()">Analyse</button>
      </div>
      <div id="custom-result"></div>
    </div>

    <div class="card" id="custom-details" style="display:none;">
      <h3>Identified Pattern</h3>
      <div class="formula-box" id="custom-formula-box">
        <div class="formula-label">Pattern</div>
        <div class="formula" id="custom-formula"></div>
      </div>
      <h4>Predicted next 5 terms</h4>
      <div class="term-grid" id="custom-predicted"></div>
      <div class="chart-container" style="margin-top:16px;"><canvas id="custom-chart"></canvas></div>
    </div>
  </div>

  <!-- INFO PANEL -->
  <div class="info-panel">
    <h3>Sequences vs Series</h3>
    <p>A <strong>sequence</strong> is an ordered list of numbers following a rule. A <strong>series</strong> is the sum of the terms of a sequence.</p>
    <h3 style="margin-top:16px;">Key Concepts</h3>
    <ul>
      <li><strong>Arithmetic sequence:</strong> constant difference between consecutive terms. Growth is linear.</li>
      <li><strong>Geometric sequence:</strong> constant ratio between consecutive terms. Growth is exponential (or decay when |r| &lt; 1).</li>
      <li><strong>Fibonacci sequence:</strong> each term is the sum of the two previous terms. Growth rate approaches the golden ratio.</li>
      <li><strong>Convergence:</strong> a geometric series converges (has a finite sum to infinity) only when |r| &lt; 1.</li>
    </ul>
    <h3 style="margin-top:16px;">Real-world Applications</h3>
    <ul>
      <li>Arithmetic: salary increases by a fixed amount each year, seat numbering in stadiums.</li>
      <li>Geometric: compound interest, population growth, radioactive decay, signal attenuation.</li>
      <li>Fibonacci: phyllotaxis (leaf arrangement), shell spirals, branching patterns in trees, financial trading models.</li>
    </ul>
  </div>
</div>

<script>
/* ============================
   Tab Switching
   ============================ */
function switchTab(type) {
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
  document.querySelector(`.tab-btn[data-type="${type}"]`).classList.add('active');
  document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
  document.getElementById('panel-' + type).classList.add('active');
}

/* ============================
   Utility: format number nicely
   ============================ */
function fmt(n) {
  if (Math.abs(n) >= 1e9) return n.toExponential(2);
  if (Number.isInteger(n)) return n.toLocaleString();
  return parseFloat(n.toPrecision(8)).toLocaleString(undefined, { maximumFractionDigits: 6 });
}

/* ============================
   Canvas Line Chart Renderer
   ============================ */
function drawLineChart(canvasId, data, color, labelX, labelY) {
  const canvas = document.getElementById(canvasId);
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  const W = rect.width, H = rect.height;
  const pad = { top: 20, right: 20, bottom: 32, left: 55 };
  const plotW = W - pad.left - pad.right;
  const plotH = H - pad.top - pad.bottom;

  ctx.clearRect(0, 0, W, H);

  if (data.length === 0) return;

  const minY = Math.min(...data, 0);
  const maxY = Math.max(...data);
  const rangeY = maxY - minY || 1;

  function xPos(i) { return pad.left + (i / (data.length - 1 || 1)) * plotW; }
  function yPos(v) { return pad.top + plotH - ((v - minY) / rangeY) * plotH; }

  // Grid lines
  ctx.strokeStyle = '#e2e8f0';
  ctx.lineWidth = 1;
  const yTicks = 5;
  for (let i = 0; i <= yTicks; i++) {
    const v = minY + (rangeY * i / yTicks);
    const y = yPos(v);
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(W - pad.right, y); ctx.stroke();
    ctx.fillStyle = '#94a3b8'; ctx.font = '11px sans-serif'; ctx.textAlign = 'right';
    ctx.fillText(fmt(v), pad.left - 6, y + 4);
  }

  // Axis labels
  ctx.fillStyle = '#94a3b8'; ctx.font = '11px sans-serif'; ctx.textAlign = 'center';
  for (let i = 0; i < data.length; i++) {
    if (data.length <= 25 || i % Math.ceil(data.length / 15) === 0) {
      ctx.fillText(i + 1, xPos(i), H - 8);
    }
  }

  // Line
  ctx.strokeStyle = color;
  ctx.lineWidth = 2.5;
  ctx.lineJoin = 'round';
  ctx.beginPath();
  data.forEach((v, i) => {
    const x = xPos(i), y = yPos(v);
    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
  });
  ctx.stroke();

  // Dots
  ctx.fillStyle = color;
  data.forEach((v, i) => {
    if (data.length <= 25 || i % Math.ceil(data.length / 20) === 0) {
      ctx.beginPath();
      ctx.arc(xPos(i), yPos(v), 3.5, 0, Math.PI * 2);
      ctx.fill();
    }
  });
}

/* ============================
   Bar chart renderer (DOM)
   ============================ */
function renderBars(containerId, data, color) {
  const container = document.getElementById(containerId);
  container.innerHTML = '';
  if (data.length === 0) return;
  const absMax = Math.max(...data.map(Math.abs), 0.001);
  data.forEach((v, i) => {
    const bar = document.createElement('div');
    bar.className = 'bar';
    const h = Math.max(2, (Math.abs(v) / absMax) * 100);
    bar.style.height = h + '%';
    bar.style.background = color;
    bar.style.opacity = 0.5 + 0.5 * (Math.abs(v) / absMax);
    bar.setAttribute('data-tip', `n=${i + 1}: ${fmt(v)}`);
    container.appendChild(bar);
  });
}

/* ============================
   ARITHMETIC SEQUENCE
   ============================ */
function getArithTerms() {
  const a = parseFloat(document.getElementById('arith-a').value) || 0;
  const d = parseFloat(document.getElementById('arith-d').value) || 0;
  const n = parseInt(document.getElementById('arith-n').value) || 20;
  const terms = [];
  for (let i = 0; i < n; i++) terms.push(a + i * d);
  return { a, d, n, terms };
}

function updateArithmetic() {
  const { a, d, n, terms } = getArithTerms();

  // Formula display
  document.getElementById('arith-nth-formula').innerHTML =
    `a<sub>n</sub> = ${fmt(a)} + (n - 1) &times; ${fmt(d)}`;
  document.getElementById('arith-sum-formula').innerHTML =
    `S<sub>n</sub> = n/2 &times; (2&times;${fmt(a)} + (n - 1)&times;${fmt(d)})`;

  // Term blocks
  const grid = document.getElementById('arith-terms');
  grid.innerHTML = '';
  terms.forEach((v, i) => {
    const block = document.createElement('div');
    block.className = 'term-block';
    block.style.background = 'var(--arithmetic-light)';
    block.style.color = 'var(--arithmetic)';
    block.innerHTML = `<span class="term-index">n=${i + 1}</span><span class="term-value">${fmt(v)}</span>`;
    grid.appendChild(block);
  });

  // Charts
  renderBars('arith-bars', terms, 'var(--arithmetic)');
  drawLineChart('arith-chart', terms, '#2563eb');

  updateArithmeticSum();
}

function updateArithmeticSum() {
  const { a, d } = getArithTerms();
  const sn = parseInt(document.getElementById('arith-sum-n').value) || 10;
  const sum = (sn / 2) * (2 * a + (sn - 1) * d);
  document.getElementById('arith-sum-value').innerHTML = `S<sub>${sn}</sub> = ${fmt(sum)}`;

  // Partial sums bar
  const partials = [];
  for (let i = 1; i <= sn; i++) {
    partials.push((i / 2) * (2 * a + (i - 1) * d));
  }
  renderBars('arith-sum-bars', partials, '#60a5fa');
}

/* ============================
   GEOMETRIC SEQUENCE
   ============================ */
function getGeoTerms() {
  const a = parseFloat(document.getElementById('geo-a').value) || 1;
  const r = parseFloat(document.getElementById('geo-r').value) || 2;
  const n = parseInt(document.getElementById('geo-n').value) || 15;
  const terms = [];
  for (let i = 0; i < n; i++) terms.push(a * Math.pow(r, i));
  return { a, r, n, terms };
}

function updateGeometric() {
  const { a, r, n, terms } = getGeoTerms();
  const converges = Math.abs(r) < 1;

  // Convergence badge
  const badge = document.getElementById('geo-convergence-badge');
  if (r === 1) {
    badge.innerHTML = '<span class="convergence-badge converges">Constant (r = 1)</span>';
  } else if (converges) {
    badge.innerHTML = '<span class="convergence-badge converges">Converges (|r| &lt; 1)</span>';
  } else {
    badge.innerHTML = '<span class="convergence-badge diverges">Diverges (|r| &ge; 1)</span>';
  }

  // Formula
  document.getElementById('geo-nth-formula').innerHTML =
    `a<sub>n</sub> = ${fmt(a)} &times; ${fmt(r)}<sup>(n-1)</sup>`;
  if (r === 1) {
    document.getElementById('geo-sum-formula').innerHTML = `S<sub>n</sub> = n &times; ${fmt(a)}`;
  } else {
    document.getElementById('geo-sum-formula').innerHTML =
      `S<sub>n</sub> = ${fmt(a)} &times; (1 - ${fmt(r)}<sup>n</sup>) / (1 - ${fmt(r)})`;
  }

  // Infinite sum
  const infBox = document.getElementById('geo-infinite-sum');
  if (converges && r !== 0) {
    infBox.style.display = 'block';
    const infSum = a / (1 - r);
    document.getElementById('geo-inf-formula').innerHTML =
      `S<sub>&infin;</sub> = ${fmt(a)} / (1 - ${fmt(r)}) = ${fmt(infSum)}`;
  } else {
    infBox.style.display = 'none';
  }

  // Term blocks
  const grid = document.getElementById('geo-terms');
  grid.innerHTML = '';
  terms.forEach((v, i) => {
    const block = document.createElement('div');
    block.className = 'term-block';
    block.style.background = 'var(--geometric-light)';
    block.style.color = 'var(--geometric)';
    const scale = converges ? 1 : Math.min(1.3, 0.7 + 0.6 * (i / n));
    block.style.transform = `scale(${scale})`;
    block.innerHTML = `<span class="term-index">n=${i + 1}</span><span class="term-value">${fmt(v)}</span>`;
    grid.appendChild(block);
  });

  // Charts
  renderBars('geo-bars', terms, 'var(--geometric)');
  drawLineChart('geo-chart', terms, '#9333ea');

  updateGeometricSum();
}

function updateGeometricSum() {
  const { a, r } = getGeoTerms();
  const sn = parseInt(document.getElementById('geo-sum-n').value) || 10;
  let sum;
  if (r === 1) {
    sum = a * sn;
  } else {
    sum = a * (1 - Math.pow(r, sn)) / (1 - r);
  }
  document.getElementById('geo-sum-value').innerHTML = `S<sub>${sn}</sub> = ${fmt(sum)}`;

  const converges = Math.abs(r) < 1;
  const infoEl = document.getElementById('geo-convergence-info');
  if (converges && r !== 0) {
    const infSum = a / (1 - r);
    const pct = ((sum / infSum) * 100).toFixed(1);
    infoEl.textContent = `This partial sum is ${pct}% of the sum to infinity (${fmt(infSum)}).`;
  } else {
    infoEl.textContent = '';
  }
}

/* ============================
   FIBONACCI SEQUENCE
   ============================ */
function getFibTerms() {
  const n = parseInt(document.getElementById('fib-n').value) || 20;
  const terms = [1, 1];
  for (let i = 2; i < n; i++) terms.push(terms[i - 1] + terms[i - 2]);
  return { n, terms };
}

function updateFibonacci() {
  const { n, terms } = getFibTerms();

  // Term blocks
  const grid = document.getElementById('fib-terms');
  grid.innerHTML = '';
  terms.forEach((v, i) => {
    const block = document.createElement('div');
    block.className = 'term-block';
    block.style.background = 'var(--fibonacci-light)';
    block.style.color = 'var(--fibonacci)';
    block.innerHTML = `<span class="term-index">F(${i + 1})</span><span class="term-value">${fmt(v)}</span>`;
    grid.appendChild(block);
  });

  // Growth chart
  drawLineChart('fib-chart', terms, '#059669');

  // Golden ratio convergence chart
  const ratios = [];
  for (let i = 1; i < terms.length; i++) {
    ratios.push(terms[i] / terms[i - 1]);
  }
  drawRatioChart(ratios);

  // Fibonacci spiral
  drawFibSpiral(terms);
}

function drawRatioChart(ratios) {
  const canvas = document.getElementById('fib-ratio-chart');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = 200 * dpr;
  ctx.scale(dpr, dpr);
  const W = rect.width, H = 200;
  const pad = { top: 15, right: 15, bottom: 28, left: 50 };
  const plotW = W - pad.left - pad.right;
  const plotH = H - pad.top - pad.bottom;

  ctx.clearRect(0, 0, W, H);

  const phi = (1 + Math.sqrt(5)) / 2;
  const minY = Math.min(...ratios, phi) - 0.2;
  const maxY = Math.max(...ratios, phi) + 0.2;
  const rangeY = maxY - minY || 1;

  function xPos(i) { return pad.left + (i / (ratios.length - 1 || 1)) * plotW; }
  function yPos(v) { return pad.top + plotH - ((v - minY) / rangeY) * plotH; }

  // Golden ratio line
  ctx.strokeStyle = '#fbbf24';
  ctx.lineWidth = 2;
  ctx.setLineDash([6, 4]);
  const phiY = yPos(phi);
  ctx.beginPath(); ctx.moveTo(pad.left, phiY); ctx.lineTo(W - pad.right, phiY); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = '#d97706'; ctx.font = '11px sans-serif'; ctx.textAlign = 'left';
  ctx.fillText('\u03C6 = ' + phi.toFixed(6), pad.left + 4, phiY - 6);

  // Ratio line
  ctx.strokeStyle = '#059669';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ratios.forEach((v, i) => {
    i === 0 ? ctx.moveTo(xPos(i), yPos(v)) : ctx.lineTo(xPos(i), yPos(v));
  });
  ctx.stroke();

  // Dots
  ctx.fillStyle = '#059669';
  ratios.forEach((v, i) => {
    ctx.beginPath();
    ctx.arc(xPos(i), yPos(v), 3, 0, Math.PI * 2);
    ctx.fill();
  });

  // Axis labels
  ctx.fillStyle = '#94a3b8'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
  ratios.forEach((_, i) => {
    if (ratios.length <= 25 || i % Math.ceil(ratios.length / 12) === 0) {
      ctx.fillText(i + 2, xPos(i), H - 8);
    }
  });
  ctx.textAlign = 'right';
  const ySteps = 4;
  for (let i = 0; i <= ySteps; i++) {
    const v = minY + (rangeY * i / ySteps);
    ctx.fillText(v.toFixed(2), pad.left - 4, yPos(v) + 4);
  }
}

function drawFibSpiral(terms) {
  const canvas = document.getElementById('fib-spiral');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  const W = rect.width, H = rect.height;
  ctx.clearRect(0, 0, W, H);

  // Draw Fibonacci spiral using squares
  const maxSquares = Math.min(terms.length, 12);
  const fibTerms = terms.slice(0, maxSquares);
  const totalSize = fibTerms[fibTerms.length - 1] + (fibTerms.length > 1 ? fibTerms[fibTerms.length - 2] : 0);
  const scale = Math.min(W, H) * 0.85 / (totalSize || 1);

  ctx.save();
  ctx.translate(W / 2, H / 2);

  // Directions: right, up, left, down
  const dirs = [
    { dx: 1, dy: 0 },
    { dx: 0, dy: -1 },
    { dx: -1, dy: 0 },
    { dx: 0, dy: 1 }
  ];

  let x = 0, y = 0;
  const colors = ['#d1fae5', '#a7f3d0', '#6ee7b7', '#34d399', '#10b981', '#059669', '#047857', '#065f46', '#064e3b', '#022c22', '#014737', '#0d3d30'];

  // Draw squares and arcs
  const squares = [];
  for (let i = 0; i < fibTerms.length; i++) {
    const size = fibTerms[i] * scale;
    const dir = dirs[i % 4];

    let sx, sy;
    if (i === 0) {
      sx = -size / 2;
      sy = -size / 2;
    } else {
      const prevSq = squares[i - 1];
      const d = i % 4;
      if (d === 0) { sx = prevSq.x + prevSq.size; sy = prevSq.y + prevSq.size - size; }
      else if (d === 1) { sx = prevSq.x + prevSq.size - size; sy = prevSq.y - size; }
      else if (d === 2) { sx = prevSq.x - size; sy = prevSq.y; }
      else { sx = prevSq.x; sy = prevSq.y + prevSq.size; }
    }

    squares.push({ x: sx, y: sy, size });

    ctx.fillStyle = colors[i % colors.length];
    ctx.globalAlpha = 0.3;
    ctx.fillRect(sx, sy, size, size);
    ctx.globalAlpha = 1;
    ctx.strokeStyle = '#059669';
    ctx.lineWidth = 1;
    ctx.strokeRect(sx, sy, size, size);

    // Label
    if (size > 15) {
      ctx.fillStyle = '#065f46';
      ctx.font = `${Math.max(9, Math.min(14, size * 0.3))}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillText(fibTerms[i], sx + size / 2, sy + size / 2 + 4);
    }
  }

  // Draw spiral arcs
  ctx.strokeStyle = '#059669';
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  for (let i = 0; i < squares.length; i++) {
    const sq = squares[i];
    const r = sq.size;
    const d = i % 4;
    let cx, cy, startAngle;
    if (d === 0) { cx = sq.x; cy = sq.y + r; startAngle = -Math.PI / 2; }
    else if (d === 1) { cx = sq.x + r; cy = sq.y + r; startAngle = Math.PI; }
    else if (d === 2) { cx = sq.x + r; cy = sq.y; startAngle = Math.PI / 2; }
    else { cx = sq.x; cy = sq.y; startAngle = 0; }
    ctx.arc(cx, cy, r, startAngle, startAngle + Math.PI / 2);
  }
  ctx.stroke();

  ctx.restore();
}

/* ============================
   CUSTOM SEQUENCE ANALYSIS
   ============================ */
function analyseCustom() {
  const raw = document.getElementById('custom-input').value;
  const terms = raw.split(',').map(s => parseFloat(s.trim())).filter(n => !isNaN(n));
  const resultEl = document.getElementById('custom-result');
  const detailsEl = document.getElementById('custom-details');

  if (terms.length < 3) {
    resultEl.innerHTML = '<div class="pattern-result pattern-none">Please enter at least 3 terms.</div>';
    detailsEl.style.display = 'none';
    return;
  }

  // Check arithmetic
  const diffs = [];
  for (let i = 1; i < terms.length; i++) diffs.push(terms[i] - terms[i - 1]);
  const isArithmetic = diffs.every(d => Math.abs(d - diffs[0]) < 1e-9);

  // Check geometric
  let isGeometric = terms[0] !== 0;
  const ratios = [];
  if (isGeometric) {
    for (let i = 1; i < terms.length; i++) {
      if (terms[i - 1] === 0) { isGeometric = false; break; }
      ratios.push(terms[i] / terms[i - 1]);
    }
    if (isGeometric) isGeometric = ratios.every(r => Math.abs(r - ratios[0]) < 1e-9);
  }

  // Check Fibonacci-like
  let isFibLike = terms.length >= 3;
  for (let i = 2; i < terms.length; i++) {
    if (Math.abs(terms[i] - (terms[i - 1] + terms[i - 2])) > 1e-9) { isFibLike = false; break; }
  }

  // Check quadratic (second differences constant)
  let isQuadratic = false;
  if (!isArithmetic && terms.length >= 4) {
    const secondDiffs = [];
    for (let i = 1; i < diffs.length; i++) secondDiffs.push(diffs[i] - diffs[i - 1]);
    isQuadratic = secondDiffs.every(d => Math.abs(d - secondDiffs[0]) < 1e-9);
  }

  let predicted = [];
  let patternName = '';
  let formulaText = '';

  if (isArithmetic) {
    const a = terms[0], d = diffs[0];
    patternName = 'Arithmetic Sequence';
    formulaText = `a<sub>n</sub> = ${fmt(a)} + (n - 1) &times; ${fmt(d)}`;
    for (let i = 0; i < 5; i++) predicted.push(a + (terms.length + i) * d);
    resultEl.innerHTML = `<div class="pattern-result pattern-found">Identified: <strong>Arithmetic</strong> with first term = ${fmt(a)} and common difference = ${fmt(d)}</div>`;
  } else if (isGeometric) {
    const a = terms[0], r = ratios[0];
    patternName = 'Geometric Sequence';
    formulaText = `a<sub>n</sub> = ${fmt(a)} &times; ${fmt(r)}<sup>(n-1)</sup>`;
    for (let i = 0; i < 5; i++) predicted.push(a * Math.pow(r, terms.length + i));
    resultEl.innerHTML = `<div class="pattern-result pattern-found">Identified: <strong>Geometric</strong> with first term = ${fmt(a)} and common ratio = ${fmt(r)}</div>`;
  } else if (isFibLike) {
    patternName = 'Fibonacci-like Sequence';
    formulaText = `a<sub>n</sub> = a<sub>n-1</sub> + a<sub>n-2</sub> (starting with ${fmt(terms[0])}, ${fmt(terms[1])})`;
    let prev2 = terms[terms.length - 2], prev1 = terms[terms.length - 1];
    for (let i = 0; i < 5; i++) {
      const next = prev1 + prev2;
      predicted.push(next);
      prev2 = prev1; prev1 = next;
    }
    resultEl.innerHTML = `<div class="pattern-result pattern-found">Identified: <strong>Fibonacci-like</strong> (each term = sum of previous two)</div>`;
  } else if (isQuadratic) {
    const secondDiffs = [];
    for (let i = 1; i < diffs.length; i++) secondDiffs.push(diffs[i] - diffs[i - 1]);
    const sd = secondDiffs[0];
    patternName = 'Quadratic Sequence';
    formulaText = `Second difference is constant: ${fmt(sd)}. This is a quadratic sequence.`;
    let lastDiff = diffs[diffs.length - 1];
    let lastVal = terms[terms.length - 1];
    for (let i = 0; i < 5; i++) {
      lastDiff += sd;
      lastVal += lastDiff;
      predicted.push(lastVal);
    }
    resultEl.innerHTML = `<div class="pattern-result pattern-found">Identified: <strong>Quadratic</strong> with constant second difference = ${fmt(sd)}</div>`;
  } else {
    patternName = 'Unknown';
    formulaText = 'No standard pattern detected. Showing linear extrapolation as a rough estimate.';
    const avgDiff = diffs.reduce((s, d) => s + d, 0) / diffs.length;
    let lastVal = terms[terms.length - 1];
    for (let i = 0; i < 5; i++) {
      lastVal += avgDiff;
      predicted.push(lastVal);
    }
    resultEl.innerHTML = '<div class="pattern-result pattern-none">No standard arithmetic, geometric, Fibonacci, or quadratic pattern detected. Showing linear extrapolation.</div>';
  }

  detailsEl.style.display = 'block';
  document.getElementById('custom-formula').innerHTML = formulaText;

  // Predicted blocks
  const predGrid = document.getElementById('custom-predicted');
  predGrid.innerHTML = '';
  predicted.forEach((v, i) => {
    const block = document.createElement('div');
    block.className = 'term-block';
    block.style.background = 'var(--custom-light)';
    block.style.color = 'var(--custom)';
    block.innerHTML = `<span class="term-index">n=${terms.length + i + 1}</span><span class="term-value">${fmt(v)}</span>`;
    predGrid.appendChild(block);
  });

  // Chart with original + predicted
  const all = [...terms, ...predicted];
  drawCustomChart(all, terms.length);
}

function drawCustomChart(data, originalCount) {
  const canvas = document.getElementById('custom-chart');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  const W = rect.width, H = rect.height;
  const pad = { top: 20, right: 20, bottom: 32, left: 55 };
  const plotW = W - pad.left - pad.right;
  const plotH = H - pad.top - pad.bottom;

  ctx.clearRect(0, 0, W, H);
  if (data.length === 0) return;

  const minY = Math.min(...data, 0);
  const maxY = Math.max(...data);
  const rangeY = maxY - minY || 1;

  function xPos(i) { return pad.left + (i / (data.length - 1 || 1)) * plotW; }
  function yPos(v) { return pad.top + plotH - ((v - minY) / rangeY) * plotH; }

  // Grid
  ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 1;
  for (let i = 0; i <= 5; i++) {
    const v = minY + (rangeY * i / 5);
    const y = yPos(v);
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(W - pad.right, y); ctx.stroke();
    ctx.fillStyle = '#94a3b8'; ctx.font = '11px sans-serif'; ctx.textAlign = 'right';
    ctx.fillText(fmt(v), pad.left - 6, y + 4);
  }

  // Original line
  ctx.strokeStyle = '#d97706'; ctx.lineWidth = 2.5;
  ctx.beginPath();
  for (let i = 0; i < originalCount; i++) {
    i === 0 ? ctx.moveTo(xPos(i), yPos(data[i])) : ctx.lineTo(xPos(i), yPos(data[i]));
  }
  ctx.stroke();

  // Predicted line (dashed)
  ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 2; ctx.setLineDash([6, 4]);
  ctx.beginPath();
  for (let i = originalCount - 1; i < data.length; i++) {
    i === originalCount - 1 ? ctx.moveTo(xPos(i), yPos(data[i])) : ctx.lineTo(xPos(i), yPos(data[i]));
  }
  ctx.stroke();
  ctx.setLineDash([]);

  // Dots: original
  ctx.fillStyle = '#d97706';
  for (let i = 0; i < originalCount; i++) {
    ctx.beginPath(); ctx.arc(xPos(i), yPos(data[i]), 4, 0, Math.PI * 2); ctx.fill();
  }
  // Dots: predicted
  ctx.fillStyle = '#fbbf24';
  for (let i = originalCount; i < data.length; i++) {
    ctx.beginPath(); ctx.arc(xPos(i), yPos(data[i]), 4, 0, Math.PI * 2); ctx.fill();
  }

  // Axis labels
  ctx.fillStyle = '#94a3b8'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
  data.forEach((_, i) => {
    if (data.length <= 30 || i % Math.ceil(data.length / 15) === 0) {
      ctx.fillText(i + 1, xPos(i), H - 8);
    }
  });

  // Legend
  ctx.font = '11px sans-serif';
  ctx.fillStyle = '#d97706';
  ctx.fillRect(W - 170, 10, 12, 12);
  ctx.fillStyle = '#64748b'; ctx.textAlign = 'left';
  ctx.fillText('Given terms', W - 154, 20);
  ctx.fillStyle = '#fbbf24';
  ctx.fillRect(W - 170, 28, 12, 12);
  ctx.fillStyle = '#64748b';
  ctx.fillText('Predicted', W - 154, 38);
}

/* ============================
   Resize handler
   ============================ */
let resizeTimer;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(() => {
    const activePanel = document.querySelector('.tab-panel.active');
    if (activePanel.id === 'panel-arithmetic') updateArithmetic();
    else if (activePanel.id === 'panel-geometric') updateGeometric();
    else if (activePanel.id === 'panel-fibonacci') updateFibonacci();
  }, 150);
});

/* ============================
   Initialise
   ============================ */
updateArithmetic();
updateGeometric();
updateFibonacci();
</script>
</body>
</html>
