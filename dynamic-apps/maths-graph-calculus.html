<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient &amp; Area Under a Curve - A-Level Mathematics</title>
    <style>
        /* CSS Reset and Base Styles */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --primary-blue: #2563eb;
            --primary-blue-light: #3b82f6;
            --primary-blue-dark: #1d4ed8;
            --primary-blue-pale: #dbeafe;
            --curve-colour: #2563eb;
            --tangent-colour: #dc2626;
            --deriv-colour: #7c3aed;
            --area-colour: rgba(34, 197, 94, 0.25);
            --area-stroke: #16a34a;
            --bound-colour: #f59e0b;
            --marker-colour: #dc2626;
            --axis-colour: #374151;
            --grid-colour: #e5e7eb;
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f1f5f9;
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --text-muted: #64748b;
            --border-colour: #cbd5e1;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            --radius-sm: 6px;
            --radius-md: 8px;
            --radius-lg: 12px;
        }

        html { font-size: 16px; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        /* Sticky Header */
        header {
            position: sticky;
            top: 0;
            z-index: 100;
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--primary-blue-light) 100%);
            color: white;
            padding: 1.25rem 2rem;
            text-align: center;
            box-shadow: var(--shadow-md);
        }

        header h1 {
            font-size: 1.6rem;
            font-weight: 700;
            margin-bottom: 0.15rem;
        }

        header p {
            font-size: 0.95rem;
            opacity: 0.9;
        }

        /* Main Layout */
        main {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1.5rem;
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 1.5rem;
        }

        /* Panels */
        .panel {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border-colour);
            box-shadow: var(--shadow-sm);
            padding: 1.25rem;
        }

        .panel h2 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--primary-blue-dark);
            border-bottom: 2px solid var(--primary-blue-pale);
            padding-bottom: 0.5rem;
        }

        .panel h3 {
            font-size: 0.95rem;
            font-weight: 600;
            margin: 1rem 0 0.5rem;
            color: var(--text-primary);
        }

        /* Controls */
        .control-group {
            margin-bottom: 1rem;
        }

        .control-group label {
            display: block;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 0.35rem;
        }

        select, input[type="number"] {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border-colour);
            border-radius: var(--radius-sm);
            font-size: 0.9rem;
            color: var(--text-primary);
            background: var(--bg-secondary);
            transition: border-color 0.2s;
        }

        select:focus, input[type="number"]:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15);
        }

        /* Readout Cards */
        .readout-card {
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            padding: 0.75rem 1rem;
            margin-bottom: 0.75rem;
            border-left: 3px solid var(--primary-blue);
        }

        .readout-card.gradient-card {
            border-left-color: var(--tangent-colour);
        }

        .readout-card.area-card {
            border-left-color: var(--area-stroke);
        }

        .readout-card.deriv-card {
            border-left-color: var(--deriv-colour);
        }

        .readout-label {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 0.15rem;
        }

        .readout-value {
            font-size: 1.15rem;
            font-weight: 700;
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
        }

        .readout-detail {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 0.15rem;
        }

        /* Canvas Area */
        .canvas-column {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }

        .canvas-wrapper {
            position: relative;
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border-colour);
            box-shadow: var(--shadow-sm);
            overflow: hidden;
        }

        .canvas-wrapper .canvas-title {
            padding: 0.6rem 1rem;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--primary-blue-dark);
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-colour);
        }

        canvas {
            display: block;
            width: 100%;
            cursor: crosshair;
        }

        /* Legend */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            padding: 0.6rem 1rem;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-colour);
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .legend-swatch {
            width: 14px;
            height: 3px;
            border-radius: 2px;
        }

        .legend-swatch.dashed {
            background: repeating-linear-gradient(
                90deg,
                var(--tangent-colour) 0, var(--tangent-colour) 4px,
                transparent 4px, transparent 7px
            );
            height: 2px;
        }

        .legend-swatch.area {
            width: 14px;
            height: 10px;
            background: var(--area-colour);
            border: 1px solid var(--area-stroke);
        }

        /* Info Panel */
        .info-panel {
            margin-top: 1rem;
        }

        .info-toggle {
            width: 100%;
            padding: 0.6rem 1rem;
            background: var(--primary-blue-pale);
            color: var(--primary-blue-dark);
            border: 1px solid var(--primary-blue);
            border-radius: var(--radius-sm);
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            text-align: left;
            transition: background-color 0.2s;
        }

        .info-toggle:hover {
            background: #bfdbfe;
        }

        .info-toggle::after {
            content: ' +';
            float: right;
        }

        .info-toggle.open::after {
            content: ' \2212';
        }

        .info-content {
            display: none;
            padding: 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-colour);
            border-top: none;
            border-radius: 0 0 var(--radius-sm) var(--radius-sm);
            font-size: 0.85rem;
            line-height: 1.65;
            color: var(--text-secondary);
        }

        .info-content.open {
            display: block;
        }

        .info-content p {
            margin-bottom: 0.75rem;
        }

        .info-content strong {
            color: var(--text-primary);
        }

        .formula {
            display: inline-block;
            background: var(--bg-secondary);
            border: 1px solid var(--border-colour);
            border-radius: var(--radius-sm);
            padding: 0.15rem 0.5rem;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            color: var(--primary-blue-dark);
        }

        /* Instruction hint */
        .hint {
            font-size: 0.8rem;
            color: var(--text-muted);
            font-style: italic;
            margin-bottom: 0.75rem;
            padding: 0.5rem;
            background: #fffbeb;
            border-radius: var(--radius-sm);
            border: 1px solid #fef3c7;
        }

        /* Function expression display */
        .fn-display {
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            font-weight: 700;
            color: var(--curve-colour);
            text-align: center;
            padding: 0.5rem;
            margin-bottom: 0.75rem;
            background: var(--primary-blue-pale);
            border-radius: var(--radius-sm);
        }

        /* Responsive */
        @media (max-width: 768px) {
            header { padding: 1rem; }
            header h1 { font-size: 1.25rem; }
            header p { font-size: 0.85rem; }

            main {
                grid-template-columns: 1fr;
                padding: 1rem;
                gap: 1rem;
            }

            .panel { padding: 1rem; }
        }
    </style>
</head>
<body>
    <header>
        <h1>Gradient &amp; Area Under a Curve</h1>
        <p>Explore differentiation and integration visually (A-Level Mathematics)</p>
    </header>

    <main>
        <!-- Controls Sidebar -->
        <div class="controls-sidebar">
            <div class="panel">
                <h2>Function</h2>
                <div class="control-group">
                    <label for="fn-select">Choose a function</label>
                    <select id="fn-select">
                        <option value="quadratic">y = x&sup2;</option>
                        <option value="cubic">y = x&sup3; &minus; 3x</option>
                        <option value="sine">y = sin(x)</option>
                        <option value="exponential">y = e^x</option>
                        <option value="reciprocal">y = 1/x</option>
                    </select>
                </div>
                <div class="fn-display" id="fn-display">y = x&sup2;</div>
                <div class="hint">Drag the red marker along the curve to change the tangent point. Drag the amber lines to adjust the integration bounds.</div>
            </div>

            <div class="panel">
                <h2>Readouts</h2>

                <div class="readout-card gradient-card">
                    <div class="readout-label">Tangent Point</div>
                    <div class="readout-value" id="readout-point">(0.00, 0.00)</div>
                </div>

                <div class="readout-card gradient-card">
                    <div class="readout-label">Gradient (dy/dx)</div>
                    <div class="readout-value" id="readout-gradient">0.00</div>
                    <div class="readout-detail" id="readout-gradient-detail"></div>
                </div>

                <div class="readout-card area-card">
                    <div class="readout-label">Definite Integral (Area)</div>
                    <div class="readout-value" id="readout-area">0.00</div>
                    <div class="readout-detail" id="readout-area-detail"></div>
                </div>

                <div class="readout-card deriv-card">
                    <div class="readout-label">Derivative Function</div>
                    <div class="readout-value" id="readout-deriv-fn">dy/dx = 2x</div>
                </div>
            </div>

            <div class="panel info-panel">
                <button class="info-toggle" id="info-toggle-diff">About Differentiation</button>
                <div class="info-content" id="info-content-diff">
                    <p><strong>Differentiation</strong> finds the rate of change of a function at any point. Geometrically, the derivative at a point equals the gradient of the tangent line to the curve at that point.</p>
                    <p>For a function <span class="formula">y = f(x)</span>, the derivative is written as <span class="formula">dy/dx</span> or <span class="formula">f'(x)</span>.</p>
                    <p>The <strong>power rule</strong> states that if <span class="formula">y = x^n</span>, then <span class="formula">dy/dx = nx^(n-1)</span>.</p>
                    <p>A positive gradient means the function is increasing; a negative gradient means it is decreasing. Where the gradient equals zero, the function has a stationary point.</p>
                </div>
            </div>

            <div class="panel info-panel" style="margin-top: 0.5rem;">
                <button class="info-toggle" id="info-toggle-int">About Integration</button>
                <div class="info-content" id="info-content-int">
                    <p><strong>Integration</strong> is the reverse of differentiation. A definite integral calculates the net signed area between the curve and the x-axis over an interval [a, b].</p>
                    <p>The notation is <span class="formula">&int;<sub>a</sub><sup>b</sup> f(x) dx</span>. Areas above the x-axis are positive; areas below are negative.</p>
                    <p>The <strong>Fundamental Theorem of Calculus</strong> connects differentiation and integration: if F is an antiderivative of f, then <span class="formula">&int;<sub>a</sub><sup>b</sup> f(x) dx = F(b) &minus; F(a)</span>.</p>
                    <p>The shaded region on the graph shows this area visually. Drag the amber bound lines to change the limits of integration.</p>
                </div>
            </div>
        </div>

        <!-- Canvas Column -->
        <div class="canvas-column">
            <div class="canvas-wrapper">
                <div class="canvas-title">f(x) with Tangent Line and Shaded Area</div>
                <canvas id="main-canvas"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-swatch" style="background: var(--curve-colour);"></div>
                        <span>f(x)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-swatch dashed"></div>
                        <span>Tangent</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-swatch area"></div>
                        <span>Integral area</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-swatch" style="background: var(--bound-colour);"></div>
                        <span>Bounds</span>
                    </div>
                </div>
            </div>

            <div class="canvas-wrapper">
                <div class="canvas-title">f'(x) (Derivative)</div>
                <canvas id="deriv-canvas"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-swatch" style="background: var(--deriv-colour);"></div>
                        <span>f'(x)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-swatch" style="background: var(--marker-colour); width: 8px; height: 8px; border-radius: 50%;"></div>
                        <span>Current gradient</span>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        /* ======================================================
           Gradient & Area Under a Curve
           A-Level Mathematics Interactive Tool
           ====================================================== */

        // ---- DOM References ----
        const fnSelect = document.getElementById('fn-select');
        const fnDisplay = document.getElementById('fn-display');
        const mainCanvas = document.getElementById('main-canvas');
        const derivCanvas = document.getElementById('deriv-canvas');
        const mainCtx = mainCanvas.getContext('2d');
        const derivCtx = derivCanvas.getContext('2d');

        const readoutPoint = document.getElementById('readout-point');
        const readoutGradient = document.getElementById('readout-gradient');
        const readoutGradientDetail = document.getElementById('readout-gradient-detail');
        const readoutArea = document.getElementById('readout-area');
        const readoutAreaDetail = document.getElementById('readout-area-detail');
        const readoutDerivFn = document.getElementById('readout-deriv-fn');

        // ---- Info panel toggles ----
        document.querySelectorAll('.info-toggle').forEach(btn => {
            btn.addEventListener('click', () => {
                const content = btn.nextElementSibling;
                btn.classList.toggle('open');
                content.classList.toggle('open');
            });
        });

        // ---- Function Definitions ----
        const functions = {
            quadratic: {
                label: 'y = x\u00B2',
                derivLabel: "dy/dx = 2x",
                f: x => x * x,
                df: x => 2 * x,
                xRange: [-5, 5],
                yRange: [-2, 26],
                derivYRange: [-10, 10],
                defaultTangentX: 1.5,
                defaultBounds: [-1, 3]
            },
            cubic: {
                label: 'y = x\u00B3 \u2212 3x',
                derivLabel: "dy/dx = 3x\u00B2 \u2212 3",
                f: x => x * x * x - 3 * x,
                df: x => 3 * x * x - 3,
                xRange: [-3, 3],
                yRange: [-6, 6],
                derivYRange: [-4, 25],
                defaultTangentX: 1,
                defaultBounds: [-1, 2]
            },
            sine: {
                label: 'y = sin(x)',
                derivLabel: "dy/dx = cos(x)",
                f: x => Math.sin(x),
                df: x => Math.cos(x),
                xRange: [-2 * Math.PI, 2 * Math.PI],
                yRange: [-1.8, 1.8],
                derivYRange: [-1.8, 1.8],
                defaultTangentX: 1,
                defaultBounds: [0, Math.PI]
            },
            exponential: {
                label: 'y = e\u02E3',
                derivLabel: "dy/dx = e\u02E3",
                f: x => Math.exp(x),
                df: x => Math.exp(x),
                xRange: [-3, 3],
                yRange: [-1, 20],
                derivYRange: [-1, 20],
                defaultTangentX: 1,
                defaultBounds: [0, 2]
            },
            reciprocal: {
                label: 'y = 1/x',
                derivLabel: "dy/dx = \u22121/x\u00B2",
                f: x => (Math.abs(x) < 0.05) ? NaN : 1 / x,
                df: x => (Math.abs(x) < 0.05) ? NaN : -1 / (x * x),
                xRange: [-5, 5],
                yRange: [-6, 6],
                derivYRange: [-10, 2],
                defaultTangentX: 1,
                defaultBounds: [0.5, 3]
            }
        };

        // ---- State ----
        let currentFnKey = 'quadratic';
        let tangentX = 1.5;
        let boundA = -1;
        let boundB = 3;
        let dragging = null; // 'tangent', 'boundA', 'boundB'
        let mainDPR = 1;
        let derivDPR = 1;
        let mainRect = { w: 0, h: 0 };
        let derivRect = { w: 0, h: 0 };

        // Padding for canvas coordinate systems (pixels at 1x)
        const PAD = { top: 20, right: 20, bottom: 30, left: 45 };

        // ---- Utility: map between graph coords and canvas pixels ----
        function graphToCanvas(x, y, xRange, yRange, w, h) {
            const plotW = w - PAD.left - PAD.right;
            const plotH = h - PAD.top - PAD.bottom;
            const px = PAD.left + (x - xRange[0]) / (xRange[1] - xRange[0]) * plotW;
            const py = PAD.top + (1 - (y - yRange[0]) / (yRange[1] - yRange[0])) * plotH;
            return [px, py];
        }

        function canvasToGraphX(px, xRange, w) {
            const plotW = w - PAD.left - PAD.right;
            return xRange[0] + (px - PAD.left) / plotW * (xRange[1] - xRange[0]);
        }

        // ---- Numerical integration (Simpson's rule) ----
        function integrate(f, a, b, n) {
            if (a === b) return 0;
            if (a > b) return -integrate(f, b, a, n);
            if (n % 2 !== 0) n++;
            const h = (b - a) / n;
            let sum = f(a) + f(b);
            for (let i = 1; i < n; i++) {
                const xi = a + i * h;
                const val = f(xi);
                if (!isFinite(val)) return NaN;
                sum += (i % 2 === 0 ? 2 : 4) * val;
            }
            return (h / 3) * sum;
        }

        // ---- Canvas sizing ----
        function sizeCanvas(canvas, ctx, desiredH) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.parentElement.getBoundingClientRect();
            const w = Math.floor(rect.width);
            const h = desiredH || Math.floor(w * 0.55);
            canvas.width = w * dpr;
            canvas.height = h * dpr;
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            return { w, h, dpr };
        }

        function sizeAllCanvases() {
            const m = sizeCanvas(mainCanvas, mainCtx);
            mainRect = { w: m.w, h: m.h };
            mainDPR = m.dpr;

            const d = sizeCanvas(derivCanvas, derivCtx, Math.floor(m.w * 0.35));
            derivRect = { w: d.w, h: d.h };
            derivDPR = d.dpr;
        }

        // ---- Drawing helpers ----
        function drawGrid(ctx, xRange, yRange, w, h) {
            const plotW = w - PAD.left - PAD.right;
            const plotH = h - PAD.top - PAD.bottom;

            ctx.save();
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 0.5;

            // Choose sensible tick spacing
            function niceStep(range) {
                const span = range[1] - range[0];
                const raw = span / 10;
                const mag = Math.pow(10, Math.floor(Math.log10(raw)));
                const norm = raw / mag;
                if (norm < 1.5) return mag;
                if (norm < 3.5) return 2 * mag;
                if (norm < 7.5) return 5 * mag;
                return 10 * mag;
            }

            const xStep = niceStep(xRange);
            const yStep = niceStep(yRange);

            // Vertical grid lines
            let xStart = Math.ceil(xRange[0] / xStep) * xStep;
            for (let gx = xStart; gx <= xRange[1]; gx += xStep) {
                const [px] = graphToCanvas(gx, 0, xRange, yRange, w, h);
                ctx.beginPath();
                ctx.moveTo(px, PAD.top);
                ctx.lineTo(px, PAD.top + plotH);
                ctx.stroke();
            }

            // Horizontal grid lines
            let yStart = Math.ceil(yRange[0] / yStep) * yStep;
            for (let gy = yStart; gy <= yRange[1]; gy += yStep) {
                const [, py] = graphToCanvas(0, gy, xRange, yRange, w, h);
                ctx.beginPath();
                ctx.moveTo(PAD.left, py);
                ctx.lineTo(PAD.left + plotW, py);
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawAxes(ctx, xRange, yRange, w, h) {
            const plotW = w - PAD.left - PAD.right;
            const plotH = h - PAD.top - PAD.bottom;

            ctx.save();
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 1.5;

            // x-axis
            const [, yAxisPx] = graphToCanvas(0, 0, xRange, yRange, w, h);
            if (yAxisPx >= PAD.top && yAxisPx <= PAD.top + plotH) {
                ctx.beginPath();
                ctx.moveTo(PAD.left, yAxisPx);
                ctx.lineTo(PAD.left + plotW, yAxisPx);
                ctx.stroke();
            }

            // y-axis
            const [xAxisPx] = graphToCanvas(0, 0, xRange, yRange, w, h);
            if (xAxisPx >= PAD.left && xAxisPx <= PAD.left + plotW) {
                ctx.beginPath();
                ctx.moveTo(xAxisPx, PAD.top);
                ctx.lineTo(xAxisPx, PAD.top + plotH);
                ctx.stroke();
            }

            // Tick labels
            ctx.fillStyle = '#64748b';
            ctx.font = '11px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            function niceStep(range) {
                const span = range[1] - range[0];
                const raw = span / 10;
                const mag = Math.pow(10, Math.floor(Math.log10(raw)));
                const norm = raw / mag;
                if (norm < 1.5) return mag;
                if (norm < 3.5) return 2 * mag;
                if (norm < 7.5) return 5 * mag;
                return 10 * mag;
            }

            const xStep = niceStep(xRange);
            const yStep = niceStep(yRange);

            // x tick labels
            let xStart = Math.ceil(xRange[0] / xStep) * xStep;
            const labelY = Math.min(Math.max(yAxisPx + 4, PAD.top), PAD.top + plotH - 12);
            for (let gx = xStart; gx <= xRange[1]; gx += xStep) {
                if (Math.abs(gx) < xStep * 0.01) continue;
                const [px] = graphToCanvas(gx, 0, xRange, yRange, w, h);
                const lbl = Math.abs(gx) < 0.001 ? '0' : parseFloat(gx.toPrecision(4)).toString();
                ctx.fillText(lbl, px, labelY);
            }

            // y tick labels
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            let yTStart = Math.ceil(yRange[0] / yStep) * yStep;
            const labelX = Math.max(Math.min(xAxisPx - 6, PAD.left + plotW), PAD.left - 2);
            for (let gy = yTStart; gy <= yRange[1]; gy += yStep) {
                if (Math.abs(gy) < yStep * 0.01) continue;
                const [, py] = graphToCanvas(0, gy, xRange, yRange, w, h);
                const lbl = Math.abs(gy) < 0.001 ? '0' : parseFloat(gy.toPrecision(4)).toString();
                ctx.fillText(lbl, labelX, py);
            }

            ctx.restore();
        }

        function drawCurve(ctx, f, xRange, yRange, w, h, colour, lineWidth, dashed) {
            const plotW = w - PAD.left - PAD.right;
            const steps = Math.max(plotW * 2, 400);
            const dx = (xRange[1] - xRange[0]) / steps;

            ctx.save();
            ctx.strokeStyle = colour;
            ctx.lineWidth = lineWidth || 2;
            if (dashed) ctx.setLineDash(dashed);
            ctx.lineJoin = 'round';
            ctx.beginPath();

            let started = false;
            for (let i = 0; i <= steps; i++) {
                const x = xRange[0] + i * dx;
                const y = f(x);
                if (!isFinite(y) || isNaN(y)) {
                    started = false;
                    continue;
                }
                const [px, py] = graphToCanvas(x, y, xRange, yRange, w, h);
                if (!started) {
                    ctx.moveTo(px, py);
                    started = true;
                } else {
                    ctx.lineTo(px, py);
                }
            }
            ctx.stroke();
            ctx.restore();
        }

        function drawShadedArea(ctx, f, a, b, xRange, yRange, w, h) {
            if (a > b) { let tmp = a; a = b; b = tmp; }
            const plotW = w - PAD.left - PAD.right;
            const steps = Math.max(Math.floor(plotW), 200);
            const dx = (b - a) / steps;

            const [, zeroY] = graphToCanvas(0, 0, xRange, yRange, w, h);

            ctx.save();
            ctx.fillStyle = 'rgba(34, 197, 94, 0.2)';
            ctx.strokeStyle = '#16a34a';
            ctx.lineWidth = 1;
            ctx.beginPath();

            // Start from x-axis at bound a
            const [startPx] = graphToCanvas(a, 0, xRange, yRange, w, h);
            ctx.moveTo(startPx, zeroY);

            for (let i = 0; i <= steps; i++) {
                const x = a + i * dx;
                const y = f(x);
                if (!isFinite(y) || isNaN(y)) continue;
                const [px, py] = graphToCanvas(x, y, xRange, yRange, w, h);
                ctx.lineTo(px, py);
            }

            // Back down to x-axis at bound b
            const [endPx] = graphToCanvas(b, 0, xRange, yRange, w, h);
            ctx.lineTo(endPx, zeroY);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }

        function drawBoundLine(ctx, xVal, xRange, yRange, w, h, label) {
            const plotH = h - PAD.top - PAD.bottom;
            const [px] = graphToCanvas(xVal, 0, xRange, yRange, w, h);

            ctx.save();
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 2;
            ctx.setLineDash([6, 3]);
            ctx.beginPath();
            ctx.moveTo(px, PAD.top);
            ctx.lineTo(px, PAD.top + plotH);
            ctx.stroke();

            // Handle at top
            ctx.setLineDash([]);
            ctx.fillStyle = '#f59e0b';
            ctx.beginPath();
            ctx.arc(px, PAD.top + 10, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#b45309';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Label
            ctx.fillStyle = '#92400e';
            ctx.font = 'bold 11px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(label + ' = ' + xVal.toFixed(2), px, PAD.top - 2);
            ctx.restore();
        }

        function drawTangentLine(ctx, f, df, xVal, xRange, yRange, w, h) {
            const y0 = f(xVal);
            const m = df(xVal);
            if (!isFinite(y0) || !isFinite(m)) return;

            // Draw tangent across visible range
            const span = xRange[1] - xRange[0];
            const ext = span * 0.4;
            const x1 = xVal - ext;
            const x2 = xVal + ext;
            const y1 = y0 + m * (x1 - xVal);
            const y2 = y0 + m * (x2 - xVal);

            ctx.save();
            ctx.strokeStyle = '#dc2626';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([5, 4]);

            const [px1, py1] = graphToCanvas(x1, y1, xRange, yRange, w, h);
            const [px2, py2] = graphToCanvas(x2, y2, xRange, yRange, w, h);

            ctx.beginPath();
            ctx.moveTo(px1, py1);
            ctx.lineTo(px2, py2);
            ctx.stroke();
            ctx.restore();

            // Draw the marker point
            const [mpx, mpy] = graphToCanvas(xVal, y0, xRange, yRange, w, h);
            ctx.save();
            ctx.fillStyle = '#dc2626';
            ctx.beginPath();
            ctx.arc(mpx, mpy, 7, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
        }

        function drawDerivMarker(ctx, df, xVal, xRange, yRange, w, h) {
            const dy = df(xVal);
            if (!isFinite(dy)) return;
            const [px, py] = graphToCanvas(xVal, dy, xRange, yRange, w, h);

            ctx.save();
            ctx.fillStyle = '#dc2626';
            ctx.beginPath();
            ctx.arc(px, py, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.restore();
        }

        // ---- Main render ----
        function render() {
            const fn = functions[currentFnKey];
            const { f, df, xRange, yRange, derivYRange } = fn;

            // Clear
            mainCtx.clearRect(0, 0, mainRect.w, mainRect.h);
            derivCtx.clearRect(0, 0, derivRect.w, derivRect.h);

            // Main canvas
            drawGrid(mainCtx, xRange, yRange, mainRect.w, mainRect.h);
            drawAxes(mainCtx, xRange, yRange, mainRect.w, mainRect.h);
            drawShadedArea(mainCtx, f, boundA, boundB, xRange, yRange, mainRect.w, mainRect.h);
            drawCurve(mainCtx, f, xRange, yRange, mainRect.w, mainRect.h, '#2563eb', 2.5);
            drawBoundLine(mainCtx, boundA, xRange, yRange, mainRect.w, mainRect.h, 'a');
            drawBoundLine(mainCtx, boundB, xRange, yRange, mainRect.w, mainRect.h, 'b');
            drawTangentLine(mainCtx, f, df, tangentX, xRange, yRange, mainRect.w, mainRect.h);

            // Derivative canvas
            drawGrid(derivCtx, xRange, derivYRange, derivRect.w, derivRect.h);
            drawAxes(derivCtx, xRange, derivYRange, derivRect.w, derivRect.h);
            drawCurve(derivCtx, df, xRange, derivYRange, derivRect.w, derivRect.h, '#7c3aed', 2);
            drawDerivMarker(derivCtx, df, tangentX, xRange, derivYRange, derivRect.w, derivRect.h);

            // Update readouts
            const yVal = f(tangentX);
            const grad = df(tangentX);
            readoutPoint.textContent = '(' + tangentX.toFixed(2) + ', ' + (isFinite(yVal) ? yVal.toFixed(2) : 'undefined') + ')';
            readoutGradient.textContent = isFinite(grad) ? grad.toFixed(4) : 'undefined';

            if (isFinite(grad)) {
                if (Math.abs(grad) < 0.005) {
                    readoutGradientDetail.textContent = 'Stationary point (gradient \u2248 0)';
                } else if (grad > 0) {
                    readoutGradientDetail.textContent = 'Function is increasing';
                } else {
                    readoutGradientDetail.textContent = 'Function is decreasing';
                }
            } else {
                readoutGradientDetail.textContent = 'Not defined at this point';
            }

            const areaVal = integrate(f, Math.min(boundA, boundB), Math.max(boundA, boundB), 200);
            const signedArea = boundA <= boundB ? areaVal : -areaVal;
            readoutArea.textContent = isFinite(signedArea) ? signedArea.toFixed(4) : 'undefined';

            const aLbl = Math.min(boundA, boundB).toFixed(2);
            const bLbl = Math.max(boundA, boundB).toFixed(2);
            readoutAreaDetail.textContent = '\u222B from ' + aLbl + ' to ' + bLbl;

            readoutDerivFn.textContent = fn.derivLabel;
        }

        // ---- Interaction: dragging ----
        function getMouseX(e, canvas) {
            const rect = canvas.getBoundingClientRect();
            return (e.clientX - rect.left);
        }

        function getTouchX(e, canvas) {
            const rect = canvas.getBoundingClientRect();
            return (e.touches[0].clientX - rect.left);
        }

        function hitTest(canvasPx, xRange, w) {
            const fn = functions[currentFnKey];
            const graphX = canvasToGraphX(canvasPx, xRange, w);

            // Check tangent marker
            const [markerPx] = graphToCanvas(tangentX, fn.f(tangentX), xRange, fn.yRange, w, mainRect.h);
            if (Math.abs(canvasPx - markerPx) < 15) return 'tangent';

            // Check bound lines
            const [boundAPx] = graphToCanvas(boundA, 0, xRange, fn.yRange, w, mainRect.h);
            if (Math.abs(canvasPx - boundAPx) < 12) return 'boundA';

            const [boundBPx] = graphToCanvas(boundB, 0, xRange, fn.yRange, w, mainRect.h);
            if (Math.abs(canvasPx - boundBPx) < 12) return 'boundB';

            return null;
        }

        function clampToRange(val, range) {
            return Math.max(range[0] + 0.01, Math.min(range[1] - 0.01, val));
        }

        function handleDragStart(px) {
            const fn = functions[currentFnKey];
            dragging = hitTest(px, fn.xRange, mainRect.w);
            if (dragging) {
                mainCanvas.style.cursor = 'grabbing';
            }
        }

        function handleDragMove(px) {
            if (!dragging) {
                // Update cursor
                const fn = functions[currentFnKey];
                const hit = hitTest(px, fn.xRange, mainRect.w);
                mainCanvas.style.cursor = hit ? 'grab' : 'crosshair';
                return;
            }

            const fn = functions[currentFnKey];
            const graphX = canvasToGraphX(px, fn.xRange, mainRect.w);
            const clamped = clampToRange(graphX, fn.xRange);

            if (dragging === 'tangent') {
                // For reciprocal, skip near zero
                if (currentFnKey === 'reciprocal' && Math.abs(clamped) < 0.1) return;
                tangentX = clamped;
            } else if (dragging === 'boundA') {
                if (currentFnKey === 'reciprocal' && Math.abs(clamped) < 0.1) return;
                boundA = clamped;
            } else if (dragging === 'boundB') {
                if (currentFnKey === 'reciprocal' && Math.abs(clamped) < 0.1) return;
                boundB = clamped;
            }
            render();
        }

        function handleDragEnd() {
            dragging = null;
            mainCanvas.style.cursor = 'crosshair';
        }

        // Mouse events
        mainCanvas.addEventListener('mousedown', e => {
            handleDragStart(getMouseX(e, mainCanvas));
        });

        window.addEventListener('mousemove', e => {
            if (dragging) {
                const rect = mainCanvas.getBoundingClientRect();
                handleDragMove(e.clientX - rect.left);
            }
        });

        mainCanvas.addEventListener('mousemove', e => {
            if (!dragging) {
                handleDragMove(getMouseX(e, mainCanvas));
            }
        });

        window.addEventListener('mouseup', handleDragEnd);

        // Touch events
        mainCanvas.addEventListener('touchstart', e => {
            e.preventDefault();
            handleDragStart(getTouchX(e, mainCanvas));
        }, { passive: false });

        window.addEventListener('touchmove', e => {
            if (dragging) {
                const rect = mainCanvas.getBoundingClientRect();
                handleDragMove(e.touches[0].clientX - rect.left);
            }
        }, { passive: false });

        window.addEventListener('touchend', handleDragEnd);

        // ---- Function selector ----
        fnSelect.addEventListener('change', () => {
            currentFnKey = fnSelect.value;
            const fn = functions[currentFnKey];
            fnDisplay.textContent = fn.label;
            tangentX = fn.defaultTangentX;
            boundA = fn.defaultBounds[0];
            boundB = fn.defaultBounds[1];
            render();
        });

        // ---- Resize handling ----
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                sizeAllCanvases();
                render();
            }, 80);
        });

        // ---- Initialise ----
        function init() {
            sizeAllCanvases();
            render();
        }

        init();
    </script>
</body>
</html>
